[{"authors":["admin"],"categories":null,"content":"简简单单知道什么是不够的，我需要知道为什么。\n这个博客就是记录我日常出现的问题。 本站所有内容均代表个人观点。\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://cytgenkidu.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"简简单单知道什么是不够的，我需要知道为什么。\n这个博客就是记录我日常出现的问题。 本站所有内容均代表个人观点。","tags":null,"title":"Tgenkidu Cy","type":"author"},{"authors":null,"categories":null,"content":"谭浩强版 http://www.doc88.com/p-6874780272508.html https://blog.csdn.net/yinzh12138/article/details/88116714 https://zhuanlan.zhihu.com/p/99716315?utm_source=wechat_session https://wenku.baidu.com/view/6c04c405f71fb7360b4c2e3f5727a5e9846a27e5.html\n鹏哥 https://www.bilibili.com/video/BV1TT4y1F7Z9\n工具VSCode参考\nVisual Studio 2017\n","date":1609977600,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1610064000,"objectID":"259d5778f549372413a89e88447bac9f","permalink":"https://cytgenkidu.github.io/tutorial/c/","publishdate":"2021-01-07T00:00:00Z","relpermalink":"/tutorial/c/","section":"tutorial","summary":"C语言重点知识点。","tags":null,"title":"概述","type":"docs"},{"authors":null,"categories":null,"content":"Java是面向对象程序设计语言和Java平台的总称。\n","date":1559779200,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1559779200,"objectID":"4fb39987d20ba3d36e9f9f950bf26e56","permalink":"https://cytgenkidu.github.io/tutorial/java/","publishdate":"2019-06-06T00:00:00Z","relpermalink":"/tutorial/java/","section":"tutorial","summary":"学习Java程序员需要掌握的知识和技能。","tags":null,"title":"概述","type":"docs"},{"authors":null,"categories":null,"content":" Flexibility This feature can be used for publishing content such as:\n Online courses Project or software documentation Tutorials  The courses folder may be renamed. For example, we can rename it to docs for software/project documentation or tutorials for creating an online course.\nDelete tutorials To remove these pages, delete the courses folder and see below to delete the associated menu link.\nUpdate site menu After renaming or deleting the courses folder, you may wish to update any [[main]] menu links to it by editing your menu configuration at config/_default/menus.toml.\nFor example, if you delete this folder, you can remove the following from your menu configuration:\n[[main]] name = \u0026quot;Courses\u0026quot; url = \u0026quot;courses/\u0026quot; weight = 50  Or, if you are creating a software documentation site, you can rename the courses folder to docs and update the associated Courses menu configuration to:\n[[main]] name = \u0026quot;Docs\u0026quot; url = \u0026quot;docs/\u0026quot; weight = 50  Update the docs menu If you use the docs layout, note that the name of the menu in the front matter should be in the form [menu.X] where X is the folder name. Hence, if you rename the courses/example/ folder, you should also rename the menu definitions in the front matter of files within courses/example/ from [menu.example] to [menu.\u0026lt;NewFolderName\u0026gt;].\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1536451200,"objectID":"63daa48e8c204a40ad608c9288c06ffc","permalink":"https://cytgenkidu.github.io/tutorial/example/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/tutorial/example/","section":"tutorial","summary":"Learn how to use Academic's docs layout for publishing online courses, software documentation, and tutorials.","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":"","date":1617750000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1617750000,"objectID":"7e08867e6a6bdc614490c7d0bbcdb1e4","permalink":"https://cytgenkidu.github.io/tutorial/java/1/","publishdate":"2021-04-07T00:00:00+01:00","relpermalink":"/tutorial/java/1/","section":"tutorial","summary":"","tags":null,"title":"基本概念","type":"docs"},{"authors":null,"categories":null,"content":" 什么是C语言？ C语言是一门计算机语言\n计算机语言是什么？人和计算机交流的语言 C/C++/java/python\n语言的发展：低级语言→高级语言\n 010001000-机器语言【二进制语言 硬件-电-正电/负电】 汇编语言 B语言 C语言、C++\u0026mdash;高级语言  C语言→早期不是很成熟→成熟→流行 国际标准ANSIC-C89/C90 、 C99/C11并不流行\n#include \u0026lt;stdio.h\u0026gt; int main() //main函数是程序的入口,一个工程中main函数有且仅有一个 { printf(\u0026quot;hello\\n\u0026quot;); printf(\u0026quot;he he\\n\u0026quot;); return 0; }  数据类型  char - 字符数据类型 1 short - 短整型 2 int - 整形 4 long - 长整型 4 long long -更长的整形 8 float -单精度浮点数 4 double -双精度浮点数 8  char ch = 'As'; int a = 0; float b = 1.22f; double c = 1.23; printf(\u0026quot;char: %c\\n\u0026quot;, ch); printf(\u0026quot;int: %d\\n\u0026quot;, a); //整形 printf(\u0026quot;float: %f\\n\u0026quot;, b); printf(\u0026quot;double: %lf\\n\u0026quot;, c); printf(\u0026quot;%d\\n\u0026quot;, sizeof(char)); //1个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(short)); //2 printf(\u0026quot;%d\\n\u0026quot;, sizeof(int)); //4 printf(\u0026quot;%d\\n\u0026quot;, sizeof(long)); //4\\8 printf(\u0026quot;%d\\n\u0026quot;, sizeof(long long)); //8 printf(\u0026quot;%d\\n\u0026quot;, sizeof(float)); //4 printf(\u0026quot;%d\\n\u0026quot;, sizeof(double)); //8  变量、常量 变量 分类  局部变量 全局变量  【当局部变量和全局变量同名时，局部变量优先使用】\n如何使用 scanf \\ printf\n#include \u0026lt;stdio.h\u0026gt; int main() { int num1, num2; //C语言语法规定，变量要定义在当前代码块的最前面 scanf(\u0026quot;%d,%d\u0026quot;, \u0026amp;num1, \u0026amp;num2); //取地址符号\u0026amp; printf(\u0026quot;sum= %d\\n\u0026quot;, num1 + num2); return 0; }  作用域：（限定的这个名字的可用性的代码范围） 作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的, 而限定这个名字的可用性的代码范围就是这个名字的作用域。\n 局部变量的作用域是变量所在局部范围。 全局变量的作用域是整个工程。  生命周期：变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段  局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束。 全局变量的生命周期是：整个程序的生命周期。  常量 字面变量\nconst 修饰的常变量：是变量，但又有常属性，所以是常变量\n#define 定义的标识符常量\n枚举常量\n#include \u0026lt;stdio.h\u0026gt; enum Sex //枚举常量 { MALE, FEMALE, SECERT }; int main() { enum Sex s = FEMALE; printf(\u0026quot;%d\\n\u0026quot;, MALE); //0 printf(\u0026quot;%d\\n\u0026quot;, FEMALE); //1 printf(\u0026quot;%d\\n\u0026quot;, SECERT); //2 return 0; }  字符串、转义字符、注释 字符串(%s\\n) #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char arr1[] = \u0026quot;abc\u0026quot;; char arr2[] = {'a', 'b', 'c'}; char arr3[] = {'a', 'b', 'c', 0}; printf(\u0026quot;%s\\n\u0026quot;, arr1); // abc printf(\u0026quot;%s\\n\u0026quot;, arr2); // abcabc printf(\u0026quot;%s\\n\u0026quot;, arr3); // abc printf(\u0026quot;%d\\n\u0026quot;, strlen(arr1)); // 3 printf(\u0026quot;%d\\n\u0026quot;, strlen(arr2)); // 6 未知 printf(\u0026quot;%d\\n\u0026quot;, strlen(arr3)); // 3 printf(\u0026quot;%d\\n\u0026quot;, strlen(\u0026quot;c:\\test\\32\\test.c\u0026quot;)); // 13 printf(\u0026quot;%s\\n\u0026quot;, \u0026quot;\\32\u0026quot;); // // \\t是一个字符 // \\32也是一个转移字符，是32作为八进制代表的十进制数字，作为ASCII码值,对应的字符 // 32---\u0026gt;10进制26【3*8^1+2*8^0】--\u0026gt;作为ASCII码代表的字符 printf(\u0026quot;%s\\n\u0026quot;, \u0026quot;\\130\u0026quot;); //X printf(\u0026quot;%s\\n\u0026quot;, \u0026quot;\\x30\u0026quot;); //0 }  这种由双引号（Double Quote）引起来的一串字符称为字符串字面值（String Literal）,或者建成字符串 注：字符串的结束标志是一个\\0的转义字符。在计算字符串长度的时候\\0是结束标志，不算做字符串内容。\n转义字符【\\】 注意：\n 区分，斜杠：\u0026rdquo;/\u0026rdquo; 与 反斜杠：\u0026rdquo;\\\u0026rdquo; ,此处不可互换 \\xhh 十六进制转义不限制字符个数 \u0026lsquo;\\x000000000000F\u0026rsquo; == \u0026lsquo;\\xF\u0026rsquo;  注释 作用  代码中有不需要的代码可以直接删除，也可以注释 代码中有些代码比较难懂，可以加一下注释文字  形式  C语言风格的注释/*xxxxxxx*/： 缺陷：不能嵌套注释 C++注释风格//xxxxx：可以注释一行也可以注释多行  选择语句 循环语句 函数：特点是简化代码，代码复用 数组 定义：一组相同类型元素的集合 使用 操作符  算数操作符：  + - * / %   移位操作符：  \u0026gt;\u0026gt; \u0026lt;\u0026lt; --- 移动二进制位   位操作符：  \u0026amp; ^ |   赋值操作符：  = += -= /= \u0026amp;= ^= |= \u0026gt;\u0026gt;= \u0026lt;\u0026lt;=   单目操作符：  ! 逻辑反操作 - 负值 + 正值 \u0026amp; 取地址 sizeof 操作数的类型长度（以字节为单位） ~ 对一个数的二进制按位取反 -- 前置、后置-- ++ 前置、后置++ * 间接访问操作符(解引用操作符) (类型) 强制类型转换  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int a = 10; int arr[] = {1, 2, 3, 4, 5, 6}; printf(\u0026quot;%d\\n\u0026quot;, sizeof(a)); //4 printf(\u0026quot;%d\\n\u0026quot;, sizeof(int)); //4 printf(\u0026quot;%d\\n\u0026quot;, sizeof a); //4 //printf(\u0026quot;%d\\n\u0026quot;, sizeof int; //err printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr)); //24 printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr) / sizeof(arr[0])); //6 return 0; }  注：原码、反码、补码\n 只要是整数，内存中存储的都是二进制补码 对于正数来说，反码、补码、原码 相同。 对负数来说，存储的是补码。 负数： ①原码是直接按照正负写出来的二进制序列； ②反码是原码的符号位不变，其他的位按位取反得到的； ③补码是反码+1。  -2 原码：1000000000000000000000010 反码：1111111111111111111111101 补码：1111111111111111111111110  #include \u0026lt;stdio.h\u0026gt; int main() { int a = 0; int b = ~a; //~按二进制取反 //00000000000000000000000000000000 //11111111111111111111111111111111 //原码、反码、补码 //11111111111111111111111111111111 //11111111111111111111111111111110 //10000000000000000000000000000001 printf(\u0026quot;%d\\n\u0026quot;, b); //-1，适用的，打印的是这个数的原码 //有符号数，最高位的二进制位符号位 return 0; }  #include \u0026lt;stdio.h\u0026gt; int main() { int a = 10, b = 10; int c = a++; //后置++，先使用，在++ int d = ++b; //前置++，先++，在使用 printf(\u0026quot;%d\\n%d\\n%d\\n%d\\n\u0026quot;, a, c, b, d); //11 10 11 11 a = 10, b = 10; int e = a--; //后置--，先使用，在-- int f = --b; //前置--，先--，在使用 printf(\u0026quot;%d\\n%d\\n%d\\n%d\\n\u0026quot;, a, e, b, f); //9 10 9 9 return 0; }  int a = (int)3.14;//double--\u0026gt;int   关系操作符：  \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= != 用于测试“不相等” == 用于测试“相等   逻辑操作符：\u0026amp;\u0026amp; 逻辑与【零为假,非零为真】 ； || 逻辑或【同假为假】  #include \u0026lt;stdio.h\u0026gt; int main() { int a = 3; int b = 5; int c = a \u0026amp; b;//按位与 int d = a ^ b; printf(\u0026quot;%d\\n\u0026quot;, c); //1 printf(\u0026quot;%d\\n\u0026quot;, d); //6 [^不是次方，是异或] //异或的计算规律：对应二进制同，则为0；对应二进制异，则为1 //按位与：只有对应的两个二进位都为1时，结果位才为1 //3: 011 //5: 101 //6: 110 - 异或 //1: 001 - 按位与 return 0; }   条件操作符(三木操作符)：exp1?exp2:exp3 逗号表达式：exp1,exp2,exp3……expn 下标引用、函数调用和结构成员：[] () . -\u0026gt;  关键字 常见关键字 auto break case char case count continue default do double else enum extern float for goyo if int long register return short signed sizeof static struct switch typeof union unsigned void volatile while\nauto int a = 10; //局部变量，自动创建，自动销毁，自动变量，默认省略auto //int 定义的变量是有符号的 //signed int;有符号的 unsigned int num=0;//无符号的 register int b=0;//寄存器关键字 //struct 结构体关键字 //union 联合体，共用体  typedef:类型定义 unsigned int num = 20; typedef unsigned int u_int; //类型重定义 u_int num2 = 20; //num1和num2类型一致  static修饰变量和函数  修饰局部变量-静态局部变量（局部变量的生命周期变长）\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void text() { int a = 1; a++; printf(\u0026quot;a=%d\\n\u0026quot;, a); // 2 2 2 2 2 } void text2() { static int a = 1; //修饰局部变量,局部变量的生命周期变长 a++; printf(\u0026quot;a=%d -static\\n\u0026quot;, a); // 2 3 4 5 6 } int main() { int i = 0; while (i \u0026lt; 5) { text(); text2(); printf(\u0026quot;_____________\\n\u0026quot;); i++; } return 0; }   修饰全局变量-静态全局变量（改变了作用域，让静态的全局变量只能在自己的源文件内使用，出了源文件就无法再使用）\n运行正常\n//add.c int g_val = 2021; //全局变量 //test.c #include \u0026lt;stdio.h\u0026gt; int main() { //extern -声明外部符号 extern int g_val; printf(\u0026quot;g_val=%d\\n\u0026quot;, g_val); return 0; }  运行异常\n//add.c static int g_val = 2021; //test.c #include \u0026lt;stdio.h\u0026gt; int main() { //extern -生命外部符号 extern int g_val; printf(\u0026quot;g_val=%d\\n\u0026quot;, g_val); return 0; }  修饰函数-静态函数（修饰函数的外部链接属性，外部链接属性\u0026ndash;\u0026gt;内部链接属性） 一个函数被static修饰，使用这个函数只能在本源文件内使用，不能再其他源文件内使用。\n//add.c int Add(int x, int y) { int z = x + y; return z; } //test.c #include \u0026lt;stdio.h\u0026gt; int main() { extern Add(int, int); printf(\u0026quot;%d\u0026quot;, Add(1, 2)); return 0; }   #define定义常量和宏 定义标识符常量：#define MAX 1000 定义宏 #include \u0026lt;stdio.h\u0026gt; //define定义标识符常量 #define MAX 1000 //define定义宏 #define MAX(x, y) (x \u0026gt; y ? x : y) //函数 int Max(int x,int y){ if(x\u0026gt;y){ return x; }else{ return y; } } int main() { //函数的方式 int max = Max(2, 3); printf(\u0026quot;MAX = %d\\n\u0026quot;, max); //宏的方式 max = MAX(2, 3); printf(\u0026quot;MAX = %d\\n\u0026quot;, max); return 0; }  指针 内存 内存是电脑上特别重要的存储器，计算机中所有程序的运行都是在内存中进行的 。 所以为了有效的使用内存，就把内存划分成一个个小的内存单元，每个内存单元的大小是1个字节。 为了能够有效的访问到内存的每个单元，就给内存单元进行了编号，这些编号被称为该内存单元的地址。\n指针变量  变量地址取出 地址存储 使用实例\u0026ndash;推广使用 指针变量的大小  #include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; //4个字节 int *p = \u0026amp;a; //取地址 //有一种变量是用来存放地址的-指针变量 printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;a); //打印地址 printf(\u0026quot;%p\\n\u0026quot;, p); //打印地址 printf(\u0026quot;a=%d\\n\u0026quot;, a); *p = 20; //* -解引用操作符,间接访问操作符 printf(\u0026quot;a=%d\\n\u0026quot;, a); char ch = 'a'; char *pc = \u0026amp;ch;//类型是char * printf(\u0026quot;ch=%c\\n\u0026quot;, ch); *pc = 'w';//与上面的*意义不同 printf(\u0026quot;ch=%c\\n\u0026quot;, ch); //指针大小 printf(\u0026quot;%d\\n\u0026quot;, sizeof(char *)); //x64下为8个字节，win32为4个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(short *)); //x64下为8个字节，win32为4个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(int *)); //x64下为8个字节，win32为4个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(double *)); //x64下为8个字节，win32为4个字节 return 0; }  结构体 描述复杂类型 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; struct Stu { char name[20]; //名字 int age; //年龄 char sex[5]; //性别 char id[15]; //学号 }; int main() { //打印结构体信息 struct Stu s = {\u0026quot;张三\u0026quot;, 20, \u0026quot;男\u0026quot;, \u0026quot;20180101\u0026quot;}; //.为结构成员访问操作符 printf(\u0026quot;name = %s age = %d sex = %s id = %s\\n\u0026quot;, s.name, s.age, s.sex, s.id); s.age = 18; // s.name = \u0026quot;李四\u0026quot;;//err strcpy(s.name, \u0026quot;李四\u0026quot;); //string-copy strcpy 字符串拷贝 printf(\u0026quot;name = %s age = %d sex = %s id = %s\\n\u0026quot;, s.name, s.age, s.sex, s.id); //-\u0026gt;操作符 struct Stu *ps = \u0026amp;s; //. 结构体变量.成员 //-\u0026gt; 结构体指针-\u0026gt;成员 printf(\u0026quot;name = %s age = %d sex = %s id = %s\\n\u0026quot;, (*ps).name, (*ps).age, (*ps).sex, (*ps).id); printf(\u0026quot;name = %s age = %d sex = %s id = %s\\n\u0026quot;, ps-\u0026gt;name, ps-\u0026gt;age, ps-\u0026gt;sex, ps-\u0026gt;id); return 0; }  ","date":1610838000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1610838000,"objectID":"dff5fdd34ec81e719c45d91ae5a200dc","permalink":"https://cytgenkidu.github.io/tutorial/c/1/","publishdate":"2021-01-17T00:00:00+01:00","relpermalink":"/tutorial/c/1/","section":"tutorial","summary":"什么是C语言？ C语言是一门计算机语言\n计算机语言是什么？人和计算机交流的语言 C/C++/java/python\n语言的发展：低级语言→高级语言\n 010001000-机器语言【二进制语言 硬件-电-正电/负电】 汇编语言 B语言 C语言、C++\u0026mdash;高级语言  C语言→早期不是很成熟→成熟→流行 国际标准ANSIC-C89/C90 、 C99/C11并不流行\n#include \u0026lt;stdio.h\u0026gt; int main() //main函数是程序的入口,一个工程中main函数有且仅有一个 { printf(\u0026quot;hello\\n\u0026quot;); printf(\u0026quot;he he\\n\u0026quot;); return 0; }  数据类型  char - 字符数据类型 1 short - 短整型 2 int - 整形 4 long - 长整型 4 long long -更长的整形 8 float -单精度浮点数 4 double -双精度浮点数 8  char ch = 'As'; int a = 0; float b = 1.","tags":null,"title":"初识C语言","type":"docs"},{"authors":null,"categories":null,"content":" In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 2 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"4f7b142ef3db7d02843028599f4889f1","permalink":"https://cytgenkidu.github.io/tutorial/example/example1/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/tutorial/example/example1/","section":"tutorial","summary":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim.","tags":null,"title":"Example Page 1","type":"docs"},{"authors":null,"categories":null,"content":" 基本流程  创建一个用户交互菜单； 创建一个棋盘并初始化； 打印一个棋盘； 玩家落子（玩家通过输入行列坐标落子）； 判定胜负关系； 电脑落子（电脑采用随机落子的方式落子）； 判定胜负关系； 游戏结束。  test.c #define _CRT_SECURE_NO_WARNINGS 1 //测试三子棋游戏 #include \u0026quot;game.h\u0026quot; //打印菜单：1.开始游戏 0.退出游戏 void menu() { printf(\u0026quot;***************************\\n\u0026quot;); printf(\u0026quot;**** 1. play 0. exit*****\\n\u0026quot;); printf(\u0026quot;***************************\\n\u0026quot;); } // | | //---|---|--- // | | //---|---|--- // | | void test() { int input = 0; srand((unsigned int)time(NULL));//拿时间戳设置一个随机起点，设置一次就可以，不要频繁调用 do { menu(); printf(\u0026quot;请选择:\u0026gt;\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;input); switch (input) { case 1: game(); break; case 0: printf(\u0026quot;退出游戏\\n\u0026quot;); break; default: printf(\u0026quot;选择错误，请重新选择!\\n\u0026quot;); break; } } while (input); } int main() { test(); return 0; }  game.h #define ROW 3 #define COL 3 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; //声明 void game();//游戏的整个算法实现 void InitBoard(char board[ROW][COL], int row, int col);//初始化数组 void DisplayBoard(char board[ROW][COL], int row, int col);//打印棋盘和棋子 void PlayerMove(char board[ROW][COL], int row, int col);//玩家移动 void ComputerMove(char board[ROW][COL], int row, int col);//电脑移动 //告诉我们四种游戏的状态 //玩家赢 - '*' //电脑赢 - '#' //平局 - 'Q' //继续 - 'C' char IsWin(char board[ROW][COL], int row, int col);//检查游戏是否结束  game.c #define _CRT_SECURE_NO_WARNINGS 1 #include \u0026quot;game.h\u0026quot; //游戏的整个算法实现 void game() { char ret = 0; //数组-存放走出的棋盘信息 char board[ROW][COL] = { 0 };//全部空格 //初始化棋盘 InitBoard(board, ROW, COL); //打印棋盘 DisplayBoard(board, ROW, COL); //下棋 while (1) { //玩家下棋 PlayerMove(board, ROW, COL); DisplayBoard(board, ROW, COL); //判断玩家是否赢 ret = IsWin(board, ROW, COL); if (ret != 'C') { break; } //电脑下棋 ComputerMove(board, ROW, COL); DisplayBoard(board, ROW, COL); //判断电脑是否赢 ret = IsWin(board, ROW, COL); if (ret != 'C') { break; } } if (ret == '*') { printf(\u0026quot;玩家赢\\n\u0026quot;); } else if (ret == '#') { printf(\u0026quot;电脑赢\\n\u0026quot;); } else { printf(\u0026quot;平局\\n\u0026quot;); } } void InitBoard(char board[ROW][COL], int row, int col) { int i = 0; int j = 0; for (i = 0; i \u0026lt; row; i++) { for (j = 0; j \u0026lt; col; j++) { board[i][j] = ' '; } } } //void DisplayBoard(char board[ROW][COL], int row, int col) //{ // int i = 0; // for (i = 0; i \u0026lt; row; i++) // { // //1. 打印一行的数据 // printf(\u0026quot; %c | %c | %c \\n\u0026quot;, board[i][0], board[i][1], board[i][2]); // //2. 打印分割行 // if (i \u0026lt; row - 1) // printf(\u0026quot;---|---|---\\n\u0026quot;); // } //} // | | //---|---|--- // | | //---|---|--- // | | void DisplayBoard(char board[ROW][COL], int row, int col) { int i = 0; for (i = 0; i \u0026lt; row; i++) { int j = 0; for (j = 0; j \u0026lt; col; j++) { //1. 打印一行的数据。 | | printf(\u0026quot; %c \u0026quot;, board[i][j]); if (j \u0026lt; col - 1) printf(\u0026quot;|\u0026quot;); } printf(\u0026quot;\\n\u0026quot;); //2. 打印分割行。 ---|---|--- if (i \u0026lt; row - 1) { for (j = 0; j \u0026lt; col; j++) { printf(\u0026quot;---\u0026quot;); if (j \u0026lt; col - 1) printf(\u0026quot;|\u0026quot;); } printf(\u0026quot;\\n\u0026quot;); } } } void PlayerMove(char board[ROW][COL], int row, int col) { int x = 0; int y = 0; printf(\u0026quot;玩家走：\u0026gt;\\n\u0026quot;); while (1) { printf(\u0026quot;请输入要下的坐标:\u0026gt;\u0026quot;); scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x, \u0026amp;y); //判断x,y坐标的合法性 if (x \u0026gt;= 1 \u0026amp;\u0026amp; x \u0026lt;= row \u0026amp;\u0026amp; y \u0026gt;= 1 \u0026amp;\u0026amp; y \u0026lt;= col) { if (board[x - 1][y - 1] == ' ') { board[x - 1][y - 1] = '*'; break; } else { printf(\u0026quot;该坐标被占用\\n\u0026quot;); } } else { printf(\u0026quot;坐标非法，请重新输入!\\n\u0026quot;); } } } void ComputerMove(char board[ROW][COL], int row, int col) { int x = 0; int y = 0; printf(\u0026quot;电脑走:\u0026gt;\\n\u0026quot;); while (1) { x = rand() % row; y = rand() % col; if (board[x][y] == ' ') { board[x][y] = '#'; break; } } } //返回1表示棋盘满了 //返回0，表示棋盘没满 int IsFull(char board[ROW][COL], int row, int col) { int i = 0; int j = 0; for (i = 0; i \u0026lt; row; i++) { for (j = 0; j \u0026lt; col; j++) { if (board[i][j] == ' ') { return 0;//没满 } } } return 1;//满了 } char IsWin(char board[ROW][COL], int row, int col) { int i = 0; //横三行 for (i = 0; i \u0026lt; row; i++) { if (board[i][0] == board[i][1] \u0026amp;\u0026amp; board[i][1] == board[i][2] \u0026amp;\u0026amp; board[i][1] != ' ') { return board[i][1]; } } //竖三列 for (i = 0; i \u0026lt; col; i++) { if (board[0][i] == board[1][i] \u0026amp;\u0026amp; board[1][i] == board[2][i] \u0026amp;\u0026amp; board[1][i] != ' ') { return board[1][i]; } } //两个对角线 if (board[0][0] == board[1][1] \u0026amp;\u0026amp; board[1][1] == board[2][2] \u0026amp;\u0026amp; board[1][1] != ' ') return board[1][1]; if (board[2][0] == board[1][1] \u0026amp;\u0026amp; board[1][1] == board[0][2] \u0026amp;\u0026amp; board[1][1] != ' ') return board[1][1]; //判断是否平局 if (1 == IsFull(board, ROW, COL)) { return 'Q'; } //继续 return 'C'; }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"14a728a7d6056ea44e03443636e1102e","permalink":"https://cytgenkidu.github.io/tutorial/c/%E4%B8%89%E5%AD%90%E6%A3%8B/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tutorial/c/%E4%B8%89%E5%AD%90%E6%A3%8B/","section":"tutorial","summary":"基本流程  创建一个用户交互菜单； 创建一个棋盘并初始化； 打印一个棋盘； 玩家落子（玩家通过输入行列坐标落子）； 判定胜负关系； 电脑落子（电脑采用随机落子的方式落子）； 判定胜负关系； 游戏结束。  test.c #define _CRT_SECURE_NO_WARNINGS 1 //测试三子棋游戏 #include \u0026quot;game.h\u0026quot; //打印菜单：1.开始游戏 0.退出游戏 void menu() { printf(\u0026quot;***************************\\n\u0026quot;); printf(\u0026quot;**** 1. play 0. exit*****\\n\u0026quot;); printf(\u0026quot;***************************\\n\u0026quot;); } // | | //---|---|--- // | | //---|---|--- // | | void test() { int input = 0; srand((unsigned int)time(NULL));//拿时间戳设置一个随机起点，设置一次就可以，不要频繁调用 do { menu(); printf(\u0026quot;请选择:\u0026gt;\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;input); switch (input) { case 1: game(); break; case 0: printf(\u0026quot;退出游戏\\n\u0026quot;); break; default: printf(\u0026quot;选择错误，请重新选择!","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" 基本流程 test.c #define _CRT_SECURE_NO_WARNINGS 1 #include \u0026quot;game.h\u0026quot; void menu() { printf(\u0026quot;*****************************\\n\u0026quot;); printf(\u0026quot;******* 1. play ******\\n\u0026quot;); printf(\u0026quot;******* 0. exit ******\\n\u0026quot;); printf(\u0026quot;*****************************\\n\u0026quot;); } void test() { int input = 0; srand((unsigned int)time(NULL)); do { menu(); printf(\u0026quot;请选择:\u0026gt;\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;input); switch (input) { case 1: game(); break; case 0: printf(\u0026quot;退出游戏\\n\u0026quot;); break; default: printf(\u0026quot;选择错误,重新选择!\\n\u0026quot;); break; } } while (input); } int main() { test(); return 0; }  game.h #define ROW 9 #define COL 9 #define ROWS ROW+2 #define COLS COL+2 #define EASY_COUNT 10 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; void game(); void InitBoard(char board[ROWS][COLS], int rows, int cols, char set); void DisplayBoard(char board[ROWS][COLS], int row, int col); void SetMine(char board[ROWS][COLS], int row, int col); void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);  game.c #define _CRT_SECURE_NO_WARNINGS 1 #include \u0026quot;game.h\u0026quot; void game() { //雷的信息存储 //1. 布置好的雷的信息 char mine[ROWS][COLS] = { 0 };// 11 * 11 //记录地雷的数组 //2. 排查出的雷的信息 char show[ROWS][COLS] = { 0 }; //展示给玩家的数组 //初始化 InitBoard(mine, ROWS, COLS, '0');//初始化 InitBoard(show, ROWS, COLS, '*'); //打印棋盘 //DisplayBoard(mine, ROW, COL); DisplayBoard(show, ROW, COL); //布置雷 SetMine(mine, ROW, COL); //DisplayBoard(mine, ROW, COL); //扫雷 FindMine(mine, show, ROW, COL); } void InitBoard(char board[ROWS][COLS], int rows, int cols, char set) { int i = 0; int j = 0; for (i = 0; i \u0026lt; rows; i++) { for (j = 0; j \u0026lt; cols; j++) { board[i][j] = set; } } } void DisplayBoard(char board[ROWS][COLS], int row, int col) { int i = 0; int j = 0; //打印列号 for (i = 0; i \u0026lt;= col; i++) { printf(\u0026quot;%d \u0026quot;, i); } printf(\u0026quot;\\n\u0026quot;); for (i = 1; i \u0026lt;= row; i++) { printf(\u0026quot;%d \u0026quot;, i); for (j = 1; j \u0026lt;= col; j++) { printf(\u0026quot;%c \u0026quot;, board[i][j]); } printf(\u0026quot;\\n\u0026quot;); } } void SetMine(char board[ROWS][COLS], int row, int col) { int count = EASY_COUNT; while (count) { int x = rand() % row + 1;//1-9 int y = rand() % col + 1;// if (board[x][y] == '0') { board[x][y] = '1'; count--; } } } //'0' - '0'=0 //'1'-'0' = 1 //'3'-'0' = 3 int get_mine_count(char mine[ROWS][COLS], int x, int y) { return mine[x - 1][y] + mine[x - 1][y - 1] + mine[x][y - 1] + mine[x + 1][y - 1] + mine[x + 1][y] + mine[x + 1][y + 1] + mine[x][y + 1] + mine[x - 1][y + 1] - 8 * '0'; } void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col) { int x = 0; int y = 0; int win = 0; //9*9-10 = 71 while (win \u0026lt; row*col - EASY_COUNT) { printf(\u0026quot;请输入排查雷的坐标:\u0026gt;\u0026quot;); scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x, \u0026amp;y); if (x \u0026gt;= 1 \u0026amp;\u0026amp; x \u0026lt;= row \u0026amp;\u0026amp; y \u0026gt;= 1 \u0026amp;\u0026amp; y \u0026lt;= col) { //坐标合法 //1. 踩雷 if (mine[x][y] == '1') { printf(\u0026quot;很遗憾，你被炸死了\\n\u0026quot;); DisplayBoard(mine, row, col); break; } else //不是雷 { //计算x,y坐标周围有几个雷 int count = get_mine_count(mine, x, y); show[x][y] = count + '0'; DisplayBoard(show, row, col); win++; } } else { printf(\u0026quot;输入坐标非法，请重新输入!\\n\u0026quot;); } } if (win == row * col - EASY_COUNT) { printf(\u0026quot;恭喜你，排雷成功\\n\u0026quot;); DisplayBoard(mine, row, col); } } //展开功能的时候-递归  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d95f0b92b3e4e8a5239bd5c914338d32","permalink":"https://cytgenkidu.github.io/tutorial/c/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tutorial/c/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/","section":"tutorial","summary":"基本流程 test.c #define _CRT_SECURE_NO_WARNINGS 1 #include \u0026quot;game.h\u0026quot; void menu() { printf(\u0026quot;*****************************\\n\u0026quot;); printf(\u0026quot;******* 1. play ******\\n\u0026quot;); printf(\u0026quot;******* 0. exit ******\\n\u0026quot;); printf(\u0026quot;*****************************\\n\u0026quot;); } void test() { int input = 0; srand((unsigned int)time(NULL)); do { menu(); printf(\u0026quot;请选择:\u0026gt;\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;input); switch (input) { case 1: game(); break; case 0: printf(\u0026quot;退出游戏\\n\u0026quot;); break; default: printf(\u0026quot;选择错误,重新选择!\\n\u0026quot;); break; } } while (input); } int main() { test(); return 0; }  game.h #define ROW 9 #define COL 9 #define ROWS ROW+2 #define COLS COL+2 #define EASY_COUNT 10 #include \u0026lt;stdio.","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" 简介 相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。\n思想 C语言实现 void hanoi(int n, char a, char b, char c)\nn - 为移动圆盘个数\na b c - 分别为三根针\n实现功能 - a上的n个圆盘移动到c上\n当只移动一个圆盘时，直接将圆盘从 A 针移动到 C 针。 若移动的圆盘为 n(n\u0026gt;1)，则分成几步走： 把 (n-1) 个圆盘从 A 针移动到 B 针（借助 C 针）； A 针上的最后一个圆盘移动到 C 针； B 针上的 (n-1) 个圆盘移动到 C 针（借助 A 针）。 每做一遍，移动的圆盘少一个，逐次递减，最后当 n 为 1 时，完成整个移动过程。\n#include \u0026lt;stdio.h\u0026gt; void hanoi(int n, char a, char b, char c) { if (n \u0026gt;= 1) { hanoi(n - 1, a, c, b);//把n - 1个盘子从a移到c借助b printf(\u0026quot;%c-- \u0026gt; %c\\n\u0026quot;, a, c); hanoi(n - 1, b, a, c);//把n - 1个盘子从b柱移到a柱借助c } } void main() { int n; printf(\u0026quot;请输入移动圆盘个数:\\n \u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); hanoi(n, 'A', 'B', 'C'); }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"528e86fd3ef4b1373a870e02c48274b2","permalink":"https://cytgenkidu.github.io/tutorial/c/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tutorial/c/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/","section":"tutorial","summary":" 简介 相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。\n思想 C语言实现 void hanoi(int n, char a, char b, char c)\nn - 为移动圆盘个数\na b c - 分别为三根针\n实现功能 - a上的n个圆盘移动到c上\n当只移动一个圆盘时，直接将圆盘从 A 针移动到 C 针。 若移动的圆盘为 n(n\u0026gt;1)，则分成几步走： 把 (n-1) 个圆盘从 A 针移动到 B 针（借助 C 针）； A 针上的最后一个圆盘移动到 C 针； B 针上的 (n-1) 个圆盘移动到 C 针（借助 A 针）。 每做一遍，移动的圆盘少一个，逐次递减，最后当 n 为 1 时，完成整个移动过程。\n#include \u0026lt;stdio.h\u0026gt; void hanoi(int n, char a, char b, char c) { if (n \u0026gt;= 1) { hanoi(n - 1, a, c, b);//把n - 1个盘子从a移到c借助b printf(\u0026quot;%c-- \u0026gt; %c\\n\u0026quot;, a, c); hanoi(n - 1, b, a, c);//把n - 1个盘子从b柱移到a柱借助c } } void main() { int n; printf(\u0026quot;请输入移动圆盘个数:\\n \u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); hanoi(n, 'A', 'B', 'C'); }  ","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" 通讯录Contact  存放1000个好友的信息 ： 名字 电话 性别 住址 年龄 增加好友信息 删除指定名字的好友信息 查找好友信息 修改好友信息 打印好友信息 排序  简单流程 详细代码 test.c 测试 #define _CRT_SECURE_NO_WARNINGS 1 #include \u0026quot;contact.h\u0026quot; void menu() { printf(\u0026quot;*****************************************\\n\u0026quot;); printf(\u0026quot;****** 1. add 2. del *******\\n\u0026quot;); printf(\u0026quot;****** 3. search 4. modify *******\\n\u0026quot;); printf(\u0026quot;****** 5. show 6. sort *******\\n\u0026quot;); printf(\u0026quot;****** 0. exit *******\\n\u0026quot;); printf(\u0026quot;*****************************************\\n\u0026quot;); } int main() { int input = 0; //创建通讯录 struct Contact con;//con就是通讯录，里边包含：data指针和size，capacity //初始化通讯录 InitContact(\u0026amp;con); // do { menu(); printf(\u0026quot;请选择:\u0026gt;\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;input); switch (input) { case ADD: AddContact(\u0026amp;con); break; case DEL: DelContact(\u0026amp;con); break; case SEARCH: SearchContact(\u0026amp;con); break; case MODIFY: ModifyContact(\u0026amp;con); break; case SHOW: ShowContact(\u0026amp;con);//即使是展示也要取地址，这种效率高 break; case SORT: SortContact(\u0026amp;con); break; case EXIT: //销毁通讯录-释放动态开辟的内存 DestroyContact(\u0026amp;con); printf(\u0026quot;退出通讯录\\n\u0026quot;); break; default: printf(\u0026quot;选择错误\\n\u0026quot;); break; } } while (input); return 0; }  contact.c 实现函数的功能 #define _CRT_SECURE_NO_WARNINGS 1 #include \u0026quot;contact.h\u0026quot; void InitContact(struct Contact* ps) { ps-\u0026gt;data = (struct PeoInfo*)malloc(DEFAULT_SZ * sizeof(struct PeoInfo)); if (ps-\u0026gt;data == NULL) { return; } ps-\u0026gt;size = 0; ps-\u0026gt;capacity = DEFAULT_SZ; } void CheckCapacity(struct Contact* ps) { if (ps-\u0026gt;size == ps-\u0026gt;capacity) { //增容 struct PeoInfo* ptr = realloc(ps-\u0026gt;data, (ps-\u0026gt;capacity + 2) * sizeof(PeoInfo)); if (ptr != NULL) { ps-\u0026gt;data = ptr; ps-\u0026gt;capacity += 2; printf(\u0026quot;增容成功\\n\u0026quot;); } else { printf(\u0026quot;增容失败\\n\u0026quot;); } } } void AddContact(struct Contact* ps) { //检测当前通讯录的容量 //1. 如果满了，就增加空间 //2. 如果不满，啥事都不干 CheckCapacity(ps); //增加数据 printf(\u0026quot;请输入名字:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, ps-\u0026gt;data[ps-\u0026gt;size].name);//数组 printf(\u0026quot;请输入年龄:\u0026gt;\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;(ps-\u0026gt;data[ps-\u0026gt;size].age));//int 要加\u0026amp; printf(\u0026quot;请输入性别:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, ps-\u0026gt;data[ps-\u0026gt;size].sex); printf(\u0026quot;请输入电话:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, ps-\u0026gt;data[ps-\u0026gt;size].tele); printf(\u0026quot;请输入地址:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, ps-\u0026gt;data[ps-\u0026gt;size].addr); ps-\u0026gt;size++; printf(\u0026quot;添加成功\\n\u0026quot;); } void ShowContact(const struct Contact* ps) { if (ps-\u0026gt;size == 0) { printf(\u0026quot;通讯录为空格\\n\u0026quot;); } else { int i = 0; //标题 printf(\u0026quot;%-20s\\t%-4s\\t%-5s\\t%-12s\\t%-20s\\n\u0026quot;, \u0026quot;名字\u0026quot;, \u0026quot;年龄\u0026quot;, \u0026quot;性别\u0026quot;, \u0026quot;电话\u0026quot;, \u0026quot;地址\u0026quot;); //数据 for (i = 0; i \u0026lt; ps-\u0026gt;size; i++) { printf(\u0026quot;%-20s\\t%-4d\\t%-5s\\t%-12s\\t%-20s\\n\u0026quot;, ps-\u0026gt;data[i].name, ps-\u0026gt;data[i].age, ps-\u0026gt;data[i].sex, ps-\u0026gt;data[i].tele, ps-\u0026gt;data[i].addr); } } } //没有声明，并加上static 这个函数只能在该源文件内调用，不会暴露在外面 static int FindByName(const struct Contact* ps, char name[MAX_NAME]) { int i = 0; for (i = 0; i \u0026lt; ps-\u0026gt;size; i++) { if (0 == strcmp(ps-\u0026gt;data[i].name, name)) { return i; } } return -1;//找不到的情况 } void DelContact(struct Contact* ps) { char name[MAX_NAME]; int pos = 0; printf(\u0026quot;请输入要删除人的名字:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, name); //1. 查找要删除的人在什么位置 //找到了返回名字所在元素的下标 //找不到返回 -1 pos = FindByName(ps, name); //2. 删除 if (pos == -1) { printf(\u0026quot;要删除的人不存在\\n\u0026quot;); } else { //删除数据 int j = 0; for (j = pos; j \u0026lt; ps-\u0026gt;size - 1; j++) { ps-\u0026gt;data[j] = ps-\u0026gt;data[j + 1]; } ps-\u0026gt;size--; printf(\u0026quot;删除成功\\n\u0026quot;); } } void SearchContact(const struct Contact* ps) { int pos = 0; char name[MAX_NAME]; printf(\u0026quot;请输入要查找人的名字:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, name); pos = FindByName(ps, name); if (pos == -1) { printf(\u0026quot;要查找的人不存在\\n\u0026quot;); } else { printf(\u0026quot;%-20s\\t%-4s\\t%-5s\\t%-12s\\t%-20s\\n\u0026quot;, \u0026quot;名字\u0026quot;, \u0026quot;年龄\u0026quot;, \u0026quot;性别\u0026quot;, \u0026quot;电话\u0026quot;, \u0026quot;地址\u0026quot;); printf(\u0026quot;%-20s\\t%-4d\\t%-5s\\t%-12s\\t%-20s\\n\u0026quot;, ps-\u0026gt;data[pos].name, ps-\u0026gt;data[pos].age, ps-\u0026gt;data[pos].sex, ps-\u0026gt;data[pos].tele, ps-\u0026gt;data[pos].addr); } } void ModifyContact(struct Contact* ps) { int pos = 0; char name[MAX_NAME]; printf(\u0026quot;请输入要修改人的名字:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, name); pos = FindByName(ps, name); if (pos == -1) { printf(\u0026quot;要修改人的信息不错在\\n\u0026quot;); } else { printf(\u0026quot;请输入名字:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, ps-\u0026gt;data[pos].name); printf(\u0026quot;请输入年龄:\u0026gt;\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;(ps-\u0026gt;data[pos].age)); printf(\u0026quot;请输入性别:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, ps-\u0026gt;data[pos].sex); printf(\u0026quot;请输入电话:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, ps-\u0026gt;data[pos].tele); printf(\u0026quot;请输入地址:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, ps-\u0026gt;data[pos].addr); printf(\u0026quot;修改完成\\n\u0026quot;); } } //冒泡排序 void SortContact(struct Contact*ps) { for (int i = 0; i \u0026lt; ps-\u0026gt;size; i++)//冒泡排序的趟数 { int flag = 1; //假设这一趟要排序的数据已经有序 //每一趟冒泡排序 for (int j = 0; j \u0026lt; ps-\u0026gt;size - i - 1; j++) { if (strcmp(ps-\u0026gt;data[j].name, ps-\u0026gt;data[j + 1].name) \u0026gt; 0) { PeoInfo temp; temp = ps-\u0026gt;data[j]; ps-\u0026gt;data[j] = ps-\u0026gt;data[j + 1]; ps-\u0026gt;data[j + 1] = temp; flag = 0; //本趟排序的数据其实不完全有序 } } if (flag == 1) { break;// if不能break,这个break是跳出外层循环 } } } void DestroyContact(Contact* ps) { free(ps-\u0026gt;data); ps-\u0026gt;data = NULL; }  contact.h 声明函数 #define _CRT_SECURE_NO_WARNINGS 1 //#define MAX 1000 #define DEFAULT_SZ 3 #define MAX_NAME 20 #define MAX_SEX 5 #define MAX_TELE 12 #define MAX_ADDR 30 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; enum Option { EXIT,//0 ADD, //1 DEL, //2 SEARCH, //3 MODIFY, //4 SHOW, //5 SORT //6 }; typedef struct PeoInfo { char name[MAX_NAME]; int age; char sex[MAX_SEX]; char tele[MAX_TELE]; char addr[MAX_ADDR]; }PeoInfo; //通讯录类型 typedef struct Contact { struct PeoInfo *data;//存放1000个信息 int size;//记录当前已经有的元素个数 int capacity;//当前通讯录的最大容量 }Contact; //声明函数 //初始化通讯录的函数 void InitContact(struct Contact* ps); //增加一个信息到通讯录 void AddContact(struct Contact* ps); //打印通讯录中的信息 void ShowContact(const struct Contact* ps); //删除指定的联系人 void DelContact(struct Contact* ps); //查找指定的人的信息 void SearchContact(const struct Contact* ps); //修改指定联系人 void ModifyContact(struct Contact* ps); //排序通讯录内容 void SortContact(struct Contact*ps); void DestroyContact(Contact* ps);  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0a8f85407c258c2638e4456c5a68dccb","permalink":"https://cytgenkidu.github.io/tutorial/c/contact/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tutorial/c/contact/","section":"tutorial","summary":"通讯录Contact  存放1000个好友的信息 ： 名字 电话 性别 住址 年龄 增加好友信息 删除指定名字的好友信息 查找好友信息 修改好友信息 打印好友信息 排序  简单流程 详细代码 test.c 测试 #define _CRT_SECURE_NO_WARNINGS 1 #include \u0026quot;contact.h\u0026quot; void menu() { printf(\u0026quot;*****************************************\\n\u0026quot;); printf(\u0026quot;****** 1. add 2. del *******\\n\u0026quot;); printf(\u0026quot;****** 3. search 4. modify *******\\n\u0026quot;); printf(\u0026quot;****** 5. show 6. sort *******\\n\u0026quot;); printf(\u0026quot;****** 0. exit *******\\n\u0026quot;); printf(\u0026quot;*****************************************\\n\u0026quot;); } int main() { int input = 0; //创建通讯录 struct Contact con;//con就是通讯录，里边包含：data指针和size，capacity //初始化通讯录 InitContact(\u0026amp;con); // do { menu(); printf(\u0026quot;请选择:\u0026gt;\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;input); switch (input) { case ADD: AddContact(\u0026amp;con); break; case DEL: DelContact(\u0026amp;con); break; case SEARCH: SearchContact(\u0026amp;con); break; case MODIFY: ModifyContact(\u0026amp;con); break; case SHOW: ShowContact(\u0026amp;con);//即使是展示也要取地址，这种效率高 break; case SORT: SortContact(\u0026amp;con); break; case EXIT: //销毁通讯录-释放动态开辟的内存 DestroyContact(\u0026amp;con); printf(\u0026quot;退出通讯录\\n\u0026quot;); break; default: printf(\u0026quot;选择错误\\n\u0026quot;); break; } } while (input); return 0; }  contact.","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" 问题描述 一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。\n分析 n - 台阶数\nsum - 跳发\n   n sum     1 1   2 2   3 3   4 5   5 8   6 13   7 21   8 34   9 55   10 89   …… ……   n-2 f(n-2)   n-1 f(n-1)   n f(n-1)+f(n-2)    可参考斐波那数\n递归实现 //1 2 3 5 8 13 21 34 55 89 …… //递归实现 int D_Frog_jump(int n) { if (n \u0026lt;3) return n; else return D_Frog_jump(n - 1) + D_Frog_jump(n - 2); } int main() { int n = 0; int ret = 0; printf(\u0026quot;请输入青蛙要跳的台阶数：\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); ret = D_Frog_jump(n); //ret = FD_Frog_jump(n); printf(\u0026quot;%d\\n\u0026quot;, ret); return 0; }  非递归实现 //非递归实现 int FD_Frog_jump(int n) { int res = 2; int pre_res = 1; int next_older_res = 0; while (n \u0026gt; 2) { next_older_res = pre_res; pre_res = res; res = pre_res + next_older_res; n--; } return res; }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2a7d16fff4182d1cc466bd74fbad37e2","permalink":"https://cytgenkidu.github.io/tutorial/c/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tutorial/c/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/","section":"tutorial","summary":"问题描述 一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。\n分析 n - 台阶数\nsum - 跳发\n   n sum     1 1   2 2   3 3   4 5   5 8   6 13   7 21   8 34   9 55   10 89   …… ……   n-2 f(n-2)   n-1 f(n-1)   n f(n-1)+f(n-2)    可参考斐波那数","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" C语言是一门结构化的程序设计语言  顺序结构 选择结构 循环结构  什么是语句 C语言中由一个分号 ; 隔开的就是一条语句。\nprintf(\u0026quot;hello\u0026quot;); ;//是语句，空语句  分支语句（选择结构） if if语句语法 if(表达式) 语句; if(表达式) 语句1; else 语句2; //多分支 if(表达式1) 语句1; else if(表达式2) 语句2; else 语句3;  if语句示例 int age = 45; if (age \u0026lt; 18) printf(\u0026quot;未成年\\n\u0026quot;); else if (age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt; 28) // 18\u0026lt;=age\u0026lt;28 有问题 printf(\u0026quot;青年\\n\u0026quot;); else if (age \u0026gt;= 28 \u0026amp;\u0026amp; age \u0026lt; 50) printf(\u0026quot;壮年\\n\u0026quot;); else if (age \u0026gt;= 50 \u0026amp;\u0026amp; age \u0026lt; 90) printf(\u0026quot;老年\u0026quot;); else printf(\u0026quot;长寿\u0026quot;);   如果表达式的结果为真，则语句执行。\n 在C语言中如何表示真假？\n 0表示假，非0表示真。   如果条件成立，要执行多条语句，怎应该使用代码块\n#include \u0026lt;stdio.h\u0026gt; int main() { if(表达式) { 语句列表1； } else { 语句列表2； } return 0; }  悬空else #include \u0026lt;stdio.h\u0026gt; //有问题 int main()//什么也不打印 { int a = 0; int b = 2; if (a == 1) if (b == 2) printf(\u0026quot;hehe\\n\u0026quot;); else printf(\u0026quot;haha\\n\u0026quot;); return 0; } //改正 //适当的使用{}可以使代码的逻辑更加清楚。 //代码风格很重要 int main() { int a = 0; int b = 2; if (a == 1) { if (b == 2) { printf(\u0026quot;hehe\\n\u0026quot;); } } else { printf(\u0026quot;haha\\n\u0026quot;); } return 0; }  if书写形式的对比 //代码1 if (condition) { return x; } return y; //代码2，和代码1 一致，但代码1 易产生误解，应避免 if (condition) { return x; }else{ return y; }  //代码3 int num = 1; if (num = 5) { // 一个=是赋值,不是判断相等 printf(\u0026quot;呵呵\\n\u0026quot;); //打印呵呵 } //代码4 int num =1 if (5 == num) { // 一个=是会报错 printf(\u0026quot;呵呵\\n\u0026quot;); //打印呵呵 } return 0;  代码2和代码4更好，逻辑更加清晰，不容易出错。\n注：\nbreak 语句只能用于for 和switch,在if语句中不能使用，因为if不是循环语句，所以不能用break来结束。\nif练习  判断一个数是否为奇数  int num; printf(\u0026quot;输入一个数:\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;num); if (0 == num % 2) // 判断这个数除以 2 的余数 printf(\u0026quot;%d 是偶数。\u0026quot;, num); else printf(\u0026quot;%d 是奇数。\u0026quot;, num);   输出1-100之间的奇数  int i = 1; while (i \u0026lt;= 100) { if (num \u0026amp; 1) // 判断这个数最后一位是1这为奇数 printf(\u0026quot;%d \u0026quot;, num); i++; }  switch switch语句也是一种分支语句。 常常用于多分支的情况。\nswitch语法 switch(整型表达式) { case 整型表达式:// 不能为变量 语句; }  switch示例 int day; printf(\u0026quot;输入：\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;day); switch (day)// ()内必须为整形 { case 1: printf(\u0026quot;Monday\u0026quot;); break; case 2: printf(\u0026quot;Tuesday\u0026quot;); break; case 3: printf(\u0026quot;Wednesday\u0026quot;); break; case 4: printf(\u0026quot;Thursday\u0026quot;); break; case 5: printf(\u0026quot;Friday\u0026quot;); break; case 6: printf(\u0026quot;Saturday\u0026quot;); break; case 7: printf(\u0026quot;Sunday\u0026quot;); break; default: printf(\u0026quot;输入有误，1-7\u0026quot;); break; } switch (day)// ()内必须为整形 { case 1: case 2: case 3: case 4: case 5: printf(\u0026quot;weekday\u0026quot;); break; case 6: case 7: printf(\u0026quot;weekend\u0026quot;); break; default: printf(\u0026quot;输入有误，1-7\u0026quot;); break; }  break语句的实际效果是把语句列表划分为不同的部分。\ndefault： 写在任何一个case标签可以出现的位置。 当 switch表达式的值并不匹配所有case标签的值时，这个default子句后面的语句就会执行。 所以，每个switch语句中只能出现一条default子句。 但是它可以出现在语句列表的任何位置，而且语句流会像贯穿一个case标签一样贯穿default子句。\nswitch练习 int n = 1; int m = 2; switch (n) { case 1: //没有break，符合case 1 完成case 1 继续执行case 2…… m++; //m=3,n=1 case 2: n++; //m=3,n=2 case 3: switch (n) { //switch允许嵌套使用 case 1: //未执行 n++; case 2: //符合，执行，break，继续执行case 4 m++; n++; //m=4,n=3 break; } case 4: m++; //m=5,n=3 break; //跳出 switch default: //未执行 break; } printf(\u0026quot;m = %d, n = %d\\n\u0026quot;, m, n); //m = 5, n = 3  循环语句 while while语法 //while 语法结构 while(表达式) 循环语句；  while语句执行的流程 while示例 int i = 1; while (i \u0026lt;= 10) { printf(\u0026quot;%d\\n\u0026quot;, i); i++; }  int i = 1; while (i \u0026lt;= 10) { if (5 == i) break; printf(\u0026quot;%d \u0026quot;, i); i++; }  break在while循环中的作用： 其实在循环中只要遇到break，就停止后期的所有的循环，直接终止循环。 所以：while中的 break是用于永久终止循环的。\nint i = 1; while (i \u0026lt;= 10) { if (5 == i) continue; printf(\u0026quot;%d \u0026quot;, i); i++; //陷入死循环，应把i++放在if前 }  continue在while循环中的作用就是： continue是用于终止本次循环的，也就是本次循环中continue后边的代码不会再执行，而是直接跳转到while语句的判断部分。进行下一次循环的入口判断.\nwhile练习 注：\nint ch = getchar(); //getchar 接收键盘一个字符 putchar(ch); //putchar 输出 printf(\u0026quot;%c\u0026quot;, ch);  代码1 //代码1 #include \u0026lt;stdio.h\u0026gt; int main() { int ch = 0; //ctrl+z获取一个EOF -end of file-\u0026gt;-1 while ((ch = getchar()) != EOF) //直接输入EOF不会停止，读入一个字符在写一个字符，EOF是三个字符 putchar(ch); return 0; }  注： #include \u0026lt;stdio.h\u0026gt; int main() { int ret = 0; char password[20] = {0}; printf(\u0026quot;请输入密码：\u0026quot;); //输入缓冲区：123456\\n scanf(\u0026quot;%s\u0026quot;, password); //输入密码，存放在password数组中 //缓冲区还剩余一个\\n,\\n--\u0026gt;10 // printf(\u0026quot;%d\u0026quot;, '\\n'); //10 getchar(); //读取\\n printf(\u0026quot;请确认（Y/N）?\u0026quot;); ret = getchar(); //Y /N if (ret == 'Y') { printf(\u0026quot;确认成功\\n\u0026quot;); } else { printf(\u0026quot;放弃确认\\n\u0026quot;); } return 0; }  若不加中间的getchar();则 加了 但还存在问题 修改代码为：\n#include \u0026lt;stdio.h\u0026gt; int main() { int ret = 0; int ch = 0; char password[20] = {0}; printf(\u0026quot;请输入密码：\u0026quot;); //输入缓冲区：123456\\n scanf(\u0026quot;%s\u0026quot;, password); //输入密码，存放在password数组中 //缓冲区还剩余一个\\n,\\n--\u0026gt;10 // printf(\u0026quot;%d\u0026quot;, '\\n'); //10 // getchar(); //读取\\n while ((ch = getchar()) != '\\n') { ; //空语句 } printf(\u0026quot;请确认（Y/N）?\u0026quot;); ret = getchar(); //Y /N if (ret == 'Y') { printf(\u0026quot;确认成功\\n\u0026quot;); } else { printf(\u0026quot;放弃确认\\n\u0026quot;); } printf(\u0026quot;密码为：%s\\n\u0026quot;, password); return 0; }  代码2 //代码2 #include \u0026lt;stdio.h\u0026gt; int main() { int ch = 0; //ctrl+z获取一个EOF -end of file-\u0026gt;-1 while ((ch = getchar()) != EOF) { if (ch \u0026lt; '0' || ch \u0026gt; '9') //只打印字符0-9,否则跳走 continue; putchar(ch); printf(\u0026quot;\\n\u0026quot;); } return 0; }  for 语法 for(表达式1；表达式2；表达式3) 循环语句；  for执行流程 for示例 int i = 0; for (i = 1; i \u0026lt; 10; i++) { if (i == 5) break; printf(\u0026quot;%d \u0026quot;, i); } printf(\u0026quot;\\n\u0026quot;); i = 1; while (i \u0026lt;= 10) { if (5 == i) break; printf(\u0026quot;%d \u0026quot;, i); i++; } printf(\u0026quot;\\n\u0026quot;); i = 0; for (i = 1; i \u0026lt; 10; i++) { if (i == 5) continue; printf(\u0026quot;%d \u0026quot;, i); } i = 1; printf(\u0026quot;\\n\u0026quot;); while (i \u0026lt;= 10) { if (5 == i) continue; printf(\u0026quot;%d \u0026quot;, i); i++; }  break和continue在for循环中 我们发现在for循环中也可以出现break和continue，他们的意义和在while循环中是一样的。 但是还是有些差异：\nfor语句的循环控制变量 一些建议：\n 不可在for 循环体内修改循环变量，防止 for 循环失去控制。[如i=5] 建议for语句的循环控制变量的取值采用“前闭后开区间”写法。  int i = 0; //前闭后开的写法,十次循环 for(i=0; i\u0026lt;10; i++) {} //两边都是闭区间 for(i=0; i\u0026lt;=9; i++) {}  一些for循环的变种  变种1\nint main() { for (;;) //死循环 { printf(\u0026quot;hehe\\n\u0026quot;); } int i = 0; int j = 0; for (i = 0; i \u0026lt; 10; i++) { for (j = 0; j \u0026lt; 10; j++) { printf(\u0026quot;hehe\\n\u0026quot;); } } //10*10=100个hehe int i = 0; int j = 0; for (; i \u0026lt; 10; i++) { for (; j \u0026lt; 10; j++) { printf(\u0026quot;hehe\\n\u0026quot;); } } //10个hehe //i=0 时，j=0,1,2,3,5,6,7,9 打印10次hehe,最后j=10 //i=1时，j还是等于10,第二个for为假，不会打印hehe //i++…… return 0; }    for循环的初始化、调整、判断 都可以省略. 但是：for循环的 判断部分 如果被省略，即判断条件就是：恒为正. 如果不是非常熟练，不要轻易省略   变种2\n#include \u0026lt;stdio.h\u0026gt; int main() { //变种2 int x, y; for (x = 0, y = 0; x \u0026lt; 2 \u0026amp;\u0026amp; y \u0026lt; 5; ++x, y++) { printf(\u0026quot;hehe\\n\u0026quot;); }//打印两个hehe return 0; }   for练习 //请问循环要循环多少次？ #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; int k = 0; for (i = 0, k = 0; k = 0; i++, k++) //k=0，把0赋值为k，这个表达式的结果为k的值，即为0，为假，所以循环0次 k++; for (i = 0, k = 0; k = 1; i++, k++) //k=1，2……不等于0，为真，死循环 k++; return 0; }  do while do while语句语法 do 循环语句； while(表达式)；  do while执行流程 do while示例 //循环至少执行一次，使用的场景有限，所以不是经常使用 int i = 10; do { printf(\u0026quot;%d\u0026quot;, i); } while (i \u0026lt; 10); //打印一个10 printf(\u0026quot;\\n\u0026quot;); i = 1; do { printf(\u0026quot;%d \u0026quot;, i); i++; } while (i \u0026lt;= 10); //打印1 2 3 4 5 6 7 8 9 10 printf(\u0026quot;\\n\u0026quot;); i = 1; do { if (i == 5) break; printf(\u0026quot;%d \u0026quot;, i); i++; } while (i \u0026lt;= 10); //打印1 2 3 4 printf(\u0026quot;\\n\u0026quot;); i = 1; do { if (i == 5) continue; printf(\u0026quot;%d \u0026quot;, i); i++; } while (i \u0026lt;= 10); //打印1 2 3 4 死循环  练习 \u0026ndash; 计算 n的阶乘。\n\u0026ndash; 计算 1!+2!+3!+……+10!\n#include \u0026lt;stdio.h\u0026gt; int main() { int ret = 1, ret2 = 0; int n = 0; printf(\u0026quot;请输入n:\\n\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); int i = 1; for (i = 1; i \u0026lt;= n; i++) { ret = ret * i; ret2 = ret2 + ret; } printf(\u0026quot;%d!=%d\\n\u0026quot;, n, ret); //计算 n的阶乘。 printf(\u0026quot;1!+2!+……+%d!=%d\u0026quot;, n, ret2); //1!+2!+……+n! return 0; }  \u0026ndash; 在一个有序数组中查找具体的某个数字n。 编写int binsearch(int x, int v[], int n); 功能：在v[0]\u0026lt;=v[1]\u0026lt;=v[2]\u0026lt;= ….\u0026lt;=v[n-1]的数组中查找x.\n#include \u0026lt;stdio.h\u0026gt; int main() { int v[] = {1, 3, 6, 7, 9, 10, 12, 13, 16, 19}; int k = 7; int i = 0; int sz = sizeof(v) / sizeof(int); //折半查找log2n int left = 0; //左下表 int right = sz - 1; //右下标 int mid = 0; while (left \u0026lt;= right) { mid = (left + right) / 2; if (v[mid] \u0026gt; k) { right = mid - 1; } else if (v[mid] \u0026lt; k) { left = mid + 1; } else break; } if (left \u0026lt;= right) printf(\u0026quot;找到了,下标是%d\\n\u0026quot;, mid); else printf(\u0026quot;找不到\\n\u0026quot;); //时间复杂度为O(n) // for (i = 0; i \u0026lt; sz; i++) // { // if (k == v[i]) // { // printf(\u0026quot;找到了,下标是%d\\n\u0026quot;, i); // break; // } // } // if (sz == i) // { // printf(\u0026quot;未找到\u0026quot;); // } return 0; } //如果实现一个二分查找函数： int bin_search(int arr[], int left, int right, int key) { int mid = 0; while (left \u0026lt;= right) { mid = (left + right) \u0026gt;\u0026gt; 1; if (arr[mid] \u0026gt; key) { right = mid - 1; } else if (arr[mid] \u0026lt; key) { left = mid + 1; } else return mid; //找到了，返回下标 } return -1; //找不到 }  \u0026ndash; 编写代码，演示多个字符从两端移动，向中间汇聚。\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { //welcome to China!!!!!! //###################### //w####################! //we##################!! // …… char arr1[] = \u0026quot;welcome to China!!!!!!\u0026quot;; //以\\0未结束 char arr2[] = \u0026quot;######################\u0026quot;; int left = 0; //int right = sizeof(arr1) / sizeof(arr1[0]) - 2; int right = strlen(arr1)-1; while (left\u0026lt;= right) { arr2[left] = arr1[left]; arr2[right] = arr1[right]; printf(\u0026quot;%s\\n\u0026quot;, arr2); //休息1秒 Sleep(1000); system(\u0026quot;cls\u0026quot;);//执行系统命令的一个函数-cls-清空屏幕 left++; right--; } printf(\u0026quot;%s\\n\u0026quot;, arr2); return 0; }  \u0026ndash; 编写代码实现，模拟用户登录情景，并且只能登录三次。（只允许输入三次密码，如果密码正确则提示登录成，如果三次均输入错误，则退出程序。\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; char password[20] = {0}; for (i = 0; i \u0026lt; 3; i++) { printf(\u0026quot;请输入密码：\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, password); // if (password == \u0026quot;123456\u0026quot;)//== 不能用来比较两个字符串是否相等，应该使用一个库函数-strcmp if (strcmp(password, \u0026quot;123456\u0026quot;) == 0) { printf(\u0026quot;登录成功\\n\u0026quot;); break; } else { printf(\u0026quot;密码错误\\n\u0026quot;); } } if (i == 3) printf(\u0026quot;三次密码均错误，退出程序\\n\u0026quot;); return 0; }  练习2 从小到大输出三个数 #include \u0026lt;stdio.h\u0026gt; int main() { int a = 0, b = 0, c = 0; scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;a, \u0026amp;b, \u0026amp;c); //算法实现a\u0026gt;b \u0026gt;c if (a \u0026lt; b) { int tmp = a; a = b; b = tmp; } if (a \u0026lt; c) { int tmp = a; a = c; c = tmp; } if (b \u0026lt; c) { int tmp = b; b = c; c = tmp; } printf(\u0026quot;%d %d %d\\n\u0026quot;, a, b, c); return 0; }  打印1-100之间所有3的倍数的数字 #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; for (i = 1; i \u0026lt;= 100; i++) { if (i % 3 == 0) { printf(\u0026quot;%d \u0026quot;, i); } } return 0; }  给定两个数求最大公约数 #include \u0026lt;stdio.h\u0026gt; int main() { int m = 0; int n = 0; int r = 0; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;m, \u0026amp;n); //辗转相除法 while (r = m % n) { m = n; n = r; } printf(\u0026quot;%d\\n\u0026quot;, n); return 0; }  打印1000-2000之间的闰年 #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; int count = 0; for (i = 1000; i \u0026lt;= 2000; i++) { //判断year 是否为闰年 // 1. 能被4整除，且不能被100整除的是闰年 // 2. 能被400整除是闰年 // if (i % 4 == 0 \u0026amp;\u0026amp; i % 100 != 0) // { // count++; // printf(\u0026quot;%d \u0026quot;, i); // } // else if (i % 400 == 0) // { // count++; // printf(\u0026quot;%d \u0026quot;, i); // } if ((i % 4 == 0 \u0026amp;\u0026amp; i % 100 != 0) || i % 400 == 0) { count++; printf(\u0026quot;%d \u0026quot;, i); } } printf(\u0026quot;\\ncount=%d\\n\u0026quot;, count); return 0; }  打印100-200之间的素数《素数求解的n种境界》 #include \u0026lt;math.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; int count = 0; //sqrt - 开平方的数学库函数 for (i = 101; i \u0026lt;= 200; i += 2) //排除所有偶数 { //判断i是否为素数 //素数判断的规则 //1. 试除法: 产生2-\u0026gt;i-1 // i=a*b a和b中至少有一个数字≤开平方i int j = 0; for (j = 2; j \u0026lt;= sqrt(i); j++) //i/2也是对的 { if (i % j == 0) { break; } } if (j \u0026gt; sqrt(i)) { count++; printf(\u0026quot;%d \u0026quot;, i); } } printf(\u0026quot;\\ncount=%d\\n\u0026quot;, count); return 0; }  编写程序数1-100所有整数种出现多少个数字9 #include \u0026lt;stdlib.h\u0026gt; //itoa所需要的库函数 #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; int j = 0; int count = 1; for (i = 1; i \u0026lt;= 100; i++) { // //法一： // if (i % 10 == 9) // { // count++; // } // if (i / 10 == 9) // { // count++; // } //法二：使用itoa函数 char s[10] = {0}; itoa(i, s, 10); // itoa(int,char,要转换的进制数) for (j = 0; j \u0026lt; strlen(s); j++) { if (s[j] == '9') { count++; printf(\u0026quot;%d \u0026quot;, i); break; } } } printf(\u0026quot;\\ncount=%d\\n\u0026quot;, count); return 0; }  计算1/1-1\u0026frasl;2+1\u0026frasl;3-1/4……-1\u0026frasl;100 #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; double re = 0; // int flag = 1; // for (i = 1; i \u0026lt;= 100; i++) // { // re = re + flag * (1.0 / i); // flag = flag * (-1); // } for (i = 1; i \u0026lt;= 100; i += 2) { re = re + 1.0 / i; } for (i = 2; i \u0026lt;= 100; i += 2) { re = re - 1.0 / i; } printf(\u0026quot;%lf\u0026quot;, re); return 0; }  求10个整数的最大值 #include \u0026lt;stdio.h\u0026gt; int main() { int arr[] = {1, 23, 4, 5, 6, 7, 32, 13, 33, 54}; int i = 0; int max = arr[0]; //如果max=0,则无法判断负数 for (i = 1; i \u0026lt; sizeof(arr) / sizeof(arr[0]); i++) { if (arr[i] \u0026gt; max) { max = arr[i]; } } printf(\u0026quot;max=%d\\n\u0026quot;, max); return 0; }  乘法口诀表 #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0, j = 0; for (i = 1; i \u0026lt; 10; i++) { for (j = 1; j \u0026lt;= i; j++) { printf(\u0026quot;%d * %d = %-2d \u0026quot;, j, i, i * j); //不够两位补空格 } printf(\u0026quot;\\n\u0026quot;); } return 0; }  猜数字游戏  电脑会生成一个随机数 猜数字  注：\n时间戳：当前计算机时间-计算机的起始时间（1970.1.1.0：0：0）=（xxxx）秒 rand() RAND_MAX-32767  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; void menu() { printf(\u0026quot;**********************************\\n\u0026quot;); printf(\u0026quot;*********** 1.play **********\\n\u0026quot;); printf(\u0026quot;*********** 0.exit **********\\n\u0026quot;); printf(\u0026quot;**********************************\\n\u0026quot;); } //TDD-测试驱动开发。 //RAND_MAX--rand函数能返回随机数的最大值。 void game() { //生成随机数 int random_num = rand() % 100 + 1; //1-100之间的 int input = 0; //接收猜的数字 while (1) { printf(\u0026quot;请输入猜的数字\u0026gt;:\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;input); if (input \u0026gt; random_num) { printf(\u0026quot;猜大了\\n\u0026quot;); } else if (input \u0026lt; random_num) { printf(\u0026quot;猜小了\\n\u0026quot;); } else { printf(\u0026quot;恭喜你，猜对了\\n\u0026quot;); break; } } } int main() { int input = 0; srand((unsigned)time(NULL)); //拿时间戳设置一个随机起点，设置一次就可以，不要频繁调用 do { menu(); printf(\u0026quot;请选择\u0026gt;:\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;input); switch (input) { case 1: game(); break; case 0: printf(\u0026quot;退出游戏!\\n\u0026quot;); break; default: printf(\u0026quot;选择错误,请重新输入!\\n\u0026quot;); break; } } while (input); return 0; }  goto语句 C语言中提供了可以随意滥用的 goto语句和标记跳转的标号。 从理论上 goto语句是没有必要的，实践中没有goto语句也可以很容易的写出代码。 但是某些场合下goto语句还是用得着的，最常见的用法就是终止程序在某些深度嵌套的结构的处理过 程，例如一次跳出两层或多层循环。 这种情况使用break是达不到目的的。它只能从最内层循环退出到上一层的循环。\n使用场景 for (...) for (...) { for (...) { if (disaster) goto error; } } … error : if (disaster) // 处理错误情况  示例 #include \u0026lt;stdio.h\u0026gt; int main() { //死循环 again: printf(\u0026quot;hello\u0026quot;); goto again; return 0; }  \u0026ndash; 一个关机程序\n#include \u0026lt;stdio.h\u0026gt; int main() { char input[10] = {0}; system(\u0026quot;shutdown -s -t 60\u0026quot;);//cmd 命令行关机。system 执行系统命令 again: printf(\u0026quot;电脑将在1分钟内关机，如果输入：我是猪，就取消关机!\\n请输入:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, input); if (0 == strcmp(input, \u0026quot;我是猪\u0026quot;)) { system(\u0026quot;shutdown -a\u0026quot;);//取消关机 } else { goto again; } return 0; }  而如果不适用goto语句，则可以使用循环\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char input[10] = {0}; system(\u0026quot;shutdown -s -t 60\u0026quot;); while (1) { printf(\u0026quot;电脑将在1分钟内关机，如果输入：我是猪，就取消关机!\\n请输入:\u0026gt;\u0026quot;); scanf(\u0026quot;%s\u0026quot;, input); if (0 == strcmp(input, \u0026quot;我是猪\u0026quot;)) { system(\u0026quot;shutdown -a\u0026quot;); break; } } return 0; }  ","date":1610838000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1610838000,"objectID":"dd4d1e7a12f416ddd8474cbc0945b5dd","permalink":"https://cytgenkidu.github.io/tutorial/c/2/","publishdate":"2021-01-17T00:00:00+01:00","relpermalink":"/tutorial/c/2/","section":"tutorial","summary":"C语言是一门结构化的程序设计语言  顺序结构 选择结构 循环结构  什么是语句 C语言中由一个分号 ; 隔开的就是一条语句。\nprintf(\u0026quot;hello\u0026quot;); ;//是语句，空语句  分支语句（选择结构） if if语句语法 if(表达式) 语句; if(表达式) 语句1; else 语句2; //多分支 if(表达式1) 语句1; else if(表达式2) 语句2; else 语句3;  if语句示例 int age = 45; if (age \u0026lt; 18) printf(\u0026quot;未成年\\n\u0026quot;); else if (age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt; 28) // 18\u0026lt;=age\u0026lt;28 有问题 printf(\u0026quot;青年\\n\u0026quot;); else if (age \u0026gt;= 28 \u0026amp;\u0026amp; age \u0026lt; 50) printf(\u0026quot;壮年\\n\u0026quot;); else if (age \u0026gt;= 50 \u0026amp;\u0026amp; age \u0026lt; 90) printf(\u0026quot;老年\u0026quot;); else printf(\u0026quot;长寿\u0026quot;);   如果表达式的结果为真，则语句执行。","tags":null,"title":"分支语句和循环语句","type":"docs"},{"authors":null,"categories":null,"content":" Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 4 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"5b12e1f5b685d6e1cb6d193050bdef8f","permalink":"https://cytgenkidu.github.io/tutorial/example/example2/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/tutorial/example/example2/","section":"tutorial","summary":"Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus.","tags":null,"title":"Example Page 2","type":"docs"},{"authors":null,"categories":null,"content":" 函数是什么 维基百科中对函数的定义：子程序\n- 在计算机科学中，子程序（英语：Subroutine, procedure, function, routine, method,subprogram, callable unit），是一个大型程序中的某部分代码， 由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。 - 一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏。这些代码通常被集成为软件库。  C语言中函数的分类  库函数 自定义函数  库函数 为什么会有库函数？\n 我们知道在我们学习C语言编程的时候，总是在一个代码编写完成之后迫不及待的想知道结果，想把这个结果打印到我们的屏幕上看看。这个时候我们会频繁的使用一个功能：将信息按照一定的格式打印到屏幕上（printf）。 在编程的过程中我们会频繁的做一些字符串的拷贝工作（strcpy）。 在编程是我们也计算，总是会计算n的k次方这样的运算（pow）。  注： http://www.cplusplus.com/ http://en.cppreference.com\n常见库函数  IO函数 字符串操作函数 字符操作函数 内存操作函数 时间/日期函数 数学函数 其他库函数  strcpy-拷贝字符串\nchar * strcpy ( char * destination, const char * source );  #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { //strcpy - string copy -字符串拷贝 //strlen - string length -字符串长度有关 char arr1[] = \u0026quot;world\u0026quot;; char arr2[] = \u0026quot;##########\u0026quot;; printf(\u0026quot;%s\\n\u0026quot;, arr2); strcpy(arr2, arr1); printf(\u0026quot;%s\\n\u0026quot;, arr2); return 0; }  memset\nvoid * memset ( void * ptr, int value, size_t num );  #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { char arr[] = \u0026quot;hello world\u0026quot;; memset(arr, '*', 5); printf(\u0026quot;%s\\n\u0026quot;, arr); return 0; }  自定义函数 函数的组成 ret_type fun_name(para1, * ) { statement;//语句项 } ret_type 返回类型 fun_name 函数名 para1 函数参数  例子：写一个函数可以找出两个整数中的最大值 #include \u0026lt;stdio.h\u0026gt; //get_max函数的设计 int get_max(int x, int y) { return (x \u0026gt; y) ? (x) : (y); } int main() { int num1 = 10; int num2 = 20; int max = get_max(num1, num2); printf(\u0026quot;max = %d\\n\u0026quot;, max); return 0; }  例子：写一个函数可以交换两个整形变量的内容 #include \u0026lt;stdio.h\u0026gt; void Swap1(int x, int y) { int tmp = 0; tmp = x; x = y; y = tmp; } void Swap2(int *px, int *py) { int tmp = 0; tmp = *px; //*px - 解引用操作 *px = *py; *py = tmp; } int main() { int num1 = 1; int num2 = 2; Swap1(num1, num2); // 传值调用 printf(\u0026quot;Swap1::num1 = %d num2 = %d\\n\u0026quot;, num1, num2); //没有交换 Swap2(\u0026amp;num1, \u0026amp;num2); // 传址调用 printf(\u0026quot;Swap2::num1 = %d num2 = %d\\n\u0026quot;, num1, num2); //交换了 return 0; }  函数参数 实际参数（实参） 真实传给函数的参数，叫实参。实参可以是：常量、变量、表达式、函数等。无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参.  形式参数（形参） 形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效.  上面Swap1和Swap2函数中的参数 x，y，px，py 都是形式参数。在main函数中传给Swap1的num1，num2和传给Swap2函数的\u0026amp;num1，\u0026amp;num2是实际参数。\n函数调用 传值调用 函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参。  传址调用 1.传址调用是把函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式。 2.这种传参方式可以让函数和函数外边的变量建立起正真的联系，也就是函数内部可以直接操作函数外部的变量.  函数练习  写一个函数，每调用一次这个函数，就会将num的值增加1。  #include \u0026lt;stdio.h\u0026gt; void add(int *px) { *px = *px + 1; // *p++ err } int main() { int num = 0; add(\u0026amp;num); printf(\u0026quot;%d\\n\u0026quot;, num); return 0; }  函数的嵌套调用和链式访问 函数和函数之间可以有机的组合的\n嵌套调用 #include \u0026lt;stdio.h\u0026gt; void new_line() { printf(\u0026quot;hehe\\n\u0026quot;); } void three_line() { int i = 0; for (i = 0; i \u0026lt; 3; i++) { new_line(); } } int main() { three_line();//打印三行hehe return 0; }  链式访问 把一个函数的返回值作为另外一个函数的参数.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char arr[20] = \u0026quot;hello\u0026quot;; int ret = strlen(strcat(arr, \u0026quot;world\u0026quot;)); //strlen函数-字符长度,strcat函数-源字符串的副本追加到目标字符串 printf(\u0026quot;%d\\n\u0026quot;, ret); // 10 return 0; }  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026quot;%d\u0026quot;, printf(\u0026quot;%d\u0026quot;, printf(\u0026quot;%d\u0026quot;, 43)));//printf 返回 打印字符的个数 //结果是啥？4321 return 0; }  函数的声明和定义 函数声明  告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。但是具体是不是存在，无关紧要。 函数的声明一般出现在函数的使用之前。要满足先声明后使用。 函数的声明一般要放在头文件中的。  函数定义 函数的定义是指函数的具体实现，交待函数的功能实现。\nadd.h的内容 放置函数的声明\n#ifndef __ADD_H__ #define __ADD_H__ //函数Add的声明 int Add(int x, int y); #endif //__ADD_H__  add.c的内容 放置函数的定义\n//函数Add的定义 int Add(int x, int y) { int z = x + y; return z; }  test.c的内容 放置函数的实现\n#include \u0026quot;add.h\u0026quot; //函数Add的实现 int main() { printf(\u0026quot;%d\\n\u0026quot;, Add(1, 2)); //3 return 0; }  函数递归 什么是递归 程序调用自身的编程技巧称为递归（ recursion）。 递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。 递归的主要思考方式在于：把大事化小\n递归的两个必要条件  存在限制条件，当满足这个限制条件的时候，递归便不再继续。 每次递归调用之后越来越接近这个限制条件  注：递归要找到条件，否则会溢出 栈溢出： 递归练习  接受一个整型值（无符号），按照顺序打印它的每一位。 例如： 输入：1234，输出 1 2 3 4  #include \u0026lt;stdio.h\u0026gt; void print(int n) { if (n \u0026gt; 9) { print(n / 10); } printf(\u0026quot;%d \u0026quot;, n % 10); } int main() { int num = 0; printf(\u0026quot;输入-\u0026gt; \u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;num); printf(\u0026quot;输出-\u0026gt; \u0026quot;); print(num); return 0; }   编写函数不允许创建临时变量，求字符串的长度。  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int my_strlen(const char *str) { //法一：记数方式 // int count = 0; // while (*str != \u0026quot;\\0\u0026quot;) // { // count++; // str++; // } // return count; //法二：递归方式 if (*str == '\\0') //*str就是字符 return 0; else return 1 + my_strlen(str + 1); //str +1 是str的下一个地址 //法三：指针方式 // char* start = str; // char* end = str; // while (*end != '\\0') // { // end++; // } // return end - start;// } int main() { char arr[] = \u0026quot;hello\u0026quot;; // int len = strlen(arr); // 求字符串长度 // char *p = \u0026quot;abcedke\u0026quot;; // int len = my_strlen(p);//7 int len = my_strlen(arr); //arr是数组，数组传参，传过去的不是整个数组，而是第一个元素的地址 printf(\u0026quot;%d\\n\u0026quot;, len); //5 return 0; }  递归与迭代  求n的阶乘。（不考虑溢出）  #include \u0026lt;stdio.h\u0026gt; int factorial(int n) { if (n \u0026lt;= 1) return 1; else return n * factorial(n - 1); } int main() { int num = 0; int ret = 0; scanf(\u0026quot;%d\u0026quot;, \u0026amp;num); ret = factorial(num); printf(\u0026quot;%d\\n\u0026quot;, ret); return 0; }   求第n个斐波那契数。（不考虑溢出）  \n-- #include \u0026lt;stdio.h\u0026gt; //斐波那契数列：1 1 2 3 5 8 13 21 34 55 … // int count = 0; //全局变量 int fib(int n) { // if (n == 3)//最后我们输出看看count，是一个很大很大的值。 // count++; if (n \u0026lt;= 2) return 1; else return fib(n - 1) + fib(n - 2); } int main() { int num = 0; scanf(\u0026quot;%d\u0026quot;, \u0026amp;num); printf(\u0026quot;%d\u0026quot;, fib(num)); return 0; }  问题  在使用 fib 这个函数的时候如果我们要计算第50个斐波那契数字的时候特别耗费时间。 使用 factorial 函数求10000的阶乘（不考虑结果的正确性），程序会崩溃。  为什么 我们发现 fib 函数在调用的过程中很多计算其实在一直重复。 如果我们把代码修改一下\n那我们如何改进呢？ 在调试 factorial 函数的时候，如果你的参数比较大，那就会报错： `stack overflow（栈溢出） 这样的信息。 系统分配给程序的栈空间是有限的，但是如果出现了死循环，或者（死递归），这样有可能导致一直开辟栈空间，最终产生栈空间耗尽的情况，这样的现象我们称为栈溢出。\n那如何解决上述的问题  将递归改写成非递归。 使用static对象替代nonstatic局部对象。在递归函数设计中，可以使用static对象替代nonstatic局部对象（即栈对象），这不仅可以减少每次递归调用和返回时产生和释放nonstatic对象的开销，而且static对象还可以保存递归调用的中间状态，并且可为各个调用层所访问.   改进factorial  int factorial(int n) { int res = 1; while (n \u0026gt; 1) { res *= n; n -= 1; } return res; }   改进fib  //斐波那契数列：1 1 2 3 5 8 13 21 34 55 … int fib(int n) { int res = 1; int pre_res = 1; int next_older_res = 0; while (n \u0026gt; 2) { next_older_res = pre_res; pre_res = res; res = pre_res + next_older_res; n--; } return res; }  提示  许多问题是以递归的形式进行解释的，这只是因为它比非递归的形式更为清晰。 但是这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性稍微差些。 当一个问题相当复杂，难以用迭代实现时，此时递归实现的简洁性便可以补偿它所带来的运行时开销。  练习 字符串逆序（递归实现） 编写一个函数reverse_string(char* string)(递归实现)\n实现：将参数字符串中的字符反向排列。\n要求：不能使用C库函数中的字符串操作函数。\n 主函数  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int my_strlen(char* str) { int count = 0; while (*str != '\\0') { count++; str++; } return count; } //…… int main() { char arr[] = \u0026quot;abcdefg\u0026quot;;//fedcba reverse_string(arr); printf(\u0026quot;%s\\n\u0026quot;, arr); return 0; }   非递归方式\nvoid reverse_string(char arr[]) { int left = 0; int right = my_strlen(arr)-1; while (left\u0026lt;right) { int tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; left++; right--; } }  递归方式\n//abcdef // a和f的小环 // 逆序reverse_string(\u0026quot;bcde\u0026quot;) void reverse_string(char* arr) { char tmp = arr[0];//先放a int len = my_strlen(arr); arr[0] = arr[len - 1]; arr[len - 1] = '\\0';//把f位置替换为\\0 if (my_strlen(arr+1) \u0026gt;=2) reverse_string(arr+1);//reverse_string(\u0026quot;bcde\\0\u0026quot;); arr[len - 1] = tmp;//把f放在最后 }    计算一个数的每位之和（递归实现） 写一个递归函数DigitSum(n),输入一个非负整数，返回组成它的数字之后而\n例如：调用 DigitSum(1729),则应该返回是1+7+2+9，它的和是19\n#include \u0026lt;stdio.h\u0026gt; //DigitSum(1729) //DigitSum(172) + 1729%10 //DigitSum(17) + 172%10 + 1729%10 //DigitSum(1) + 17%10 + ... //1+7+2+9 int DigitSum(unsigned int num) { if (num \u0026gt; 9) { return DigitSum(num / 10) + num % 10; } else { return num; } } int main() { unsigned int num = 0; scanf(\u0026quot;%d\u0026quot;, \u0026amp;num);//1729 int ret = DigitSum(num); printf(\u0026quot;ret = %d\\n\u0026quot;, ret); return 0; }  递归实现n的k次方 #include \u0026lt;stdio.h\u0026gt; double Pow(int n, int k) { //n^k = n* n^(k-1) if (k \u0026lt; 0) return (1.0 / (Pow(n, -k))); else if (k == 0) return 1; else return n*Pow(n, k - 1); } int main() { int n = 0; int k = 0; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;k); double ret = Pow(n, k); printf(\u0026quot;ret = %lf\\n\u0026quot;, ret); return 0; }  ","date":1610838000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1610838000,"objectID":"510eaeaf3813bfc5c0a0fd743a929c59","permalink":"https://cytgenkidu.github.io/tutorial/c/3/","publishdate":"2021-01-17T00:00:00+01:00","relpermalink":"/tutorial/c/3/","section":"tutorial","summary":"函数是什么 维基百科中对函数的定义：子程序\n- 在计算机科学中，子程序（英语：Subroutine, procedure, function, routine, method,subprogram, callable unit），是一个大型程序中的某部分代码， 由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。 - 一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏。这些代码通常被集成为软件库。  C语言中函数的分类  库函数 自定义函数  库函数 为什么会有库函数？\n 我们知道在我们学习C语言编程的时候，总是在一个代码编写完成之后迫不及待的想知道结果，想把这个结果打印到我们的屏幕上看看。这个时候我们会频繁的使用一个功能：将信息按照一定的格式打印到屏幕上（printf）。 在编程的过程中我们会频繁的做一些字符串的拷贝工作（strcpy）。 在编程是我们也计算，总是会计算n的k次方这样的运算（pow）。  注： http://www.cplusplus.com/ http://en.cppreference.com\n常见库函数  IO函数 字符串操作函数 字符操作函数 内存操作函数 时间/日期函数 数学函数 其他库函数  strcpy-拷贝字符串\nchar * strcpy ( char * destination, const char * source );  #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { //strcpy - string copy -字符串拷贝 //strlen - string length -字符串长度有关 char arr1[] = \u0026quot;world\u0026quot;; char arr2[] = \u0026quot;##########\u0026quot;; printf(\u0026quot;%s\\n\u0026quot;, arr2); strcpy(arr2, arr1); printf(\u0026quot;%s\\n\u0026quot;, arr2); return 0; }  memset","tags":null,"title":"函数","type":"docs"},{"authors":null,"categories":null,"content":" 一维数组的创建和初始化 数组的创建 数组是一组相同类型元素的集合。 数组的创建方式\ntype_t arr_name [const_n]; //type_t 是指数组的元素类型 //const_n 是一个常量表达式，用来指定数组的大小  素组创建的实例\n注：数组创建， [] 中要给一个常量才可以，不能使用变量。\n//创建一个数组-存放整形-10个 int arr[5] = {1, 2, 3}; //不完全初始化，剩下的元素默认初始化为0 char arr2[5] = {'a', 'b'}; char arr3[5] = \u0026quot;ab\u0026quot;; char arr4[] = \u0026quot;abcdef\u0026quot;; // int n = 5; // char ch[n];//err printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr4)); //7 sizeof 计算变量、数组、类型的大小-单位是字节- 操作符 printf(\u0026quot;%d\\n\u0026quot;, strlen(arr4)); //6 strlen 是求字符串长度的，只针对字符串求长度- 库函数-使用得引用头文件  数组的初始化 数组的初始化是指，在创建数组的同时给数组的内容一些合理初始值（初始化）。\nchar arr1[] = \u0026quot;abc\u0026quot;; char arr2[] = {'a', 'b', 'c'}; printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr1)); //4 printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr2)); //3 printf(\u0026quot;%d\\n\u0026quot;, strlen(arr1)); //3 printf(\u0026quot;%d\\n\u0026quot;, strlen(arr2)); //随机数，没有\\0结束字符  一维数组的使用 对于数组的使用我们之前介绍了一个操作符： [] ，下标引用操作符。它其实就数组访问的操作符。\nchar arr[] = \u0026quot;abcdef\u0026quot;; //[a][b][c][d][e][f][\\0] printf(\u0026quot;%c\\n\u0026quot;, arr[3]);//d int i = 0; for (i = 0; i \u0026lt; (int)strlen(arr); i++) { printf(\u0026quot;%c \u0026quot;, arr[i]); }  总结:\n 数组是使用下标来访问的，下标是从0开始。 数组的大小可以通过计算得到。int sz = sizeof(arr) / sizeof(arr[0]);  一维数组在内存中的存储 int arr[10] = {0}; // 数组在内存中是连续存放的。 int i = 0; for (i = 0; i \u0026lt; sizeof(arr) / sizeof(arr[0]); ++i) { printf(\u0026quot;\u0026amp;arr[%d] = %p\\n\u0026quot;, i, \u0026amp;arr[i]); //10进制：0-9 16进制 0-9 a b c d e f }  数组在内存中是连续存放的。 二维数组的创建和初始化 int arr[3][4] = {1, 2, 3, 4, 5}; int arr1[3][4] = {{1, 2, 3}, {4, 5}}; // int arr2[][] = {1, 2, 3, 4, 5};//err // int arr3[][] = {{1, 2, 3}, {4, 5}};//err // int arr4[2][] = {{1, 2, 3}, {4, 5}};//err int arr5[][4] = {{1, 2, 3}, {4, 5}}; //行可以省略，列不可省略 //char ch[5][6];  二维数组的使用 int arr[3][4] = {0}; int i = 0; //赋值 for (i = 0; i \u0026lt; 3; i++) { int j = 0; for (j = 0; j \u0026lt; 4; j++) { arr[i][j] = i * 4 + j; } } //使用 for (i = 0; i \u0026lt; 3; i++) { int j = 0; for (j = 0; j \u0026lt; 4; j++) { printf(\u0026quot;%2d \u0026quot;, arr[i][j]); } printf(\u0026quot;\\n\u0026quot;); }  二维数组在内存中的存储 int arr[3][4] = {{1, 2, 3}, {4, 5}}; int i = 0; //存储 for (i = 0; i \u0026lt; 3; i++) { int j = 0; for (j = 0; j \u0026lt; 4; j++) { printf(\u0026quot;\u0026amp;arr[%d][%d] = %p\\n\u0026quot;, i, j, \u0026amp;arr[i][j]); } }  二维数组在内存中也是连续存储的。 数组作为函数参数 数组名是数组首元素的地址。（有两个例外）\n sizeof(数组名)，计算整个数组的大小，sizeof内部单独放一个数组名，数组名表示整个数组。 \u0026amp;数组名，取出的是数组的地址。\u0026amp;数组名，数组名表示整个数组。  除此1,2两种情况之外，所有的数组名都表示数组首元素的地址。\nint arr[10] = {1, 2, 3, 4, 5}; printf(\u0026quot;%p\\n\u0026quot;, arr); printf(\u0026quot;%p\\n\u0026quot;, arr + 1); printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;arr[0]); printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;arr[0] + 1); printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;arr); //数组的地址≠数组首元素的地址 printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;arr + 1); //意义不同，增加了5*4个字节，开始取的是1的地址，+1之后是取5后面的地址 printf(\u0026quot;%d\\n\u0026quot;, *arr);  冒泡排序函数 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n针对所有的元素重复以上的步骤，除了最后一个。\n持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n#include \u0026lt;stdio.h\u0026gt; void bubble_sort(int arr[], int sz)//int *arr { int i = 0; // 确定冒泡排序的趟数 // int sz = sizeof(arr) / sizeof(arr[0]); //这样对吗？ 不对 for (i = 0; i \u0026lt; sz - 1; i++) { int flag = 1; //假设这一趟要排序的数据已经有序 //每一趟冒泡排序 int j = 0; for (j = 0; j \u0026lt; sz - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = 0; //本趟排序的数据其实不完全有序 } } if (flag == 1) { break;// if不能break,这个break是跳出外层循环 } } } int main() { int arr[] = {3, 1, 7, 5, 8, 9, 0, 2, 4, 6}; //对arr进行排序，排成升序 int sz = sizeof(arr) / sizeof(arr[0]); // bubble_sort(arr); //是否可以正常排序？ // arr是数组，我们对数组arr进行传参，实际上传递过去的是数组arr首元素的地址 \u0026amp;arr[0] bubble_sort(arr,sz); // 冒泡排序函数 int i = 0; for (i = 0; i \u0026lt; sizeof(arr) / sizeof(arr[0]); i++) { printf(\u0026quot;%d \u0026quot;, arr[i]); } return 0; }  练习 创建一个整形数组，完成数组的操作  实现函数init()初始化数组为全0 实现print()打印数组的每个元素 实现reverse()完成数组元素的逆置  void Init(int arr[], int sz) { int i = 0; for (i = 0; i \u0026lt; sz; i++) { arr[i] = 0; } } void Print(int arr[], int sz) { int i = 0; for (i = 0; i \u0026lt; sz; i++) { printf(\u0026quot;%d \u0026quot;, arr[i]); } printf(\u0026quot;\\n\u0026quot;); } void Reverse(int arr[], int sz) { int left = 0; int right = sz - 1; while (left\u0026lt;right) { int tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; left++; right--; } } int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int sz = sizeof(arr) / sizeof(arr[0]); //Init(arr, sz);//把数组初始化0 Print(arr, sz);//打印 1 2 3 4 5 6 7 8 9 10 Reverse(arr, sz); Print(arr, sz);//打印 10 9 8 7 6 5 4 3 2 1 return 0; }  将数组A中的内容和数组B中的内容进行交换。（数组一样大） int arr1[] = { 1, 3, 5, 7, 9 };//不能直接与tmp[5]={0}交换，因为arr1存储的是arr1首元素地址 int arr2[] = { 2, 4, 6, 8, 0 }; int tmp = 0; int i = 0; int sz = sizeof(arr1) / sizeof(arr1[0]); for (i = 0; i \u0026lt; sz; i++) { tmp = arr1[i]; arr1[i] = arr2[i]; arr2[i] = tmp; }  ","date":1612306800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1612306800,"objectID":"cd75c0891aa3afe86f790ca8d64772e2","permalink":"https://cytgenkidu.github.io/tutorial/c/4/","publishdate":"2021-02-03T00:00:00+01:00","relpermalink":"/tutorial/c/4/","section":"tutorial","summary":"一维数组的创建和初始化 数组的创建 数组是一组相同类型元素的集合。 数组的创建方式\ntype_t arr_name [const_n]; //type_t 是指数组的元素类型 //const_n 是一个常量表达式，用来指定数组的大小  素组创建的实例\n注：数组创建， [] 中要给一个常量才可以，不能使用变量。\n//创建一个数组-存放整形-10个 int arr[5] = {1, 2, 3}; //不完全初始化，剩下的元素默认初始化为0 char arr2[5] = {'a', 'b'}; char arr3[5] = \u0026quot;ab\u0026quot;; char arr4[] = \u0026quot;abcdef\u0026quot;; // int n = 5; // char ch[n];//err printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr4)); //7 sizeof 计算变量、数组、类型的大小-单位是字节- 操作符 printf(\u0026quot;%d\\n\u0026quot;, strlen(arr4)); //6 strlen 是求字符串长度的，只针对字符串求长度- 库函数-使用得引用头文件  数组的初始化 数组的初始化是指，在创建数组的同时给数组的内容一些合理初始值（初始化）。\nchar arr1[] = \u0026quot;abc\u0026quot;; char arr2[] = {'a', 'b', 'c'}; printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr1)); //4 printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr2)); //3 printf(\u0026quot;%d\\n\u0026quot;, strlen(arr1)); //3 printf(\u0026quot;%d\\n\u0026quot;, strlen(arr2)); //随机数，没有\\0结束字符  一维数组的使用 对于数组的使用我们之前介绍了一个操作符： [] ，下标引用操作符。它其实就数组访问的操作符。","tags":null,"title":"数组","type":"docs"},{"authors":null,"categories":null,"content":" 操作符 分类  算术操作符 移位操作符 位操作符 赋值操作符 单目操作符 关系操作符 逻辑操作符 条件操作符 逗号表达式 下标引用、函数调用和结构成员  算术操作符 + - * / %   除了 % 操作符之外，其他的几个操作符可以作用于整数和浮点数。 对于 / 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。 % 操作符的两个操作数必须为整数。返回的是整除之后的余数。  double a = 5 % 2;//商2余1 printf(\u0026quot;a = %lf\\n\u0026quot;, a);//1.000000  移位操作符 ：移动是二进制位，只能作用于整形 \u0026lt;\u0026lt; 左移操作符 \u0026gt;\u0026gt; 右移操作符  左移操作符 移位规则： **左边抛弃、右边补0**  int a = 5; int b = a \u0026lt;\u0026lt; 1; //00000000000000000000000000000101 //00000000000000000000000000001010 printf(\u0026quot;%d\\n\u0026quot;, b); //10  右移操作符 移位规则：[右移1位有除2的效果] 首先右移运算分两种： 1. 逻辑移位 左边用0填充，右边丢弃 2. 算术移位 左边用原该值的符号位填充，右边丢弃  int a = 16; //\u0026gt;\u0026gt; -- 右移操作符 //移动的是二进制位 //00000000000000000000000000010000 int b = a \u0026gt;\u0026gt; 2; //00000000000000000000000000000100 printf(\u0026quot;%d\\n\u0026quot;, b); //4  int a = -1; //整数的二进制表示有：原码、反码、补码 //存储到内存的是补码 //10000000000000000000000000000001 - 原码 //11111111111111111111111111111110 - 反码 //11111111111111111111111111111111 - 补码 int b = a \u0026gt;\u0026gt; 1; printf(\u0026quot;%d\\n\u0026quot;, b); //-1  警告⚠ ： 对于移位运算符，不要移动负数位，这个是标准未定义的。 例如：\nint num = 10; num\u0026gt;\u0026gt;-1;//error  位操作符 : 只能作用于整数 \u0026amp; //按位与 | //按位或 ^ //按位异或   \u0026amp; - 按2进制位与 对应的两个二进位均为1时，结果位才为1 ，否则为0。【补码形式比较】  int a = 3; // 00000000000000000000000000000011 int b = 5; // 00000000000000000000000000000101 int c = a\u0026amp;b; // 00000000000000000000000000000001 printf(\u0026quot;%d\\n\u0026quot;, c);   | - 按2进制位或 对应的两个二进位有一个为1时，结果位就为1。【补码形式比较】  int a = 3; //00000000000000000000000000000011 int b = 5; //00000000000000000000000000000101 int c = a | b; //00000000000000000000000000000111 printf(\u0026quot;%d\\n\u0026quot;, c);   ^ 按2进制位异或: 相同为0，相异为1 对应的两个二进位相异时，结果位为1。【补码形式比较】 C++ int a = 3; //00000000000000000000000000000011 int b = 5; //00000000000000000000000000000101 int c = a ^ b; //00000000000000000000000000000110 printf(\u0026quot;%d\\n\u0026quot;, c);   赋值操作符 int weight = 120;//体重 weight = 89;//不满意就赋值 double salary = 10000.0; salary = 20000.0;//使用赋值操作符赋值。  赋值操作符可以连续使用，比如：\nint a = 10; int x = 0; int y = 20; a = x = y+1;//连续赋值,避免使用 a=x=21  复合赋值符 += -= *= /= %= \u0026gt;\u0026gt;= \u0026lt;\u0026lt;= \u0026amp;= |= ^=  单目操作符 ! 逻辑反操作 - 负值 + 正值 \u0026amp; 取地址 sizeof 操作数的类型长度（以字节为单位） ~ 对一个数的二进制按位取反 -- 前置、后置-- ++ 前置、后置++ * 间接访问操作符(解引用操作符) (类型) 强制类型转换  sizeof和数组 int a = 10; char c = 'r'; char *p = \u0026amp;c; int arr[10] = {0}; //sizeof 计算的变量所占内存空间的大小，单位是字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof a); //4 printf(\u0026quot;%d\\n\u0026quot;, sizeof(int)); //4 printf(\u0026quot;%d\\n\u0026quot;, sizeof(c)); //1 printf(\u0026quot;%d\\n\u0026quot;, sizeof(char)); //1 printf(\u0026quot;%d\\n\u0026quot;, sizeof(p)); //4 printf(\u0026quot;%d\\n\u0026quot;, sizeof(char *)); //4 printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr)); //40 printf(\u0026quot;%d\\n\u0026quot;, sizeof(int[10])); //40  sizeof 内部的表达式不参与运算\nshort s = 0; int a = 10; printf(\u0026quot;%d\\n\u0026quot;, sizeof(s = a + 5)); //2 printf(\u0026quot;%d\\n\u0026quot;, s); //0  练习\nvoid test1(int arr[]) { printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr)); //(2) 4/8 } void test2(char ch[]) { printf(\u0026quot;%d\\n\u0026quot;, sizeof(ch)); //(4) 4/8 } int main() { int arr[10] = {0}; char ch[10] = {0}; printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr)); //(1) 40 printf(\u0026quot;%d\\n\u0026quot;, sizeof(ch)); //(3) 10 test1(arr); //传参是首元素地址，指针的大小4/8 test2(ch); //传参是首元素地址,指针的大小4/8 return 0; }  ~ 按位取反 int a = 0; //~ 按（2进制）位取反 //00000000000000000000000000000000 - 原码 0 //11111111111111111111111111111111 - 补码 //11111111111111111111111111111110 - 反码 -1 //10000000000000000000000000000001 - 原码 //-1 printf(\u0026quot;%d\\n\u0026quot;, ~a);  int a = 11; a = a | (1 \u0026lt;\u0026lt; 2); printf(\u0026quot;%d\\n\u0026quot;, a); //15 a = a \u0026amp; (~(1 \u0026lt;\u0026lt; 2)); printf(\u0026quot;%d\\n\u0026quot;, a); //11 //0000000000000000000000000000001011 - 11 //0000000000000000000000000000000100 - (1 \u0026lt;\u0026lt; 2) //0000000000000000000000000000000001 - 1 // //0000000000000000000000000000001111 - 或 结果 //1111111111111111111111111111111011 - ~(1 \u0026lt;\u0026lt; 2) //0000000000000000000000000000000100 //0000000000000000000000000000001011 - 且 结果  ++和\u0026ndash;运算符 int a = 10; //printf(\u0026quot;%d\\n\u0026quot;, ++a);//前置++，先++，后使用 printf(\u0026quot;%d\\n\u0026quot;, a++);//后置++，先使用，再++  （类型） int a = (int)3.14; //int a = int(3.14);//err  关系操作符 \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= != 用于测试“不相等” == 用于测试“相等  警告： 在编程的过程中== 和=不小心写错，会导致的错误。\n逻辑操作符 \u0026amp;\u0026amp; 逻辑与 || 逻辑或  \u0026amp;\u0026amp; 逻辑与：两个条件都同时成立的情况下“逻辑与”的运算结果才为“真”。\n 当逻辑与左边为false(假)，则不再进行逻辑与右边的判断，结果为false(假) 当逻辑与左边为true(真)则进行右边判断，右边为false(假)，结果为false(假) 当逻辑与左边为true(真)则进行右边判断，右边也为true(真)，则结果为true(真)  || 逻辑或：任一或多个条件成立的情况下“逻辑或”的运算才为“真”。\n 当逻辑或左边为false(假)，继续逻辑或右边的判断，如果也为false(假)，结果为false(假) 当逻辑或左边为false(假)，继续逻辑或右边的判断，如果为true(真)，结果为true(真) 当逻辑或左边为true(真)，则不再进行逻辑或右边的判断，结果为true(真)  区分逻辑与和按位与 区分逻辑或和按位或\n1\u0026amp;2-----\u0026gt;0 1\u0026amp;\u0026amp;2----\u0026gt;1 1|2-----\u0026gt;3 1||2----\u0026gt;1 //00000000000000000000000000000001 -1 //00000000000000000000000000000010 -2 //00000000000000000000000000000000 -1\u0026amp;2 //00000000000000000000000000000011 -1|2  int i = 0, a = 0, b = 2, c = 3, d = 4; i = a++ \u0026amp;\u0026amp; ++b \u0026amp;\u0026amp; d++; //a++ 是后置++，先使用再++。a=0 为假，后面不管是什么都不算了，a++ printf(\u0026quot; a = %d\\n b = %d\\n c = %d\\n d = %d\\n\u0026quot;, a, b, c, d); //1 2 3 4  int i = 0, a = 1, b = 2, c = 3, d = 4; i = a++ \u0026amp;\u0026amp; ++b \u0026amp;\u0026amp; d++;//a=1为真，a++,++b是前置++，先加在使用，b=3为真，d=4为真，d++ printf(\u0026quot; a = %d\\n b = %d\\n c = %d\\n d = %d\\n\u0026quot;, a, b, c, d); //2 3 3 5  int i = 0, a = 0, b = 2, c = 3, d = 4; i = a++ || ++b || d++; //a=0为假，a++,b++,b=3为真，结束 printf(\u0026quot; a = %d\\n b = %d\\n c = %d\\n d = %d\\n\u0026quot;, a, b, c, d); //1 3 3 4  int i = 0, a = 1, b = 2, c = 3, d = 4; i = a++ || ++b || d++; //a=1为真，结束。a++ printf(\u0026quot; a = %d\\n b = %d\\n c = %d\\n d = %d\\n\u0026quot;, a, b, c, d); //2 2 3 4  条件操作符 exp1 ? exp2 : exp3  if (a \u0026gt; 5) b = 3; else b = -3; b = (a \u0026gt; 5 ? 3 : -3);  int a = 10; int b = 20; int max = 0; if (a \u0026gt; b) max = a; else max = b; max = (a \u0026gt; b ? a : b);  逗号表达式 exp1, exp2, exp3, …expN  逗号表达式，就是用逗号隔开的多个表达式。 逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。\n//代码1 int a = 1; int b = 2; int c = (a \u0026gt; b, a = b + 10, a, b = a + 1); //逗号表达式，c=13  //代码2 if (a = b + 1, c = a / 2, d \u0026gt; 0)  //代码3 a = get_val(); count_val(a); while (a \u0026gt; 0) { //业务处理 a = get_val(); count_val(a); } //如果使用逗号表达式，改写: while (a = get_val(), count_val(a), a \u0026gt; 0) { //业务处理 }  下标引用、函数调用和结构成员  []下标引用操作符 操作数：一个数组名+一个索引值\nint arr[10];//创建数组 arr[9] = 10;//实用下标引用操作符。 [ ]的两个操作数是arr和9。  ( ) 函数调用操作符 接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。\nvoid test1() { printf(\u0026quot;hehe\\n\u0026quot;); } void test2(const char *str) { printf(\u0026quot;%s\\n\u0026quot;, str); } int main() { test1(); //实用（）作为函数调用操作符。 test2(\u0026quot;hello world.\u0026quot;);//实用（）作为函数调用操作符。 return 0; }  访问一个结构的成员\n. 结构体.成员名 -\u0026gt; 结构体指针-\u0026gt;成员名  //创建一个结构体类型-struct Stu struct Stu { //成员变量 char name[20]; int age; char id[20]; }; int main() { //使用struct Stu这个类型创建了一个学生对象s1，并初始化 struct Stu s1 = {\u0026quot;张三\u0026quot;, 20, \u0026quot;2019010305\u0026quot;}; struct Stu *ps = \u0026amp;s1; printf(\u0026quot;%s\\n\u0026quot;, ps-\u0026gt;name); printf(\u0026quot;%d\\n\u0026quot;, ps-\u0026gt;age); //结构体指针-\u0026gt;成员名 /*printf(\u0026quot;%s\\n\u0026quot;, (*ps).name); printf(\u0026quot;%d\\n\u0026quot;, (*ps).age);*/ /*printf(\u0026quot;%s\\n\u0026quot;, s1.name); printf(\u0026quot;%d\\n\u0026quot;, s1.age); printf(\u0026quot;%s\\n\u0026quot;, s1.id);*/ //结构体变量.成员名 return 0; }   表达式求值 表达式求值的顺序一部分是由操作符的优先级和结合性决定。 同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。\n隐式类型转换 C的整型算术运算总是至少以缺省整型类型的精度来进行的。 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。\n整型提升的意义：\n表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。\n因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。\n通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。\n负数的整形提升\nchar c1 = -1;  变量c1的二进制位(补码)中只有8个比特位： 1111111 因为 char 为有符号的 char 所以整形提升的时候，高位补充符号位，即为1 提升之后的结果是： 11111111111111111111111111111111 - 补码=反码+1 11111111111111111111111111111110 - 反码 10000000000000000000000000000001 - 原码  正数的整形提升\nchar c2 = 1;  变量c2的二进制位(补码)中只有8个比特位： 00000001 因为 char 为有符号的 char 所以整形提升的时候，高位补充符号位，即为0 提升之后的结果是： 00000000000000000000000000000001  无符号整形提升，高位补0\n两个整形提升的变量如何相加\nchar a = 3; //00000000000000000000000000000011 //00000011 - a // char b = 127; //‭00000000000000000000000001111111 //‬01111111 - b //a和b如何相加 //00000000000000000000000000000011 //00000000000000000000000001111111 //00000000000000000000000010000010 // char c = a + b; //10000010 - c //11111111111111111111111110000010 - 补码 有符号数补1，无符号数补0 //11111111111111111111111110000001 - 反码 =补码-1 //10000000000000000000000001111110 - 原码 //-126 printf(\u0026quot;%d\\n\u0026quot;, c);  整体提升\n整形提升是按照变量的数据类型的符号位来提升的  整形提升的例子\n// 实例1: //a,b要进行整形提升,但是c不需要整形提升 a,b整形提升之后,变成了负数 //c不发生整形提升,则表达式 c==0xb6000000 的结果是真 int main() { char a = 0xb6; //10110110 short b = 0xb600; int c = 0xb6000000; if (a == 0xb6) printf(\u0026quot;a\u0026quot;); if (b == 0xb600) printf(\u0026quot;b\u0026quot;); if (c == 0xb6000000) printf(\u0026quot;c\u0026quot;); //C return 0; }  //实例2 //c只要参与表达式运算,就会发生整形提升,表达式 +c ,就会发生提升,所以 sizeof(+c) 是4个字节. //表达式 -c 也会发生整形提升,所以 sizeof(-c) 是4个字节,但是 sizeof(c) ,就是1个字节 int main() { char c = 1; printf(\u0026quot;%u\\n\u0026quot;, sizeof(c)); //1 printf(\u0026quot;%u\\n\u0026quot;, sizeof(+c)); //4 printf(\u0026quot;%u\\n\u0026quot;, sizeof(!c)); //1 return 0; }  算术转换 如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为寻常算术转换.\nlong double double float unsigned long int long int unsigned int int  如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。 警告： 但是算术转换要合理，要不然会有一些潜在的问题。\nfloat f = 3.14; int num = f;//隐式转换，会有精度丢失  操作符的属性 复杂表达式的求值有三个影响的因素。 1. 操作符的优先级 2. 操作符的结合性 3. 是否控制求值顺序。\n两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。\n操作符优先级【越靠前，优先级越高】    操作符 描述 用法示例 结果类型 结合性 是否控制求值顺序     （） 聚组 （表达式） 与表达式同 N/A 否   （） 函数调用 rexp （ rexp ，\u0026hellip;, rexp ） rexp L-R 否   [ ] 下标引用 rexp [ rexp ] lexp L-R 否   . 访问结构成员 lexp .member_name lexp L-R 否   -\u0026gt; 访问结构指针成员 rexp -\u0026gt;member_name lexp L-R 否   ++ 后缀自增 lexp ++ rexp L-R 否   \u0026ndash; 后缀自减 lexp \u0026ndash; rexp L-R 否   ! 逻辑反 ! rexp rexp R-L 否   ~ 按位取反 ~ rexp rexp R-L 否   + 单目，表示正值 + rexp rexp R-L 否   - 单目，表示负值 - rexp rexp R-L 否   ++ 前缀自增 ++ lexp rexp R-L 否   \u0026ndash; 前缀自减 \u0026ndash; lexp rexp R-L 否   * 间接访问 * rexp lexp R-L 否   \u0026amp; 取地址 \u0026amp; lexp rexp R-L 否   sizeof 取其长度，以字节表示 sizeof rexp sizeof(类型) rexp R-L 否   (类型） 类型转换 (类型) rexp rexp R-L 否   * 乘法 rexp * rexp rexp L-R 否   / 除法 rexp / rexp rexp L-R 否   % 整数取余 rexp % rexp rexp L-R 否   + 加法 rexp + rexp rexp L-R 否   - 减法 rexp - rexp rexp L-R 否   \u0026lt;\u0026lt; 左移位 rexp \u0026lt;\u0026lt; rexp rexp L-R 否   \u0026gt;\u0026gt; 右移位 rexp \u0026gt;\u0026gt; rexp rexp L-R 否   \u0026gt; 大于 rexp \u0026gt; rexp rexp L-R 否   \u0026gt;= 大于等于 rexp \u0026gt;= rexp rexp L-R 否   \u0026lt; 小于 rexp \u0026lt; rexp rexp L-R 否   \u0026lt;= 小于等于 rexp \u0026lt;= rexp rexp L-R 否   == 等于 rexp == rexp rexp L-R 否   != 不等于 rexp != rexp rexp L-R 否   \u0026amp; 位与 rexp \u0026amp; rexp rexp L-R 否   ^ 位异或 rexp ^ rexp rexp L-R 否   || 位或 rexp || rexp rexp L-R 否   \u0026amp;\u0026amp; 逻辑与 rexp \u0026amp;\u0026amp; rexp rexp L-R 是   || 逻辑或 rexp || rexp rexp L-R 是   ?: 条件操作符 rexp ? rexp : rexp rexp N/A 是   = 赋值 lexp = rexp rexp R-L 否   += 以\u0026hellip;加 lexp += rexp rexp R-L 否   -= 以\u0026hellip;减 lexp -= rexp rexp R-L 否   *= 以\u0026hellip;乘 lexp *= rexp rexp R-L 否   /= 以\u0026hellip;除 lexp /= rexp rexp R-L 否   %= 以\u0026hellip;取模 lexp %= rexp rexp R-L 否   \u0026lt;\u0026lt;= 以\u0026hellip;左移 lexp \u0026lt;\u0026lt;= rexp rexp R-L 否   \u0026gt;\u0026gt;= 以\u0026hellip;右移 lexp \u0026gt;\u0026gt;= rexp rexp R-L 否   \u0026amp;= 以\u0026hellip;与 lexp \u0026amp;= rexp rexp R-L 否   ^= 以\u0026hellip;异或 lexp ^= rexp rexp R-L 否   |= 以\u0026hellip;或 lexp = rexp rexp R-L 否   ， 逗号 rexp ， rexp rexp L-R 是    问题表达式\n表达式的求值部分由操作符的优先级决定。\n 表达式1\na*b + c*d + e*f  代码1在计算的时候，由于比+的优先级高，只能保证，的计算是比+早，但是优先级并不能决定第三个*比第一个+早执行。\n计算机顺序可能是\na*b c*d a*b + c*d e*f a*b + c*d + e*f 或者： a*b c*d e*f a*b + c*d a*b + c*d + e*f  表达式2\nc + --c;  同上，操作符的优先级只能决定自减 \u0026ldquo;\u0026ndash;\u0026rdquo; 的运算在+的运算的前面，但是我们并没有办法得知，+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义的。\n 表达式3-非法表达式：表达式3在不同编译器中测试结果不同\nint main() { int i = 10; i = i-- - --i * ( i = -3 ) * i++ + ++i; printf(\u0026quot;i = %d\\n\u0026quot;, i); return 0; }  表达式4\n//answer = fun() - fun() * fun(); 中我们只能通过操作符的优先级得知：先算乘法，再算减法。 //函数的调用先后顺序无法通过操作符的优先级确定 int fun() { static int count = 1; return ++count; } int main() { int answer; answer = fun() - fun() * fun(); printf( \u0026quot;%d\\n\u0026quot;, answer);//输出多少？ return 0; }  表达式5\n//代码5 #include \u0026lt;stdio.h\u0026gt; int main() { int i = 1; int ret = (++i) + (++i) + (++i); printf(\u0026quot;%d\\n\u0026quot;, ret); printf(\u0026quot;%d\\n\u0026quot;, i); return 0; }  linux 环境gcc编译器 :10 4\nVS2013环境下都执行 :12 4\n第一个 + 在执行的时候，第三个++是否执行，这个是不确定的，因为依靠操作符的优先级和结合性是无法决定第一个 + 和第三个前置 ++ 的先后顺序。\n  总结 我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题的。\n练习 题目1 #include \u0026lt;stdio.h\u0026gt; int i;//全局变量-不初始化-默认是0。如果为局部变量为随机值 int main() { i--; //-1 //10000000000000000000000000000001 - 原码 //11111111111111111111111111111110 - 反码（符号位不变，其余取反） //11111111111111111111111111111111 - 补码 （反码+1） //放在内存里是补码，但高位就不再是符号位，一个超大数 //因为sizeof 返回的是无符号数，所以将i也转变成无符号数，i的最高位将不是符号位，而是有效位 if (i \u0026gt; sizeof(i))//sizeof()-计算变量/类型所占内存的大小 \u0026gt;=0 无符号数 { printf(\u0026quot;\u0026gt;\\n\u0026quot;);//\u0026gt; } else { printf(\u0026quot;\u0026lt;\\n\u0026quot;); } return 0; }  题目2 int a, b, c; a = 5; c = ++a;// c=6 a=6 b = ++c, c++, ++a, a++;//c=7 ,c=8 ,a=7,b=7,a=8 b += a++ + c;//a=8,c=8,b=7,b=7+8+8=23,a=9 printf(\u0026quot;a = %d b = %d c = %d\\n:\u0026quot;, a, b, c);//9 23 8  统计二进制中1的个数【补码的二进制有几个1】 写一个函数返回参数二进制中1的个数\n比如：15 00001111 4个1\n 主函数  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int a = 0; scanf(\u0026quot;%d\u0026quot;, \u0026amp;a); //写一个函数求a的二进制（补码）表示中有几个1 int count = count_bit_one(a); printf(\u0026quot;count = %d\\n\u0026quot;, count); //system(\u0026quot;pause\u0026quot;);//system库函数-执行系统命令-pause（暂停） return 0; }   count_bit_one 法一\n//13 //000000000000000000000000000001101 //-1 //100000000000000000000000000000001 原码 //111111111111111111111111111111110 反码 //111111111111111111111111111111111 补码 int count_bit_one(unsigned int n) // 无符号，解决负数 { int count = 0; while (n) { if (n % 2 == 1) { count++; } n = n / 2; } return count; }  count_bit_one 法二\n// -1 //111111111111111111111111111111111 补码 //000000000000000000000000000000001 int count_bit_one(int n) { int count = 0; int i = 0; for (i = 0; i \u0026lt; 32; i++) { if (((n \u0026gt;\u0026gt; i) \u0026amp; 1) == 1)// 每一位移到最低位，按位与1 { count++; } } return count; }  count_bit_one 法三（最佳，高效）\n//n = n\u0026amp;(n-1) //n //13 //1101 n count++ //1100 n-1 //1100 n count++ //1011 n-1 //1000 n count++ //0111 n-1 //0000 n 跳出 int count_bit_one(int n) { int count = 0; while (n) { n = n \u0026amp; (n - 1); count++; } return count; }   求二进制中不同位的个数 两个int (32位)的整数m和n的二进制表达中有多少个位（bit）不同？\n输入例子：1999 2299 输出例子：7  #include \u0026lt;stdio.h\u0026gt; int get_diff_bit(int m, int n) { int tmp = m^n;// ^ 按位异或同为0,相异为1 int count = 0; //return count_bit_one(tmp); while (tmp) { tmp = tmp\u0026amp;(tmp - 1); count++; } return count; } int main() { int m = 0; int n = 0; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;m, \u0026amp;n); int count = get_diff_bit(m, n); printf(\u0026quot;count = %d\\n\u0026quot;, count); return 0; }  打印二进制的奇数位和偶数位 获取一个整数二进制序列中所有的偶数位和奇数位，分别打印出二进制序列\n#include \u0026lt;stdio.h\u0026gt; //00000000000000000000000000001010 void print(int m) { int i = 0; printf(\u0026quot;奇数位：\\n\u0026quot;); for (i = 30; i \u0026gt;= 0; i -= 2) { printf(\u0026quot;%d \u0026quot;, (m \u0026gt;\u0026gt; i) \u0026amp; 1); } printf(\u0026quot;\\n\u0026quot;); printf(\u0026quot;偶数位：\\n\u0026quot;); for (i = 31; i \u0026gt;= 1; i -= 2) { printf(\u0026quot;%d \u0026quot;, (m \u0026gt;\u0026gt; i) \u0026amp; 1); } printf(\u0026quot;\\n\u0026quot;); } int main() { int m = 0; scanf(\u0026quot;%d\u0026quot;, \u0026amp;m); print(m); return 0; }  交换两个变量（不创建临时变量） 不允许创建临时变量，交换两个整数的内容\n 临时变量\nint a = 3; int b = 5; int tmp = 0;//临时变量 printf(\u0026quot;before: a=%d b=%d\\n\u0026quot;, a, b); tmp = a; a = b; b = tmp;  加减法-可能会溢出\nint a = 3; int b = 5; a = a + b; //8 b = a - b; //3 a = a - b; //5  异或的方法\nint a = 3; //011 int b = 5; //101 a = a^b; //110 b = a^b; //011 a = a^b; //101   ","date":1612306800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1612306800,"objectID":"80c2816a8decd4cf307d034a9557763d","permalink":"https://cytgenkidu.github.io/tutorial/c/5/","publishdate":"2021-02-03T00:00:00+01:00","relpermalink":"/tutorial/c/5/","section":"tutorial","summary":"操作符 分类  算术操作符 移位操作符 位操作符 赋值操作符 单目操作符 关系操作符 逻辑操作符 条件操作符 逗号表达式 下标引用、函数调用和结构成员  算术操作符 + - * / %   除了 % 操作符之外，其他的几个操作符可以作用于整数和浮点数。 对于 / 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。 % 操作符的两个操作数必须为整数。返回的是整除之后的余数。  double a = 5 % 2;//商2余1 printf(\u0026quot;a = %lf\\n\u0026quot;, a);//1.000000  移位操作符 ：移动是二进制位，只能作用于整形 \u0026lt;\u0026lt; 左移操作符 \u0026gt;\u0026gt; 右移操作符  左移操作符 移位规则： **左边抛弃、右边补0**  int a = 5; int b = a \u0026lt;\u0026lt; 1; //00000000000000000000000000000101 //00000000000000000000000000001010 printf(\u0026quot;%d\\n\u0026quot;, b); //10  右移操作符 移位规则：[右移1位有除2的效果] 首先右移运算分两种： 1.","tags":null,"title":"操作符详解","type":"docs"},{"authors":null,"categories":null,"content":" 指针是什么 在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向 （points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以 说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址 的内存单元。  int a = 10;//在内存中开辟一块空间 int *p = \u0026amp;a;//这里我们对变量a，取出它的地址，可以使用\u0026amp;操作符。 //将a的地址存放在p变量中，p就是一个之指针变量  总结：指针就是变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理）。指针就是地址.\n 一个小的单元到底是多大？（1个字节） 如何编址？\n经过仔细的计算和权衡我们发现一个字节给一个对应的地址是比较合适的。 对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的是产生一个电信号正电/负电（1或者0）\n那么32根地址线产生的地址就会是：\n00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 ... 11111111 11111111 11111111 11111111  这里就有2的32次方个地址。\n每个地址标识一个字节，那我们就可以给 （2^32Byte == 2^32/1024KB ==2^32/1024/1024MB==2^32/1024/1024/1024GB == 4GB） 4G的空闲进行编址。\n同样的方法，那64位机器，如果给64根地址线，那能编址多大空间，自己计算。\n  总结：\n 指针是用来存放地址的，地址是唯一标示一块地址空间的。 指针的大小在32位平台是4个字节，在64位平台是8个字节。  指针和指针类型 指针+-整数 int n = 10; char *pc = (char *)\u0026amp;n; int *pi = \u0026amp;n; printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;n); //000000000061FE0C printf(\u0026quot;%p\\n\u0026quot;, pc); //000000000061FE0C printf(\u0026quot;%p\\n\u0026quot;, pc + 1); //000000000061FE0D printf(\u0026quot;%p\\n\u0026quot;, pi); //000000000061FE0C printf(\u0026quot;%p\\n\u0026quot;, pi + 1); //000000000061FE10  总结：指针的类型决定了指针向前或者向后走一步有多大（距离单位是字节）(指针的步长)。\nint* p; p+1 --\u0026gt;4 char* p; p+1 --\u0026gt;1 double* p; p+1 --\u0026gt;8  指针的解引用 int a = 0x11223344; int* pa = \u0026amp;a; *pa = 0; /*char *pc = \u0026amp;a; *pc = 0;*/  总结： 指针的类型决定了，对指针解引用的时候有多大的权限（能操作几个字节）。\nint* p; *p 能够访问4个字节 char* p; *p 能够访问1个字节 double* p; *p 能够访问8个字节  示例:指针类型的意义 int arr[10] = { 0 }; int* p = arr;//数组名-首元素的地址 //char*p = arr; int i = 0; for (i = 0; i \u0026lt; 10; i++) { *(p + i) = 1; }  int* p = arr;\nchar*p = arr;\n野指针 概念： 野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）  野指针成因  指针未初始化\n//int a;//局部变量不初始化，默认是随机值 int *p;//局部的指针变量，就被初始化随机值 *p = 20;  指针越界访问\nint a[10] = { 0 }; int i = 0; int* p = a; for (i = 0; i \u0026lt;= 12; i++) { //*p = i; //p++; *p++ = i; }  指针指向的空间释放（详见动态内存开辟）\nint* test() { int a = 10; //局部变量 return \u0026amp;a; } int main() { int *p = test();//test指向的空间被释放了 *p = 20; //访问就是非法的 return 0; }   如何避免野指针  指针初始化\nint b = 0;// int a = 10; int*pa = \u0026amp;a;//初始化 int* p = NULL;//NULL- 用来初始化指针的，给指针赋值  小心指针越界\n 指针指向空间释放即使置NULL\nint a = 10; int *pa = \u0026amp;a; *pa = 20; // pa = NULL;  指针使用之前检查有效性\nif (pa != NULL) { }   指针运算 指针+- 整数 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int i = 0; int sz = sizeof(arr) / sizeof(arr[0]); int* p = arr; for (i = 0; i \u0026lt; sz; i++) { printf(\u0026quot;%d \u0026quot;, *p); // 1 2 3 4 5 6 7 8 9 10 p++;//p+=1 } printf(\u0026quot;\\n\u0026quot;); int* p1 = \u0026amp;arr[9]; for (i = 0; i \u0026lt; 5; i++) { printf(\u0026quot;%d \u0026quot;, *p1); //10 8 6 4 2 p1-=2; }  指针-指针 char ch[5] = {0}; int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 15 }; printf(\u0026quot;%d\\n\u0026quot;, \u0026amp;arr[9] - \u0026amp;arr[0]);//9,指针之间元素的个数 printf(\u0026quot;%d\\n\u0026quot;, \u0026amp;arr[0] - \u0026amp;arr[9]);//|-9|,指针之间元素的个数 //printf(\u0026quot;%d\\n\u0026quot;, \u0026amp;arr[9] - \u0026amp;ch[0]);//err  计算字符串长度[1.计数器的方式1; 2.递归的方式2 3.指针的方式3]\nint my_strlen(char* str) { char* start = str; char* end = str; while (*end != '\\0') { end++; } return end - start;// }  指针的关系运算 #define N_VALUES 5 float values[N_VALUES]; float *vp; //指针+-整数；指针的关系运算 for (vp = \u0026amp;values[0]; vp \u0026lt; \u0026amp;values[N_VALUES]) { *vp++ = 0; } //下面代码是应该避免这样写，因为标准并不保证它可行。 for(vp = \u0026amp;values[N_VALUES-1]; vp \u0026gt;= \u0026amp;values[0];vp--) { *vp = 0; }  标准规定：\n允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。\n指针和数组 int arr[10] = { 0 }; printf(\u0026quot;%p\\n\u0026quot;, arr);//地址-首元素的地址 printf(\u0026quot;%p\\n\u0026quot;, arr+1); printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;arr[0]);//首元素地址 printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;arr[0]+1); printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;arr);//不是首元素地址，是整个数组地址 printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;arr + 1); //1. \u0026amp;arr- \u0026amp;数组名- 数组名不是首元素的地址-数组名表示整个数组 - \u0026amp;数组名 取出的是整个数组的地址 //2. sizeof(arr) - sizeof(数组名) - 数组名表示的整个数组- sizeof(数组名)计算的是整个数组的大小  结论：数组名表示的是数组首元素的地址。\nint arr[10] = { 0 }; int* p = arr; int i = 0; for (i = 0; i \u0026lt; 10; i++) { *(p + i) = i; } for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;%d \u0026quot;, *(p + i)); //0 1 2 3 4 5 6 7 8 9 } printf(\u0026quot;\\n\\n\u0026quot;); for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;\u0026amp;arr[%d] = %p \u0026lt;====\u0026gt; p+%d = %p\\n\u0026quot;, i, \u0026amp;arr[i], i, p + i); }  二级指针 int a = 10; int * pa = \u0026amp;a;// *表示pa是指针，int表示pa指向的对象类型是int int* * ppa = \u0026amp;pa;//ppa就是二级指针,存放一级指针变量的地址 //int* 表示ppa指向的对象类型是int* ，第二个*表示ppa是个指针 **ppa = 20; printf(\u0026quot;%d\\n\u0026quot;, **ppa);//20 printf(\u0026quot;%d\\n\u0026quot;, a);//20 //int** * pppa = \u0026amp;ppa;// 三级指针  指针数组 指针数组是指针还是数组？\n答案：是数组，是存放指针的数组。\nint a = 10; int b = 20; int c = 30; //int* pa = \u0026amp;a; //int* pb = \u0026amp;b; //int* pc = \u0026amp;c; //整形数组 - 存放整形 //字符数组 - 存放字符 //指针数组 - 存放指针 //int arr[10]; int* arr2[3] = {\u0026amp;a, \u0026amp;b, \u0026amp;c};//整形指针数组 int i = 0; for (i = 0; i \u0026lt; 3; i++) { printf(\u0026quot;%d \u0026quot;, *(arr2[i])); //10 20 30 }  练习 题目1 int arr[] = { 1, 2, 3, 4, 5 }; short *p = (short*)arr; int i = 0; for (i = 0; i\u0026lt;4; i++) { *(p + i) = 0; } for (i = 0; i\u0026lt;5; i++) { printf(\u0026quot;%d \u0026quot;, arr[i]);//0 0 3 4 5 }  题目2 int a = 0x11223344; char *pc = (char*)\u0026amp;a; *pc = 0; printf(\u0026quot;%x\\n\u0026quot;, a);  使用指针打印数组内容 #include \u0026lt;stdio.h\u0026gt; void print(int *p, int sz) { int i = 0; for (i = 0; i \u0026lt; sz; i++) { printf(\u0026quot;%d \u0026quot;, *(p + i)); } } int main() { int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int sz = sizeof(arr) / sizeof(arr[0]); print(arr, sz); return 0; }  注：\n 指针-指针得到指针之间元素的个数，非字节数  写一个函数逆序字符串的内容 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; void reverse(char *str) { assert(str); //判断指针的有效性 int len = strlen(str); char *left = str; char *right = str + len - 1; while (left \u0026lt; right) { char tmp = *left; *left = *right; *right = tmp; left++; right--; } } int main() { char arr[256] = {0}; //scanf(\u0026quot;%s\u0026quot;, arr);//abcdef ---\u0026gt; fedcba scanf读取遇到空格就会结束 gets(arr); //读取一行 //逆序函数 reverse(arr); printf(\u0026quot;逆序后的字符串：%s\\n\u0026quot;, arr); // return 0; }  计算求和 Sn=a+aa+aaa+aaaa+aaaaa的前5项之和，其中a是一个数字。 int a = 0; int n = 0; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;n);//2 5 int sum = 0; int i = 0; int ret = 0; //2 22 222 2222 22222 // for (i = 0; i \u0026lt; n; i++) { ret = ret * 10 + a; sum += ret; } printf(\u0026quot;%d\\n\u0026quot;, sum);  判断i是否为水仙花数（自幂数） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main() { int i = 0; for (i = 0; i \u0026lt;= 100000; i++) { //判断i是否为水仙花数（自幂数） //1. 计算i的位数 - n位数 int n = 1; int tmp = i; int sum = 0; while (tmp /= 10) { n++; } //2. 计算i的每一位的n次方之和 sum tmp = i; while (tmp) { sum += pow(tmp % 10, n); tmp /= 10; } //3. 比较i == sum if (i == sum) { printf(\u0026quot;%d \u0026quot;, i); } } return 0; }  打印菱形 * *** ***** ******* ********* *********** ************* *********** ********* ******* ***** *** *  课上代码\nint line = 0; scanf(\u0026quot;%d\u0026quot;, \u0026amp;line);//7 //打印上半部分 int i = 0; for (i = 0; i \u0026lt; line; i++) { //打印空格 int j = 0; for (j = 0; j \u0026lt; line-1-i; j++) { printf(\u0026quot; \u0026quot;); } //打印* for (j = 0; j \u0026lt;2*i+1; j++) { printf(\u0026quot;*\u0026quot;); } printf(\u0026quot;\\n\u0026quot;); } //打印下半部分 for (i = 0; i \u0026lt; line - 1; i++) { int j = 0; //打印空格 for (j = 0; j \u0026lt;=i; j++) { printf(\u0026quot; \u0026quot;); } //打印* for (j = 0; j \u0026lt;2*(line-1-i)-1; j++) { printf(\u0026quot;*\u0026quot;); } printf(\u0026quot;\\n\u0026quot;); }  喝汽水问题 喝汽水，一瓶汽水1元，2个空瓶可以换一瓶汽水，给20元,可以多少汽水？（编程实现）\ntotal=2*m-1\nint m = 0;//money int n = 0;//总数量 int k = 0;//空瓶 scanf(\u0026quot;%d\u0026quot;, \u0026amp;m); n = m; k = m; while (k \u0026gt;1) { n += k / 2; k = k / 2 + k % 2; } printf(\u0026quot;%d\u0026quot;, n);  ","date":1613343600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1613343600,"objectID":"4a1a3ceeabdd6d2fbf07a376fab8afd5","permalink":"https://cytgenkidu.github.io/tutorial/c/6/","publishdate":"2021-02-15T00:00:00+01:00","relpermalink":"/tutorial/c/6/","section":"tutorial","summary":"指针是什么 在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向 （points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以 说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址 的内存单元。  int a = 10;//在内存中开辟一块空间 int *p = \u0026amp;a;//这里我们对变量a，取出它的地址，可以使用\u0026amp;操作符。 //将a的地址存放在p变量中，p就是一个之指针变量  总结：指针就是变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理）。指针就是地址.\n 一个小的单元到底是多大？（1个字节） 如何编址？\n经过仔细的计算和权衡我们发现一个字节给一个对应的地址是比较合适的。 对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的是产生一个电信号正电/负电（1或者0）\n那么32根地址线产生的地址就会是：\n00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 ... 11111111 11111111 11111111 11111111  这里就有2的32次方个地址。\n每个地址标识一个字节，那我们就可以给 （2^32Byte == 2^32/1024KB ==2^32/1024/1024MB==2^32/1024/1024/1024GB == 4GB） 4G的空闲进行编址。\n同样的方法，那64位机器，如果给64根地址线，那能编址多大空间，自己计算。\n  总结：\n 指针是用来存放地址的，地址是唯一标示一块地址空间的。 指针的大小在32位平台是4个字节，在64位平台是8个字节。  指针和指针类型 指针+-整数 int n = 10; char *pc = (char *)\u0026amp;n; int *pi = \u0026amp;n; printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;n); //000000000061FE0C printf(\u0026quot;%p\\n\u0026quot;, pc); //000000000061FE0C printf(\u0026quot;%p\\n\u0026quot;, pc + 1); //000000000061FE0D printf(\u0026quot;%p\\n\u0026quot;, pi); //000000000061FE0C printf(\u0026quot;%p\\n\u0026quot;, pi + 1); //000000000061FE10  总结：指针的类型决定了指针向前或者向后走一步有多大（距离单位是字节）(指针的步长)。","tags":null,"title":"指针","type":"docs"},{"authors":null,"categories":null,"content":" 结构体类型的声明 结构的基础知识 结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。  结构的声明 struct tag { member-list; }variable-list;  例如描述一个学生 :名字,年龄,电话,性别\n//定义结构体类型 //struct 结构体关键字 Stu - 结构体标签 struct Stu - 结构体类型 struct Stu { //成员变量 char name[20]; short age; char tele[12]; char sex[5]; }s1, s2, s3;//s1,s2,s3 是三个全局的结构体变量，//分号不能丢 //创建结构体变量 struct Stu s2 = {\u0026quot;旺财\u0026quot;, 30, \u0026quot;15596668862\u0026quot;, \u0026quot;保密\u0026quot;};  //typedef给结构体类型struct Stu重新命名为Stu typedef struct Stu { //成员变量 char name[20]; short age; char tele[12]; char sex[5]; }Stu;//分号不能丢 //创建结构体变量 Stu s1 = {\u0026quot;张三\u0026quot;, 20, \u0026quot;15249287076\u0026quot;, \u0026quot;男\u0026quot;};//局部变量  结构成员的类型 结构的成员可以是标量、数组、指针，甚至是其他结构体。\n结构体变量的定义和初始化 有了结构体类型，那如何定义变量，其实很简单。\nstruct Point { int x; int y; }p1; //声明类型的同时定义变量p1 struct Point p2; //定义结构体变量p2 //初始化：定义变量的同时赋初值。 struct Point p3 = {x, y}; struct Stu //类型声明 { char name[15];//名字 int age; //年龄 }; struct Stu s = {\u0026quot;zhangsan\u0026quot;, 20};//初始化 struct Node { int data; struct Point p; struct Node* next; }n1 = {10, {4,5}, NULL}; //结构体嵌套初始化 struct Node n2 = {20, {5, 6}, NULL};//结构体嵌套初始化  结构体成员的访问 结构体传参  结构体变量访问成员 结构变量的成员是通过点操作符（.）访问的。点操作符接受两个操作数。\n 结构体指针访问指向变量的成员 有时候我们得到的不是一个结构体变量，而是指向一个结构体的指针\n  typedef struct Stu { //成员变量 char name[20]; short age; char tele[12]; char sex[5]; }Stu; void Print1(Stu tmp) { printf(\u0026quot;name: %s\\n\u0026quot;, tmp.name); printf(\u0026quot;age: %d\\n\u0026quot;, tmp.age); printf(\u0026quot;tele: %s\\n\u0026quot;, tmp.tele); printf(\u0026quot;sex: %s\\n\u0026quot;, tmp.sex); } void Print2(Stu* ps) { printf(\u0026quot;name: %s\\n\u0026quot;, ps-\u0026gt;name); printf(\u0026quot;age : %d\\n\u0026quot;, ps-\u0026gt;age); printf(\u0026quot;tele: %s\\n\u0026quot;, ps-\u0026gt;tele); printf(\u0026quot;sex : %s\\n\u0026quot;, ps-\u0026gt;sex); } int main() { Stu s = { \u0026quot;李四\u0026quot;, 40, \u0026quot;15598886688\u0026quot;, \u0026quot;男\u0026quot; }; //打印结构体数据 Print1(s); //传结构体 Print2(\u0026amp;s); //传地址 return 0; }  上面的 print1 和 print2 函数哪个好些？\n答案是：首选print2函数。 原因：\n函数传参的时候，参数是需要压栈的。 如果传递一个结构体对象的时候，结构体过大，参数压栈 的系统开销比较大，所以会导致性能的下降。  结论： 结构体传参的时候，要传结构体的地址。\n压栈\nint Add(int x, int y) { int z = 0; z = x + y; return z; } int main() { int a = 10; int b = 20; int ret = 0; ret = Add(a, b); return 0; }  参考：函数栈帧的创建和销毁\n","date":1613343600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1613343600,"objectID":"17f79f616737e405eae3e51d13813179","permalink":"https://cytgenkidu.github.io/tutorial/c/7/","publishdate":"2021-02-15T00:00:00+01:00","relpermalink":"/tutorial/c/7/","section":"tutorial","summary":"结构体类型的声明 结构的基础知识 结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。  结构的声明 struct tag { member-list; }variable-list;  例如描述一个学生 :名字,年龄,电话,性别\n//定义结构体类型 //struct 结构体关键字 Stu - 结构体标签 struct Stu - 结构体类型 struct Stu { //成员变量 char name[20]; short age; char tele[12]; char sex[5]; }s1, s2, s3;//s1,s2,s3 是三个全局的结构体变量，//分号不能丢 //创建结构体变量 struct Stu s2 = {\u0026quot;旺财\u0026quot;, 30, \u0026quot;15596668862\u0026quot;, \u0026quot;保密\u0026quot;};  //typedef给结构体类型struct Stu重新命名为Stu typedef struct Stu { //成员变量 char name[20]; short age; char tele[12]; char sex[5]; }Stu;//分号不能丢 //创建结构体变量 Stu s1 = {\u0026quot;张三\u0026quot;, 20, \u0026quot;15249287076\u0026quot;, \u0026quot;男\u0026quot;};//局部变量  结构成员的类型 结构的成员可以是标量、数组、指针，甚至是其他结构体。","tags":null,"title":"结构体","type":"docs"},{"authors":null,"categories":null,"content":" Debug和Release的介绍 Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。  Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。  int main() { int i = 0; int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; printf(\u0026quot;%p\\n\u0026quot;, arr); printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;i); //VC6.0 环境下 \u0026lt;=10 就死循环了 //gcc 编译器 \u0026lt;=11 就死循环了 //VS2013 \u0026lt;=12 死循环 for (i = 0; i \u0026lt;= 12; i++) { printf(\u0026quot;hehe\\n\u0026quot;); arr[i] = 0; } system(\u0026quot;pause\u0026quot;); return 0; }  死循环的原因：\nmain函数创建了i和arr是局部变量，存储在栈区，i在高地址创建，arr在i的低地址创建,所以在使用的过程中产生越界，可能arr会遇到i\n 栈区的默认使用 先使用高地址处的空间，在使用低地址处的空间 数组随着下标的增长，地址是由低到高的变化  常用快捷键 window F5 启动调试，经常用来直接调到下一个断点处。\nF9 创建断点和取消断点 断点的重要作用，可以在程序的任意位置设置断点。这样就可以使得程序在想要的位置随意停止执行，继而一步步执行下去。\nF10 逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句。\nF11 逐语句，就是每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑进入函数内部（这是最常用的）。\nCTRL + F5 开始执行不调试，如果你想让程序直接运行起来而不调试就可以直接使用。\n如何写出好（易于调试）的代码 优秀的代码：  代码运行正常 bug很少 效率高 可读性高 可维护性高 注释清晰 文档齐全  常见的coding技巧：  使用assert 尽量使用const 养成良好的编码风格 添加必要的注释 避免编码的陷阱  模拟实现库函数：strcpy //void my_strcpy(char* dest, char* src) //{ // while (*src != '\\0') // { // *dest = *src; // src++; // dest++; // } // *dest = *src;//'\\0' //} //void my_strcpy(char* dest, char* src) //{ // if (dest != NULL \u0026amp;\u0026amp; src != NULL) // { // while (*dest++ = *src++) // { // ; // } // } //} #include \u0026lt;assert.h\u0026gt; char* my_strcpy(char* dest, const char* src) { char* ret = dest; assert(dest != NULL);//断言 assert(src != NULL);//断言 //把src指向的字符串拷贝到dest指向的空间，包含'\\0'字符 while (*dest++ = *src++) { ; } return ret; } int main() { //strcpy //字符串拷贝 char arr1[] = \u0026quot;#########\u0026quot;; char arr2[] = \u0026quot;bit\u0026quot;; printf(\u0026quot;%s\\n\u0026quot;, my_strcpy(arr1, arr2)); return 0; }  注意：\n 分析参数的设计（命名，类型），返回值类型的设计 这里讲解野指针，空指针的危害。 assert的使用，这里介绍assert的作用 参数部分 const 的使用，这里讲解const修饰指针的作用 注释的添加  const的作用 const int num = 10; int n = 100; int * p = \u0026amp;num; // const int * p = \u0026amp;num; // int * const p = \u0026amp;num; // const 放在指针变量的*左边时，修饰的是*p,也就是说：不能通过p来改变*p（num）的值 // const 放在指针变量的*右边是，修饰的是指针变量p本身，p不能被改变了 *p = 20; p = \u0026amp;n; printf(\u0026quot;%d\\n\u0026quot;, num);  结论：\nconst修饰指针变量的时候：\n const如果放在*的左边，修饰的是指针指向的内容，保证指针指向的内容不能通过指针来改变。但是指针变量本身的内容可变。 const如果放在*的右边，修饰的是指针变量本身，保证了指针变量的内容不能修改，但是指针指向的内容，可以通过指针改变.  模拟实现一个strlen函数 参考代码：\nint my_strlen(const char *str) { int count = 0; assert(str != NULL);//保证指针的有效性 while (*str != '\\0') { count++; str++; } return count; } int main() { char arr[] = \u0026quot;abcdef\u0026quot;; int len = my_strlen(arr); printf(\u0026quot;%d\\n\u0026quot;, len); return 0; }  编程常见的错误 常见的错误分类： 编译型错误\n直接看错误提示信息（双击），解决问题。或者凭借经验就可以搞定。相对来说简单。\n链接型错误\n看错误提示信息，主要在代码中找到错误信息中的标识符，然后定位问题所在。一般是标识符名不存在或者拼写错误。\n运行时错误\n借助调试，逐步定位问题。最难搞。\n练习 调整奇数偶数顺序 调整数组使级数全部都位于偶数前面\n输入一个整数数组，实现函数。来调整数组中数字的顺序使的数组中所有的奇数位于数组的前半部分，所有偶数位于数组的后半部分。\n//1.从左边开始找一个偶数 //2.从右边开始找一个奇数 //3.把他们交换 void move(int arr[], int sz) { int left = 0; int right = sz - 1; while (left \u0026lt; right) //若数组全为奇数，不加此句会导致越界访问 { //从左边找偶数 while ((left \u0026lt; right) \u0026amp;\u0026amp; (arr[left] % 2 == 1)) { left++; } //从右边找奇数 while ((left \u0026lt; right) \u0026amp;\u0026amp; (arr[right] % 2 == 0)) { right--; } if (left \u0026lt; right) { int tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; } } } void print(int arr[],int sz) { for (int i = 0; i \u0026lt; sz; i++) { printf(\u0026quot;%d \u0026quot;, arr[i]); } } int main() { //1 3 5 7 9 9 7 5 3 1 int arr[] = { 1,3,5,7,9 }; int sz = sizeof(arr) / sizeof(arr[0]); move(arr, sz); print(arr, sz); return 0; }  ","date":1613343600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1613343600,"objectID":"7741b5fe9c4f0d3a43d45475652eb463","permalink":"https://cytgenkidu.github.io/tutorial/c/8/","publishdate":"2021-02-15T00:00:00+01:00","relpermalink":"/tutorial/c/8/","section":"tutorial","summary":"Debug和Release的介绍 Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。  Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。  int main() { int i = 0; int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; printf(\u0026quot;%p\\n\u0026quot;, arr); printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;i); //VC6.0 环境下 \u0026lt;=10 就死循环了 //gcc 编译器 \u0026lt;=11 就死循环了 //VS2013 \u0026lt;=12 死循环 for (i = 0; i \u0026lt;= 12; i++) { printf(\u0026quot;hehe\\n\u0026quot;); arr[i] = 0; } system(\u0026quot;pause\u0026quot;); return 0; }  死循环的原因：\nmain函数创建了i和arr是局部变量，存储在栈区，i在高地址创建，arr在i的低地址创建,所以在使用的过程中产生越界，可能arr会遇到i\n 栈区的默认使用 先使用高地址处的空间，在使用低地址处的空间 数组随着下标的增长，地址是由低到高的变化  常用快捷键 window F5 启动调试，经常用来直接调到下一个断点处。","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" 数据类型  内置类型\nchar //字符数据类型 short //短整型 int //整形 long //长整型 long long //更长的整形 float //单精度浮点数 double //双精度浮点数  自定义类型(构造类型)\n  类型的意义：\n 使用这个类型开辟内存空间的大小（大小决定了使用范围）。 如何看待内存空间的视角。  类型的基本归类 整形家族 char unsigned char //无符号数 signed char short unsigned short [int] signed short [int] //[int] 可以省略 int unsigned int signed int long unsigned long [int] signed long [int]  浮点数家族 float double  构造类型 \u0026gt; 数组类型 \u0026gt; 结构体类型 struct \u0026gt; 枚举类型 enum \u0026gt; 联合类型 union  指针类型 int *pi; char *pc; float* pf; void* pv;  空类型 void 表示空类型（无类型） 通常应用于函数的返回类型、函数的参数、指针类型。  整形在内存中的存储 limit.h 原码、反码、补码 计算机中的有符号数有三种表示方法，即原码、反码和补码。[无符号：原码、反码、补码 相同] 三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位三种表示方法各不相同。  原码\n直接将二进制按照正负数的形式翻译成二进制就可以。\n反码\n将原码的符号位不变，其他位依次按位取反就可以得到了。\n补码\n反码+1就得到补码。\n正数的原、反、补码都相同。\n对于整形来说：数据存放内存中其实存放的是补码。\n1 - 1; //1 + (-1) //00000000000000000000000000000001 //11111111111111111111111111111111 //00000000000000000000000000000000 //10000000000000000000000000000001 - -1原码 //11111111111111111111111111111110 -1补码 //11111111111111111111111111111111 -反码 //00000000000000000000000000000001 - 1 原码 补码 反码 //10000000000000000000000000000001 //10000000000000000000000000000010  为什么呢？\n在计算机系统中，数值一律用补码来表示和存储。 原因在于，使用补码，可以将符号位和数值域统一处理； 同时，加法和减法也可以统一处理（CPU只有加法器） 此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。\n我们可以看到对于a和b分别存储的是补码。但是我们发现顺序有点不对劲。 这是又为什么？\n大小端介绍 什么大端小端\n大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中； 小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。  为什么有大端和小端：\n这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。 但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）， 另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节， 那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。 例如一个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ， 那么 0x11 为高字节， 0x22 为低字节。 对于大端模式，就将 0x11 放在低地址中，即 0x0010 中， 0x22 放在高地址中，即 0x0011 中。 小端模式，刚好相反。我们常用的 X86 结构是小端模式，而 KEIL C51 则为大端模式。 很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。  百度2015年系统工程师笔试题：\n请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。（10分）\n#include \u0026lt;stdio.h\u0026gt; int check_sys() { int a = 1; return *(char*)\u0026amp;a; } //指针类型的意义： //1. 指针类型决定了指针解引用操作符能访问几个字节：char*p; *p 访问了1个字节，int*p;*p 访问4个字节 //2. 指针类型决定了指针+1，-1，加的或者减的是几个字节；char*p; p+1,跳过一个字符，int*p; p+1,跳过一个整形-4个字节 int main() { printf(\u0026quot;当前机器的字节序:%s\u0026quot;, check_sys() == 1 ? \u0026quot;小端存储\u0026quot; : \u0026quot;大端存储\u0026quot;); return 0; }  练习 下面程序输出什么？\n char a = -1; /*10000000000000000000000000000001 11111111111111111111111111111110 11111111111111111111111111111111 11111111111111111111111111111111*/ signed char b = -1; //11111111 unsigned char c = -1; /*00000000000000000000000011111111 255*/ printf(\u0026quot;a=%d,b=%d,c=%d\u0026quot;, a, b, c);//-1 -1 255  char a = -128; //10000000000000000000000010000000 //11111111111111111111111101111111 //11111111111111111111111110000000-补码 //10000000 //11111111111111111111111110000000-补码 // printf(\u0026quot;%u\\n\u0026quot;, a);//4294967168 //%d - 打印十进制的有符号数字 //%u - 打印十进制的无符号数字  char a = 128;//127+1，char放不下128，127+1=-128 //10000000000000000000000010000000 - -128 //11111111111111111111111101111111 //11111111111111111111111110000000-补码 //10000000 //11111111111111111111111110000000-补码 printf(\u0026quot;%u\\n\u0026quot;, a);//4294967168 //%d - 打印十进制的有符号数字 //%u - 打印十进制的无符号数字   int i= -20; //1000000 00000000 00000000 00010100 //1111111 11111111 11111111 11101011 //1111111 11111111 11111111 11101100 - 补码 unsigned int j = 10; //0000000 00000000 00000000 00001010 - 补码 //1111111 11111111 11111111 11101100 - 补码 //0000000 00000000 00000000 00001010 - 补码 //1111111 11111111 11111111 11110110 - 结果 补码 //1111111 11111111 11111111 11110101 - 反码 //1000000 00000000 00000000 00001010 - 原码 printf(\u0026quot;%d\\n\u0026quot;, i+j);//-10 //按照补码的形式进行运算，最后格式化成为有符号整数  #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { unsigned int i; for (i = 9; i \u0026gt;= 0; i--) { printf(\u0026quot;%u\\n\u0026quot;, i); //9 8 7 6 5 4 3 2 1 0 4294967295 4294967294 4294967293…… //死循环 Sleep(100); } return 0; }  char a[1000]; int i; for (i = 0; i\u0026lt;1000; i++) { a[i] = -1 - i;//char的范围-128--\u0026gt;127 //-1 -2 -3 …… -127 -126 -125 …… -1 0 } printf(\u0026quot;%d\u0026quot;, strlen(a));//255  #include \u0026lt;stdio.h\u0026gt; unsigned char i = 0;//0-255 int main() { for (i = 0; i \u0026lt;= 255; i++) { printf(\u0026quot;hello world\\n\u0026quot;);//死循环 } return 0; }   浮点型在内存中的存储 float.h 常见的浮点数： 3.14159 1E10 浮点数家族包括： float、double、long double 类型。 浮点数表示的范围：float.h中定义  存入 根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：\n(-1)^S * M * 2^E (-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。 M表示有效数字，大于等于1，小于2。 2^E表示指数位。  //9.0 //1001.0 //(-1)^0 * 1.001 * 2^3 //(-1)^s * M * 2^E //s - 0 //M - 1.001 //E - 3 // //0.5 //0.1 二进制表示形式 //(-1)^0 * 1.0 * 2^-1 //S = 0 //M = 1.0 //E = -1 //E + 127【中间值】 = 126  IEEE 754规定： 对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。\n对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。\nfloat f = 5.5; //5.5 //101.1 //(-1)^0 * 1.011*2^2 //(-1)^s * M *2^E //S = 0 //M = 1.011 //E = 2 //0 10000001 01100000000000000000000 //0100 0000 1011 0000 0000 0000 0000 0000 //0x40b00000 //(-1)^0 * 1.011 * 2^2  IEEE 754对有效数字M和指数E，还有一些特别规定。 前面说过， 1≤M\u0026lt;2 ，也就是说，M可以写成 1.xxxxxx 的形 式，其中xxxxxx表示小数部分。\nIEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。 比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。 以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。\n至于指数E，情况就比较复杂。\n首先，E为一个无符号整数（unsigned int） 这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的 取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真 实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E 是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。\n取出 然后，指数E从内存中取出还可以再分成三种情况：\nE不全为0或不全为1\n这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前 加上第一位的1。 比如： 0.5（1/2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位， 则为1.0*2^(-1)，其阶码为-1+127=126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到23位 00000000000000000000000，则其二进制表示形式为:\n0 01111110 00000000000000000000000\nE全为0\n这时，浮点数的指数E等于1-127（或者1-1023）即为真实值， 有效数字M不再加上第一位的1，而是还原为 0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。\n//0 00000000 01100000000000000000000 //+/- 0.011 * 2^-126 //正负无穷小  E全为1\n这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；\n//0 11111111 01100000000000000000000 //E+127 = 255 //E = 128 //1.xxx * 2^128 //表示的正负无穷大的数字  例子 int main() { int n = 9; //0 00000000 00000000000000000001001-补码 // float *pFloat = (float *)\u0026amp;n; printf(\u0026quot;n的值为：%d\\n\u0026quot;, n);//9 printf(\u0026quot;*pFloat的值为：%f\\n\u0026quot;, *pFloat);//0.000000 //(-1)^0 * 0.00000000000000000001001 * 2^-126 // *pFloat = 9.0; //1001.0 //1.001*2^3 //(-1)^0 *1.001 * 2^3 //01000001000100000000000000000000 printf(\u0026quot;num的值为：%d\\n\u0026quot;, n); printf(\u0026quot;*pFloat的值为：%f\\n\u0026quot;, *pFloat);//9.0 return 0; }  为什么 0x00000009 还原成浮点数，就成了 0.000000 ？\n首先，将 0x00000009 拆分，得到第一位符号位s=0，后面8位的指数 E=00000000 ， 最后23位的有效数字M=000 0000 0000 0000 0000 1001。\n由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成： V=(-1)^0 × 0.00000000000000000001001×2^(-126)=1.001×2^(-146) 显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是0.000000。\n请问浮点数9.0，如何用二进制表示？还原成十进制又是多少？\n首先，浮点数9.0等于二进制的1001.0，即1.001×2^3。\n那么，第一位的符号位s=0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3+127=130， 即10000010。 所以，写成二进制形式，应该是s+E+M，即这个32位的二进制数，还原成十进制，正是 1091567616 。\n练习 1 unsigned char a = 200; unsigned char b = 100; unsigned char c = 0; c = a + b; //整形提升 //00000000000000000000000011001000 - a //00000000000000000000000001100100 - b //00000000000000000000000100101100 //00101100 - c //00000000000000000000000000101100 // //00000000000000000000000011001000 //11001000-a //00000000000000000000000001100100 //01100100-b printf(\u0026quot;%d %d\u0026quot;, a + b, c); //300 44  练习2 unsigned int a = 0x1234; unsigned char b = *(unsigned char *)\u0026amp;a; printf(\u0026quot;%d\\n\u0026quot;, b);//0x00  练习3 //-128 --\u0026gt; 127 char a[1000] = { 0 }; // int i = 0; for (i = 0; i\u0026lt;1000; i++) { a[i] = -1 - i; } //-1 -2 ... -128 127 126 125 ... 3 2 1 0 -1 -2 ... //0结束 printf(\u0026quot;%d\\n\u0026quot;, strlen(a));//255 // #include \u0026lt;string.h\u0026gt;  打印杨辉三角 // 1 // 1 1 // 1 2 1 // 1 3 3 1 // 1 4 6 4 1 // ................ int main() { int arr[10][10] = { 0 }; int i = 0; int j = 0; for (i = 0; i \u0026lt; 10; i++) { for (j = 0; j \u0026lt; 10; j++) { if (j == 0) { arr[i][j] = 1; } if (i == j) { arr[i][j] = 1; } if (i \u0026gt;= 2 \u0026amp;\u0026amp; j \u0026gt;= 1) { arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1]; } } } //打印 for (i = 0; i \u0026lt; 10; i++) { for (j = 0; j \u0026lt;=i; j++) { printf(\u0026quot;%d \u0026quot;, arr[i][j]); } printf(\u0026quot;\\n\u0026quot;); } return 0; }  猜凶手 日本某地发生了一件谋杀案，警察通过排查确定杀人凶手必为4个嫌疑犯的一个。 以下为4个嫌疑犯的供词 : A说：不是我。//0 B说：是C。 //0 C说：是D。 //0 D说：C在胡说 //1 已知3个人说了真话，1个人说的是假话。 现在请根据这些信息，写一个程序来确定到底谁是凶手  int killer = 0; for (killer = 'a'; killer \u0026lt;= 'd'; killer++) { if ((killer != 'a') + (killer == 'c') + (killer == 'd') + (killer != 'd') == 3) { printf(\u0026quot;killer = %c\\n\u0026quot;, killer); } }  猜名次 5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果： A说：B第二，我第三。 B说：我第二，E第四。 C说：我第一，D第二。 E说：我第四，A第一； 比赛结束后，每个选手都谁对了一半，请编程确定比赛名次。\nint main() { int a = 0; int b = 0; int c = 0; int d = 0; int e = 0; for (a = 1; a \u0026lt;= 5; a++) { for (b = 1; b \u0026lt;= 5; b++) { for (c = 1; c \u0026lt;= 5; c++) { for (d = 1; d \u0026lt;= 5; d++) { for (e = 1; e \u0026lt;= 5; e++) { if (((b == 2) + (a == 3) == 1) \u0026amp;\u0026amp; ((b == 2) + (e == 4) == 1) \u0026amp;\u0026amp; ((c == 1) + (d == 2) == 1) \u0026amp;\u0026amp; ((c == 5) + (d == 3) == 1) \u0026amp;\u0026amp; ((e == 4) + (a == 1) == 1)) { if (a * b * c * d * e == 120) printf(\u0026quot;a=%d b=%d c=%d d=%d e=%d\\n\u0026quot;, a, b, c, d, e); } } } } } } return 0; }  本页完\n","date":1613343600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1613343600,"objectID":"682de515d2c2147a027440d91b4bd9ce","permalink":"https://cytgenkidu.github.io/tutorial/c/9/","publishdate":"2021-02-15T00:00:00+01:00","relpermalink":"/tutorial/c/9/","section":"tutorial","summary":"数据类型  内置类型\nchar //字符数据类型 short //短整型 int //整形 long //长整型 long long //更长的整形 float //单精度浮点数 double //双精度浮点数  自定义类型(构造类型)\n  类型的意义：\n 使用这个类型开辟内存空间的大小（大小决定了使用范围）。 如何看待内存空间的视角。  类型的基本归类 整形家族 char unsigned char //无符号数 signed char short unsigned short [int] signed short [int] //[int] 可以省略 int unsigned int signed int long unsigned long [int] signed long [int]  浮点数家族 float double  构造类型 \u0026gt; 数组类型 \u0026gt; 结构体类型 struct \u0026gt; 枚举类型 enum \u0026gt; 联合类型 union  指针类型 int *pi; char *pc; float* pf; void* pv;  空类型 void 表示空类型（无类型） 通常应用于函数的返回类型、函数的参数、指针类型。  整形在内存中的存储 limit.","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" 字符指针 在指针的类型中我们知道有一种指针类型为字符指针 char* ;\n一般使用:\nchar ch = 'w'; char *pc = \u0026amp;ch; *pc = 'w';  char arr[] = \u0026quot;abcdef\u0026quot;; char* pc = arr; printf(\u0026quot;%s\\n\u0026quot;, arr);//abcdef printf(\u0026quot;%s\\n\u0026quot;, pc);//abcdef  还有一种使用方式如下：\nchar* p= \u0026quot;abcdef\u0026quot;;//\u0026quot;abcdef\u0026quot; 是一个常量字符串，存放的是a的地址 printf(\u0026quot;%c\\n\u0026quot;, p);//a printf(\u0026quot;%s\\n\u0026quot;, p);//abcdef *p='W'; //printf(\u0026quot;%s\\n\u0026quot;, p);//err,准确的写法const char* p= \u0026quot;abcdef\u0026quot;;  面试题 char arr1[] = \u0026quot;abcdef\u0026quot;; char arr2[] = \u0026quot;abcdef\u0026quot;; const char* p1 = \u0026quot;abcdef\u0026quot;;//常量自字符串 const char* p2 = \u0026quot;abcdef\u0026quot;;//常量自字符串里 //p1、p2指向的是一个同一个常量字符串，p1和p2指向同一个地址 //C/C++会把常量字符串存储到单独的一个内存区域， //当几个指针。指向同一个字符串的时候，他们实际会指向同一块内存。 //但是用相同的常量字符串去初始化不同的数组的时候就会开辟出不同的内存块。 if (arr1 == arr2) { printf(\u0026quot;hehe\\n\u0026quot;); } else { printf(\u0026quot;haha\\n\u0026quot;);//打印 } if (p1 == p2) { printf(\u0026quot;hehe\\n\u0026quot;);//打印 } else { printf(\u0026quot;haha\\n\u0026quot;); }  指针数组 指针数组的定义 //指针数组 是数组，用来存放指针的 int arr[10] = {0};//整形数组 char ch[5] = { 0 };//字符数组 int* parr[4];//存放整形指针的数组 - 指针数组 char* pch[5];//存放字符指针的数组 - 指针数组  指针数组的用途 //实际中不会这么用 int a = 10; int b = 20; int c = 30; int d = 40; int* arr[4] = {\u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d}; int i = 0; for (i = 0; i \u0026lt; 4; i++) { printf(\u0026quot;%d \u0026quot;, *(arr[i]));//10 20 30 40 }  实际用途\nint arr1[] = { 1, 2, 3, 4, 5 }; int arr2[] = { 2, 3, 4, 5, 6 }; int arr3[] = { 3, 4, 5, 6, 7 }; int* parr[] = { arr1, arr2, arr3 }; int i = 0; for (i = 0; i \u0026lt; 3; i++) { int j = 0; for (j = 0; j \u0026lt; 5; j++) { printf(\u0026quot;%d \u0026quot;, *(parr[i] + j)); } printf(\u0026quot;\\n\u0026quot;); }  数组指针 数组指针是指针？还是数组？\n答案是：指针。\n//int *p = NULL; //p是整形指针 - 指向整形的指针 - 可以存放整形的地址 //char* pc = NULL;//pc是字符指针 - 指向字符的指针 - 可以存放字符的地址 //数组指针 - 指向数组的指针 - 存放数组的地址 //int arr[10] = {0}; //arr- 首元素地址 //\u0026amp;arr[0] -首元素的地址 //\u0026amp;arr - 数组的地址 int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; int (*p)[10] = \u0026amp;arr;//数组的地址要存起来 //上面的p就是数组指针 printf(\u0026quot;%p\\n\u0026quot;, arr ); printf(\u0026quot;%p\\n\u0026quot;, arr + 1); printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;arr ); printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;arr+1);  \u0026amp;arr和arr，虽然值是一样的，但是意义应该不一样的。 实际上： \u0026amp;arr 表示的是数组的地址，而不是数组首元素的地址。 数组的地址+1，跳过整个数组的大小，所以 \u0026amp;arr+1 相对于 \u0026amp;arr 的差值是40.\n\u0026amp;数组名VS数组名 数组指针的使用 char* arr[5]; char* (*pa)[5] = \u0026amp;arr;;//把数组arr的地址赋值给数组指针变量pa //但是我们一般很少这样写代码  一个数组指针的使用：\n//参数是数组的形式 void print1(int arr[3][5], int x, int y) { int i = 0; int j = 0; for (i = 0; i \u0026lt; x; i++) { for (j = 0; j \u0026lt; y; j++) { printf(\u0026quot;%d \u0026quot;, arr[i][j]); } printf(\u0026quot;\\n\u0026quot;); } } //参数是指针的形式 void print2(int(*p)[5], int x, int y) { int i = 0; for (i = 0; i \u0026lt; x; i++) { int j = 0; for (j = 0; j \u0026lt; y; j++) { printf(\u0026quot;%d \u0026quot;, p[i][j]); //printf(\u0026quot;%d \u0026quot;, *(p[i] + j));// //printf(\u0026quot;%d \u0026quot;, *(*(p + i) + j)); //printf(\u0026quot;%d \u0026quot;, (*(p + i))[j]);//*(p + i)找到第i行j元素 } printf(\u0026quot;\\n\u0026quot;); } } int main() { int arr[3][5] = { { 1, 2, 3, 4, 5 }, { 2, 3, 4, 5, 6 }, { 3, 4, 5, 6, 7 } }; //print1(arr, 3, 5);//arr - 数组名 - 数组名就是首元素地址 //但是二维数组的首元素是二维数组的第一行 //所以这里传递的arr，其实相当于第一行的地址，是一维数组的地址 //可以数组指针来接收 print_arr2(arr, 3, 5); return 0; }  arr[i] == *(arr+i) == *(p+i) == p[i]\nint arr[10] = {1,2,3,4,5,6,7,8,9,10}; int i = 0; int* p = arr; for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;%d \u0026quot;, p[i]);//1 2 3 4 5 6 7 8 9 10 printf(\u0026quot;%d \u0026quot;, *(p + i));//1 2 3 4 5 6 7 8 9 10 printf(\u0026quot;%d \u0026quot;, *(arr + i));//1 2 3 4 5 6 7 8 9 10 printf(\u0026quot;%d \u0026quot;, arr[i]);//arr[i] == *(arr+i) == *(p+i) == p[i] }  //去掉数组名，就是存储的元素类型\nint arr[5]; //arr 是一个5个元素的整形数组 int *parr1[10]; //parr1 是一个数组，数组有10个元素，每个元素的类型是int* ,parr1是存放指针的数组。指针数组 int (*parr2)[10]; //parr2 是一个指针，改指针指向了一个数组，数组有10个元素，每个元素的类型是int,parr2 是数组指针 int (*parr3[10])[5];//parr3 是一个数组，该数组有10个元素，每个元素是一个数组指针，该数组指针指向的数组有5个元素，每个元素是int  数组参数、指针参数 一维数组传参 #include \u0026lt;stdio.h\u0026gt; void test(int arr[])//ok {} void test(int arr[10])//ok {} void test(int *arr)//ok {} void test2(int *arr[20])//ok {} void test2(int **arr)//ok {} int main() { int arr[10] = {0}; int *arr2[20] = {0}; test(arr); test2(arr2); }  二维数组传参 void test(int arr[3][5])//ok {} void test(int arr[][])//err {} void test(int arr[][5])//ok {} void test(int arr[3][])//err {} //总结：二维数组传参，函数形参的设计只能省略第一个[]的数字。 //因为对一个二维数组，可以不知道有多少行，但是必须知道一行多少元素。 //这样才方便运算。 void test(int *arr)//err {} void test(int* arr[5])//ok {} void test(int (*arr)[5])//ok {} void test(int **arr)//err {} int main() { int arr[3][5] = {0}; test(arr);//传入arr的第一行的地址，是个一维数组的地址值 }  一级指针传参 #include \u0026lt;stdio.h\u0026gt; void print(int *p, int sz) { int i = 0; for(i=0; i\u0026lt;sz; i++) { printf(\u0026quot;%d\\n\u0026quot;, *(p+i)); } } int main() { int arr[10] = {1,2,3,4,5,6,7,8,9}; int *p = arr; int sz = sizeof(arr)/sizeof(arr[0]); //一级指针p，传给函数 print(p, sz); return 0; }  void test1(int *p) {} //test1函数能接收什么参数？ void test2(char* p) {} //test2函数能接收什么参数？ int main() { int a = 10; int* p1 = \u0026amp;a; test1(\u0026amp;a);//ok test1(p1);//ok char ch = 'w'; char* pc = \u0026amp;ch; test2(\u0026amp;ch);//ok test2(pc);//ok return 0; }  二级指针传参 #include \u0026lt;stdio.h\u0026gt; void test(int** ptr) { printf(\u0026quot;num = %d\\n\u0026quot;, **ptr); } int main() { int n = 10; int*p = \u0026amp;n; int **pp = \u0026amp;p; test(pp); test(\u0026amp;p); int* arr[10]; test(arr);//指针数组也可以 return 0; }  函数指针 \u0026amp;函数名 和 函数名 都是函数的地址\n//数组指针 - 是指向数组的指针 //函数指针 - 是指向函数的指针 - 存放函数地址的一个指针 int Add(int x, int y) { int z = 0; z = x + y; return z; } int main() { int a = 10; int b = 20; //int arr[10] = { 0 }; //int (*p)[10] = \u0026amp;arr; //arr;//\u0026amp;arr //printf(\u0026quot;%d\\n\u0026quot;, Add(a, b)); //\u0026amp;函数名 和 函数名 都是函数的地址 /* printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;Add); printf(\u0026quot;%p\\n\u0026quot;, Add); */ int (*pa)(int, int) = Add; printf(\u0026quot;%d\\n\u0026quot;, (*pa)(2, 3));//5 return 0; }  void Print(char*str) { printf(\u0026quot;%s\\n\u0026quot;, str); } int main() { int a; int * pa; void (*p)(char*) = Print; (*p)(\u0026quot;hello\u0026quot;); p(\u0026quot;hello\u0026quot;); p(\u0026quot;hello world\u0026quot;); return 0; }  //代码1 (*(void (*)())0)();//将0进行强制类型转换成【void (*)() 】-函数指针类型，该函数指针的类型是无参换返回类型是void,0就是一个函数的地址，然后*解引用，调用0地址处的该函数。 //代码2 void (* signal(int , void(*)(int)) )(int);//void(*)(int) 函数指针类型，该函数指针类型传入int返回void 。整个函数指针返回的是void(* )(int)-函数指针类型 // signal是一个函数声明 // signal函数的参数有2个，第一个是int。第二个是函数指针，该函数指针指向的函数的参数是int，返回类型是void // signal函数的返回类型也是一个函数指针：该函数指针指向的函数的参数是int，返回类型是void ////简化 //typedef void(*pfun_t)(int); //pfun_t signal(int, pfun_t); // //typedef unsigned int uint;  注 :推荐《C陷阱和缺陷》\nint Add(int x, int y) { int z = 0; z = x + y; return z; } int main() { int a = 10; int b = 20; int(*pa)(int, int) = Add; printf(\u0026quot;%d\\n\u0026quot;, pa(2, 3)); printf(\u0026quot;%d\\n\u0026quot;, Add(2, 3)); //printf(\u0026quot;%d\\n\u0026quot;, *pa(2, 3));//err printf(\u0026quot;%d\\n\u0026quot;, (*pa)(2, 3)); printf(\u0026quot;%d\\n\u0026quot;, (**pa)(2, 3)); return 0; }  函数指针数组 int Add(int x, int y) { return x + y; } int Sub(int x, int y) { return x - y; } int Mul(int x, int y) { return x * y; } int Div(int x, int y) { return x / y; } int main() { //指针数组 //int* arr[5]; //需要一个数组，这个数组可以存放4个函数的地址 - 函数指针的数组 int (*pa)(int, int) = Add;//Sub/Mul/Div int(*parr[4])(int, int) = {Add, Sub, Mul, Div};//函数指针的数组 int i = 0; for (i = 0; i \u0026lt; 4; i++) { printf(\u0026quot;%d\\n\u0026quot;, parr[i](2, 3));//5 -1 6 0 } return 0; }  函数指针定义 int (*parr1[10])(); int *parr2[10]();//err int (*)() parr3[10];//err  练习 char* my_strcpy(char* dest, const char* src); //1.写一个函数指针 pf，能够指向my_strcpy char* (*pf)(char*, const char*); //2. 写一个函数指针数组 pfArr，能够存放4个my_strcpy函数的地址 char* (*pfArr[4])(char*, const char*);  函数指针数组的用途：转移表 例子：（计算器）\n#include \u0026lt;stdio.h\u0026gt; //计算器 void menu() { printf(\u0026quot;**************************\\n\u0026quot;); printf(\u0026quot;** 1. add 2. sub **\\n\u0026quot;); printf(\u0026quot;** 3. mul 4. div **\\n\u0026quot;); printf(\u0026quot;** 5. xor 0. exit**\\n\u0026quot;); printf(\u0026quot;**************************\\n\u0026quot;); } int Add(int x, int y) { return x + y; } int Sub(int x, int y) { return x - y; } int Mul(int x, int y) { return x * y; } int Div(int x, int y) { return x / y; } int Xor(int x, int y) { return x ^ y; } //回调函数 void Calc(int (*pf)(int, int)) { int x = 0; int y = 0; printf(\u0026quot;请输入两个操作数:\u0026gt;\u0026quot;); scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x, \u0026amp;y); printf(\u0026quot;%d\\n\u0026quot;, pf(x, y)); } int main() { int input = 0; do { menu(); printf(\u0026quot;请选择:\u0026gt;\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;input); switch (input) { case 1: Calc(Add); break; case 2: Calc(Sub); break; case 3: Calc(Mul); break; case 4: Calc(Div); break; case 0: printf(\u0026quot;退出\\n\u0026quot;); break; default: printf(\u0026quot;选择错误\\n\u0026quot;); break; } } while (input); return 0; }  使用函数指针数组的实现main：\nint main() { int input = 0; int x = 0; int y = 0; //pfArr 是一个函数指针数组 - 转移表 int(*pfArr[])(int, int) = {0, Add, Sub, Mul, Div, Xor}; do { menu(); printf(\u0026quot;请选择:\u0026gt;\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;input); if (input \u0026gt;= 1 \u0026amp;\u0026amp; input \u0026lt;= 5) { printf(\u0026quot;请输入两个操作数:\u0026gt;\u0026quot;); scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x, \u0026amp;y); int ret = pfArr[input](x, y); printf(\u0026quot;%d\\n\u0026quot;, ret); } else if (input == 0) { printf(\u0026quot;退出\\n\u0026quot;); } else { printf(\u0026quot;选择错误\\n\u0026quot;); } } while (input); }  指向函数指针数组的指针 指向函数指针数组的指针是一个指针，指针指向一个数组，数组的元素都是函数指针。\nint arr[10] = { 0 }; int (*p)[10] = \u0026amp;arr;//取出数组的地址 int(*pf)(int, int);//函数指针 int (*pfArr[4])(int, int);//pfArr是一个数组-函数指针的数组 //ppfArr是一个指向[函数指针数组]的指针 int(*(*ppfArr)[4])(int, int) = \u0026amp;pfArr; // //ppfArr 是一个数组指针，指针指向的数组有4个元素 //指向的数组的每个元素的类型是一个函数指针 int(*)(int, int) //  回调函数 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。\nvoid print(char *str) //回调函数 { printf(\u0026quot;hehe:%s\u0026quot;, str); } void test( void (*p)(char*) ) { printf(\u0026quot;test\\n\u0026quot;); p(\u0026quot;hello\u0026quot;); } int main() { test(print); //test //hehe : hello return 0; }  使用场景 之前写的BubbleSort：只能排序整形数组\nvoid bubble_sort(int arr[], int sz) { int i = 0; //趟数 for (i = 0; i \u0026lt; sz-1; i++) { //一趟冒泡排序 int j = 0; for (j = 0; j \u0026lt;sz-1-i; j++)//9 8 7 6 5 4 3 2 1 多少对 { if (arr[j] \u0026gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } } }  void* 类型的指针 可以接受任意类型的地址\nint a = 10; //int* pa = \u0026amp;a;// //char* pc = \u0026amp;a; //char ch = 'w'; void* p = \u0026amp;a; //*p = 0; //p++; //p = \u0026amp;ch; //void* 类型的指针 可以接收任意类型的地址 //void* 类型的指针 不能进行解引用操作 //void* 类型的指针 不能进行+-整数的操作  qsort函数 qsort函数实现冒泡排序 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int cmp_int(const void *e1, const void *e2) { //比较两个整形值的 return *(int *)e1 - *(int *)e2; } void test1() { int arr[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}; int sz = sizeof(arr) / sizeof(arr[0]); qsort(arr, sz, sizeof(arr[0]), cmp_int); int i = 0; for (i = 0; i \u0026lt; sz; i++) { printf(\u0026quot;%d \u0026quot;, arr[i]); } } //比较浮点型 int cmp_float(const void *e1, const void *e2) { /*if (*(float*)e1 == *(float*)e2) return 0; else if (*(float*)e1 \u0026gt; *(float*)e2) return 1; else return -1;*/ return ((int)(*(float *)e1 - *(float *)e2)); } void test2() { float f[] = {9.0, 8.0, 7.0, 6.0, 5.0, 4.0}; int sz = sizeof(f) / sizeof(f[0]); qsort(f, sz, sizeof(f[0]), cmp_float); int j = 0; for (j = 0; j \u0026lt; sz; j++) { printf(\u0026quot;%f \u0026quot;, f[j]); } } //比较结构体类型 struct Stu { char name[20]; int age; }; int cmp_stu_by_age(const void *e1, const void *e2) { return ((struct Stu *)e1)-\u0026gt;age - ((struct Stu *)e2)-\u0026gt;age; } int cmp_stu_by_name(const void *e1, const void *e2) { //比较名字就是比较字符串 //字符串比较不能直接用\u0026gt;\u0026lt;=来比较，应该用strcmp函数\u0026lt;string.h\u0026gt; return strcmp(((struct Stu *)e1)-\u0026gt;name, ((struct Stu *)e2)-\u0026gt;name); } void test3() { struct Stu s[3] = {{\u0026quot;zhangsan\u0026quot;, 20}, {\u0026quot;lisi\u0026quot;, 30}, {\u0026quot;wangwu\u0026quot;, 10}}; int sz = sizeof(s) / sizeof(s[0]); qsort(s, sz, sizeof(s[0]), cmp_stu_by_name); //第一个参数：待排序数组的收元素地址 //第二个参数：待排序数组的元素个数 //第三个参数：待排序数组的每个元素的大小-单位是字节 //第四个参数：是函数指针，比较两个元素的所用函数的地址-这个函数使用者自己实现 // 函数指针的两个参数是：待比较的两个元素的地址 } //实现bubble_sort函数的程序员，他是否知道未来排序的数据类型-不知道 //那程序员也不知道，待比较的两个元素的类型 void Swap(char *buf1, char *buf2, int width) { int i = 0; for (i = 0; i \u0026lt; width; i++) { char tmp = *buf1; *buf1 = *buf2; *buf2 = tmp; buf1++; //指向下一个字符 buf2++; } } //因为首元素类型不同，v所以使用void指针 //sz要排序元素个数 //width每个元素的字节数 //两个元素比较的方法不一样，把比较函数的地址传进来,e1,e2要比较的元素 void bubble_sort(void *base, int sz, int width, int (*cmp)(void *e1, void *e2)) { int i = 0; //趟数 for (i = 0; i \u0026lt; sz - 1; i++) { //每一趟比较的对数 int j = 0; for (j = 0; j \u0026lt; sz - 1 - i; j++) { //两个元素的比较 if (cmp((char *)base + j * width, (char *)base + (j + 1) * width) \u0026gt; 0) { //交换,一对一对字符交换 Swap((char *)base + j * width, (char *)base + (j + 1) * width, width); } } } } void test4() { int arr[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}; int sz = sizeof(arr) / sizeof(arr[0]); //使用bubble_sort的程序员一定知道自己排序的是什么数据 //就应该知道如何比较待排序数组中的元素 bubble_sort(arr, sz, sizeof(arr[0]), cmp_int); } void test5() { struct Stu s[3] = {{\u0026quot;zhangsan\u0026quot;, 20}, {\u0026quot;lisi\u0026quot;, 30}, {\u0026quot;wangwu\u0026quot;, 10}}; int sz = sizeof(s) / sizeof(s[0]); //bubble_sort(s, sz, sizeof(s[0]), cmp_stu_by_age); bubble_sort(s, sz, sizeof(s[0]), cmp_stu_by_name); } int main() { //test1(); //test2(); //test3(); //test4(); test5(); return 0; }  指针和数组笔试题解析 数组名是首元素的地址\n sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小。 \u0026amp;数组名，这里的数组名表示整个数组，取出的是整个数组的地址。 除此之外所有的数组名都表示首元素的地址。  一维数组 整形数组 int a[] = {1, 2, 3, 4}; //4*4 = 16 printf(\u0026quot;%d\\n\u0026quot;, sizeof(a)); //sizeof(数组名)-计算的是数组总大小-单位是字节- 16 printf(\u0026quot;%d\\n\u0026quot;, sizeof(a + 0)); //4/8 - 数组名这里表示收元素的值，a+0 还是首元素地址，地址的大小就是4/8个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(*a)); //4 - 数组名表示首元素地址，*a就是首元素，sizeof(*a)就是4 printf(\u0026quot;%d\\n\u0026quot;, sizeof(a + 1)); //4/8 - 数组名这里表示收元素的值，a+1 第2个元素的地址，地址的大小就是4/8个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(a[1])); //4 - 第2个元素的大小 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;a)); //4/8 \u0026amp;a取出的是数组的地址，但是数组的地址那也是地址，地址的大小就是4/8个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(*\u0026amp;a)); //16 - \u0026amp;a数组的地址，数组的地址解引用访问的数组，sizeof计算的就是数组的大小单位是字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;a + 1)); //4/8 \u0026amp;a是数组的地址，\u0026amp;a+1虽然地址跳过整个数组，但还是地址，所以是4/8个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;a[0])); //4/8 \u0026amp;a[0]是第一个元素的地址 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;a[0] + 1)); //4/8 \u0026amp;a[0]+1 是第二个元素的地址  字符数组1 char arr[] = {'a', 'b', 'c', 'd', 'e', 'f'}; printf(\u0026quot;%d\\n\u0026quot;, strlen(arr)); //随机值 printf(\u0026quot;%d\\n\u0026quot;, strlen(arr + 0)); //随机值 //printf(\u0026quot;%d\\n\u0026quot;, strlen(*arr));//err //printf(\u0026quot;%d\\n\u0026quot;, strlen(arr[1]));//err printf(\u0026quot;%d\\n\u0026quot;, strlen(\u0026amp;arr));//随机值 printf(\u0026quot;%d\\n\u0026quot;, strlen(\u0026amp;arr + 1));//随机值-6,与前一个随机值差6 printf(\u0026quot;%d\\n\u0026quot;, strlen(\u0026amp;arr[0] + 1));//随机值-1，与前一个随机值差1 printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr)); //sizeof计算机的是数组大小，6*1 = 6字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr + 0)); //4/8 arr是首元素的地址，arr+0还是首元素的地址 地址的大小是4/8字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(*arr)); //1 arr是首元素的地址，*arr就是首元素，首元素是字符大小是一个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr[1])); //1 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;arr)); //4/8 \u0026amp;arr 虽然是数组的地址，但还是地址，地址大小是4/8个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;arr + 1)); //4/8 \u0026amp;arr+1 是跳过整个数组后的地址，地址大小是4/8个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;arr[0] + 1)); //4/8 第二个元素的地址  字符数组2 char arr[] = \u0026quot;abcdef\u0026quot;; printf(\u0026quot;%d\\n\u0026quot;, strlen(arr)); //6 printf(\u0026quot;%d\\n\u0026quot;, strlen(arr + 0)); //6 //printf(\u0026quot;%d\\n\u0026quot;, strlen(*arr));//err //printf(\u0026quot;%d\\n\u0026quot;, strlen(arr[1]));//err printf(\u0026quot;%d\\n\u0026quot;, strlen(\u0026amp;arr)); //6 \u0026amp;arr - 数组的地址-数组指针 char(*p)[7] = \u0026amp;arr; printf(\u0026quot;%d\\n\u0026quot;, strlen(\u0026amp;arr + 1)); //随机值 printf(\u0026quot;%d\\n\u0026quot;, strlen(\u0026amp;arr[0] + 1)); //5 printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr)); //sizeof(arr)计算的数组的大小，单位是字节：7 printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr + 0)); //4/8 计算的是地址的大小-arr + 0是首元素的地址 printf(\u0026quot;%d\\n\u0026quot;, sizeof(*arr)); //1 *arr 是首元素，sizeof(*arr)计算首元素的大小 printf(\u0026quot;%d\\n\u0026quot;, sizeof(arr[1])); //1 arr[1]是第二个元素，sizeof(arr[1])计算的是第二个元素的大小 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;arr)); //4/8 \u0026amp;arr虽然是数组的地址，但也是地址，所以是4/8个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;arr + 1)); //4/8 \u0026amp;arr+1是跳过整个数组后的地址，但也是地址 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;arr[0] + 1)); //4/8 \u0026amp;arr[0]+1 第二个元素的地址  字符数组3 char *p = \u0026quot;abcdef\u0026quot;; //把常量字符串abcdef的a的地址放到p printf(\u0026quot;%d\\n\u0026quot;, strlen(p)); //6 printf(\u0026quot;%d\\n\u0026quot;, strlen(p + 1)); //5 //printf(\u0026quot;%d\\n\u0026quot;, strlen(*p));//err //printf(\u0026quot;%d\\n\u0026quot;, strlen(p[0]));//err printf(\u0026quot;%d\\n\u0026quot;, strlen(\u0026amp;p)); //随机值 小端存储 printf(\u0026quot;%d\\n\u0026quot;, strlen(\u0026amp;p + 1)); //随机值 printf(\u0026quot;%d\\n\u0026quot;, strlen(\u0026amp;p[0] + 1)); //5 printf(\u0026quot;%d\\n\u0026quot;, sizeof(p)); //4/8 - 计算指针变量p的大小 printf(\u0026quot;%d\\n\u0026quot;, sizeof(p + 1)); //4/8 - p+1 得到的是字符b的地址 printf(\u0026quot;%d\\n\u0026quot;, sizeof(*p)); //1 *p 就是字符串的第一个字符 - 'a' printf(\u0026quot;%d\\n\u0026quot;, sizeof(p[0])); //1 int arr[10]; arr[0] == *(arr+0) p[0] == *(p+0) == 'a' printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;p)); //4/8 地址 a的地址 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;p + 1)); //4/8 地址 b的地址 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;p[0] + 1)); //4/8 地址 b的地址  \u0026amp;p 和 \u0026amp;p+1 【图中地址为捏造，举例】\n二维数组 //二维数组 int a[3][4] = {0}; //printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;a[0][0]); //00000009A9B4F6E8 第一行第一个元素的地址 //printf(\u0026quot;%p\\n\u0026quot;, a[0] + 1); //00000009A9B4F6EC 第一行第二个元素的地址 64位 //printf(\u0026quot;%p\\n\u0026quot;, a + 1); //00000009A9B4F6F8 第二行的地址 //printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;a[0] + 1); //00000009A9B4F6F8 第二行的地址 printf(\u0026quot;%d\\n\u0026quot;, sizeof(a)); //48 printf(\u0026quot;%d\\n\u0026quot;, sizeof(a[0][0])); //4 printf(\u0026quot;%d\\n\u0026quot;, sizeof(a[0])); //16 a[0]相当于第一行做为一维数组的数组名， //sizeof(arr[0])把数组名单独放在sizeof()内，计算的是第一行的大小 printf(\u0026quot;%d\\n\u0026quot;, sizeof(a[0] + 1)); //4/8 - a[0]是第一行的数组名，数组名此时是首元素的地址，a[0]其实就是第一行第一个元素的地址 //所以 a[0]+1 就是第一行第二个元素的地址- 地址大小是4/8个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(*(a[0] + 1))); //4- *(a[0] + 1)) 是第一行第二个元素，大小是4个字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(a + 1)); //4/8 //a是二维数组的数组名，没有sizeof(a)，也没有\u0026amp;(a),所以a是首元素地址 //而把二维数组看成一维数组时，二维数组的首元素是他的第一行，a就是第一行（首元素）的地址 //a+1就是第二行的地址 printf(\u0026quot;%d\\n\u0026quot;, sizeof(*(a + 1))); //16, sizeof(a[1]) 计算第二行的大小,单位是字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(\u0026amp;a[0] + 1)); //4/8, 第二行的地址 printf(\u0026quot;%d\\n\u0026quot;, sizeof(*(\u0026amp;a[0] + 1))); //16 计算第二行的大小，单位是字节 printf(\u0026quot;%d\\n\u0026quot;, sizeof(*a)); //16 a是首元素地址-第一行的地址，*a就是第一行，sizeof(*a)就是计算第一行的大小 printf(\u0026quot;%d\\n\u0026quot;, sizeof(a[3])); //16 sizeof()括号里不参与真实运算，sizeof(a[3])等价sizeof(a[0])  指针相关 指针加减整数的运算1 int a[5] = { 1, 2, 3, 4, 5 }; int *ptr = (int *)(\u0026amp;a + 1); printf( \u0026quot;%d,%d\u0026quot;, *(a + 1), *(ptr - 1)); //2 5  指针加减整数的运算2 //结构体的大小是20个字节 struct Test { int Num; char *pcName; short sDate; char cha[2]; short sBa[4]; } * p; //假设p 的值为0x100000。 如下表表达式的值分别为多少？ int main() { p = (struct Test *)0x100000; printf(\u0026quot;%p\\n\u0026quot;, p + 0x1); //00100014 32位 0x100000+20 printf(\u0026quot;%p\\n\u0026quot;, (unsigned long)p + 0x1); //00100001 32位 p转换成10进制=1,048,576+1 printf(\u0026quot;%p\\n\u0026quot;, (unsigned int *)p + 0x1); //00100004 32位 (unsigned int *)无符号整型指针 就是指针+1(int指针为4/8) return 0; }  指针加减整数的运算3 int a[4] = { 1, 2, 3, 4 }; int *ptr1 = (int *)(\u0026amp;a + 1); int *ptr2 = (int *)((int)a + 1);//a是首元素地址，强制转换成整数+1.在转换成地址，相当于向后偏移了一个字节 printf(\u0026quot;%x,%x\u0026quot;, ptr1[-1], *ptr2);//4，2000000  指针加减整数的运算4 int a[3][2] = { (0, 1), (2, 3), (4, 5) };//（，）逗号表达式，存储逗号后内容 int *p; p = a[0]; printf(\u0026quot;%d\\n\u0026quot;, p[0]);//1  指针加减整数的运算5 int a[5][5]; int(*p)[4]; p = a;//int (*)[4] ----- int (*) [5] 【会有警告】 printf(\u0026quot;%p,%d\\n\u0026quot;, \u0026amp;p[4][2] - \u0026amp;a[4][2], \u0026amp;p[4][2] - \u0026amp;a[4][2]);//FFFFFFFC,-4  指针加减整数的运算6 int aa[2][5] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int *ptr1 = (int *)(\u0026amp;aa + 1); int *ptr2 = (int *)(*(aa + 1)); // aa[1] printf(\u0026quot;%d,%d\\n\u0026quot;, *(ptr1 - 1), *(ptr2 - 1)); //10 5 int arr[10] = {1,2,3,4,5}; int* p = arr; //*(p + 2) == p[2] ==\u0026gt; *(arr+2) == arr[2] arr[2]; // ==\u0026gt; *(arr+2)  指针加减整数的运算7 char* a[] = { \u0026quot;work\u0026quot;, \u0026quot;at\u0026quot;, \u0026quot;alibaba\u0026quot; }; char**pa = a; pa++; printf(\u0026quot;%s\\n\u0026quot;, *pa);//  指针加减整数的运算8 char *c[] = {\u0026quot;ENTER\u0026quot;, \u0026quot;NEW\u0026quot;, \u0026quot;POINT\u0026quot;, \u0026quot;FIRST\u0026quot;}; char **cp[] = {c + 3, c + 2, c + 1, c}; char ***cpp = cp; printf(\u0026quot;%s\\n\u0026quot;, **++cpp); //POINT printf(\u0026quot;%s\\n\u0026quot;, *--*++cpp + 3); //ER printf(\u0026quot;%s\\n\u0026quot;, *cpp[-2] + 3); //ST printf(\u0026quot;%s\\n\u0026quot;, cpp[-1][-1] + 1); //EW  旋转字符串 实现一个函数，可以左旋字符串中的k个字符。\n例如： ABCD左旋一个字符得到BCDA ABCD左旋两个字符得到CDAB   暴力求解法\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; void left_move(char* arr, int k) { assert(arr != NULL); int i = 0; int len = strlen(arr); for (i = 0; i \u0026lt; k; i++) { //左旋转一个字符 //1 char tmp = *arr; //2 int j = 0; for (j = 0; j \u0026lt; len-1; j++) { *(arr + j) = *(arr + j + 1); } //3 *(arr + len - 1) = tmp; } } int main() { char arr[] = \u0026quot;abcdef\u0026quot;; left_move(arr, 2); printf(\u0026quot;%s\\n\u0026quot;, arr); return 0; }  三步翻转法\nabcdef ab cdef 左边逆序，右边逆序 bafedc 整体逆序 cdefab  #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; //逆序字符串的函数 void reverse(char* left, char* right) { assert(left != NULL); assert(right != NULL); while (left \u0026lt; right) { char tmp = *left; *left = *right; *right = tmp; left++; right--; } } void left_move(char* arr, int k) { assert(arr); int len = strlen(arr); assert(k \u0026lt;= len); //不能超过字符长度 reverse(arr, arr + k - 1);//逆序左边 reverse(arr + k, arr + len - 1);//逆序右边 reverse(arr, arr + len - 1);//逆序整体 } int main() { char arr[] = \u0026quot;abcdef\u0026quot;; left_move(arr, 2); printf(\u0026quot;%s\\n\u0026quot;, arr); return 0; }   字符串旋转结果 写一个函数，判断一个字符串是否为另一个字符串旋转之后的字符串。\n例如给定 s1=AABCD和s2=BCDAA,返回1 给定s1=abcd和s2=ACBD,返回0 AABCD左旋一个字符得到ABCDA AABCD左旋两个字符得到BCDAA AABCD右旋一个字符得到DAABC   穷举法\nint is_left_move(char* str1, char* str2) { int len = strlen(str1); int i = 0; for (i = 0; i \u0026lt; len; i++) { left_move(str1, 1);//调用上题代码，每次旋转s1都会变化 int ret = strcmp(str1, str2); if (ret == 0) { return 1; } } return 0; } int main() { char arr1[] = \u0026quot;abcdef\u0026quot;; char arr2[] = \u0026quot;cdefab\u0026quot;; int ret = is_left_move(arr1, arr2); if (ret == 1) { printf(\u0026quot;Yes\\n\u0026quot;); } else { printf(\u0026quot;No\\n\u0026quot;); } return 0; }  追加法\nabcdef cdefab abcdefabcdef  #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int is_left_move(char* str1, char* str2) { int len1 = strlen(str1); int len2 = strlen(str2); if (len1 != len2) return 0; //1. 在str1字符串中追加一个str1字符串 //strcat(str1, str1);//err 自己给自己追加不能使用该方法\\0不会停下来 strncat(str1, str1, len1);//abcdefabcdef //2. 判断str2指向的字符串是否是str1指向的字符串的子串 //strstr-找子串的 char * ret = strstr(str1, str2); if (ret == NULL) { return 0; } else { return 1; } } int main() { char arr1[30] = \u0026quot;abcdef\u0026quot;; char arr2[] = \u0026quot;cdef\u0026quot;; int ret = is_left_move(arr1, arr2); if (ret == 1) { printf(\u0026quot;Yes\\n\u0026quot;); } else { printf(\u0026quot;No\\n\u0026quot;); } return 0; }  注： strcat 示例\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { char arr1[30] = \u0026quot;abc\u0026quot;; char arr2[] = \u0026quot;def\u0026quot;; strcat(arr1, arr2); printf(\u0026quot;%s\\n\u0026quot;, arr1); //abcdef return 0; }   杨氏矩阵 有一个数字矩阵，矩阵的每行从左到右是递增的，矩阵从上到下是递增的， 请编写程序在这样的矩阵中查找某个数字是否存在。 要求：时间复杂度小于O(N); 1 2 3 4 5 6 7 8 9 1 2 3 2 3 4 3 4 5  //int FindNum(int arr[3][3], int k, int row, int col) //{ // int x = 0; // int y = col - 1; // // while (x\u0026lt;=row-1 \u0026amp;\u0026amp; y\u0026gt;=0) // { // if (arr[x][y] \u0026gt; k) // { // y--; // } // else if (arr[x][y] \u0026lt; k) // { // x++; // } // else // { // return 1; // } // } // //找不到 // return 0; //} // int FindNum(int arr[3][3], int k, int *px, int*py) { int x = 0; int y = *py - 1; while (x \u0026lt;= *px - 1 \u0026amp;\u0026amp; y \u0026gt;= 0) { if (arr[x][y] \u0026gt; k) { y--; } else if (arr[x][y] \u0026lt; k) { x++; } else { *px = x; *py = y; return 1; } } //找不到 return 0; } int main() { int arr[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, {7,8,9} }; int k = 7; int x = 3; int y = 3; //返回型参数 int ret = FindNum(arr, k, \u0026amp;x, \u0026amp;y); if (ret == 1) { printf(\u0026quot;找到了\\n\u0026quot;); printf(\u0026quot;下标是：%d %d\\n\u0026quot;, x, y); } else { printf(\u0026quot;找不到\\n\u0026quot;); } return 0; }  ","date":1613775600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1613775600,"objectID":"5c93727fcb130514f3a6dd8b98e630e6","permalink":"https://cytgenkidu.github.io/tutorial/c/10/","publishdate":"2021-02-20T00:00:00+01:00","relpermalink":"/tutorial/c/10/","section":"tutorial","summary":"字符指针 在指针的类型中我们知道有一种指针类型为字符指针 char* ;\n一般使用:\nchar ch = 'w'; char *pc = \u0026amp;ch; *pc = 'w';  char arr[] = \u0026quot;abcdef\u0026quot;; char* pc = arr; printf(\u0026quot;%s\\n\u0026quot;, arr);//abcdef printf(\u0026quot;%s\\n\u0026quot;, pc);//abcdef  还有一种使用方式如下：\nchar* p= \u0026quot;abcdef\u0026quot;;//\u0026quot;abcdef\u0026quot; 是一个常量字符串，存放的是a的地址 printf(\u0026quot;%c\\n\u0026quot;, p);//a printf(\u0026quot;%s\\n\u0026quot;, p);//abcdef *p='W'; //printf(\u0026quot;%s\\n\u0026quot;, p);//err,准确的写法const char* p= \u0026quot;abcdef\u0026quot;;  面试题 char arr1[] = \u0026quot;abcdef\u0026quot;; char arr2[] = \u0026quot;abcdef\u0026quot;; const char* p1 = \u0026quot;abcdef\u0026quot;;//常量自字符串 const char* p2 = \u0026quot;abcdef\u0026quot;;//常量自字符串里 //p1、p2指向的是一个同一个常量字符串，p1和p2指向同一个地址 //C/C++会把常量字符串存储到单独的一个内存区域， //当几个指针。指向同一个字符串的时候，他们实际会指向同一块内存。 //但是用相同的常量字符串去初始化不同的数组的时候就会开辟出不同的内存块。 if (arr1 == arr2) { printf(\u0026quot;hehe\\n\u0026quot;); } else { printf(\u0026quot;haha\\n\u0026quot;);//打印 } if (p1 == p2) { printf(\u0026quot;hehe\\n\u0026quot;);//打印 } else { printf(\u0026quot;haha\\n\u0026quot;); }  指针数组 指针数组的定义 //指针数组 是数组，用来存放指针的 int arr[10] = {0};//整形数组 char ch[5] = { 0 };//字符数组 int* parr[4];//存放整形指针的数组 - 指针数组 char* pch[5];//存放字符指针的数组 - 指针数组  指针数组的用途 //实际中不会这么用 int a = 10; int b = 20; int c = 30; int d = 40; int* arr[4] = {\u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d}; int i = 0; for (i = 0; i \u0026lt; 4; i++) { printf(\u0026quot;%d \u0026quot;, *(arr[i]));//10 20 30 40 }  实际用途","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" 函数介绍  求字符串长度\nstrlen  长度不受限制的字符串函数\nstrcpy strcat strcmp  长度受限制的字符串函数介绍\nstrncpy strncat strncmp  字符串查找\nstrstr strtok  错误信息报告\nstrerror  字符操作\n 内存操作函数\nmemcpy memmove memset memcmp   求字符串长度 strlen-获取字符串长度 size_t strlen ( const char * str ); //size_t== unsigned int，是无符号的（ 易错 ）   字符串已经\u0026rsquo;\\0\u0026rsquo;作为结束标志， strlen函数返回的是在字符串中\u0026rsquo;\\0\u0026rsquo;前面出现的字符个数（不包含 \u0026lsquo;\\0\u0026rsquo; )。 参数指向的字符串必须要以 \u0026lsquo;\\0\u0026rsquo; 结束。  strlen函数的模拟实现  计数器方式 不能创建临时变量计数器 指针-指针的方式  int my_strlen(const char *str) //库里返回的是无符号数 { //法一：记数方式 int count = 0; while (*str != \u0026quot;\\0\u0026quot;) //while(*str) { { count++; str++; } return count; //法二：递归方式 // if (*str == '\\0') //*str就是字符 // return 0; // else // return 1 + my_strlen(str + 1); //str +1 是str的下一个地址 //法三：指针方式 // char* start = str; // char* end = str; // while (*end != '\\0') // { // end++; // } // return end - start;// } int main() { int len = my_strlen(\u0026quot;abcdef\u0026quot;); //错误示范 //char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' }; //int len = my_strlen(arr); printf(\u0026quot;%d\\n\u0026quot;, len); //3 - 6 = -3 无符号数 if (my_strlen(\u0026quot;abc\u0026quot;) - my_strlen(\u0026quot;abcdef\u0026quot;) \u0026gt; 0) { printf(\u0026quot;hehe\\n\u0026quot;);//hehe } else { printf(\u0026quot;haha\\n\u0026quot;); } return 0; }  长度不受限制的字符串函数 strcpy-复制字符串 char* strcpy(char * destination, const char * source );   源字符串必须以 \u0026lsquo;\\0\u0026rsquo; 结束。 会将源字符串中的 \u0026lsquo;\\0\u0026rsquo; 拷贝到目标空间。 目标空间必须足够大，以确保能存放源字符串。 目标空间必须可变。  strcpy函数的模拟实现  参数顺序 函数的功能，停止条件 assert const修饰指针 函数返回值 题目出自《高质量C/C++编程》书籍最后的试题部分  char* my_strcpy(char* dest, const char*src) { assert(dest != NULL); assert(src != NULL); char* ret = dest; //拷贝src指向的字符串到dest指向的空间，包含'\\0' while (*dest++ = *src++) { ; } //返回目的空间的起始地址 return ret; } int main() { char arr1[] = \u0026quot;abcdefghi\u0026quot;;//2 //错误的示范 // char *arr1 = \u0026quot;abcdefghi\u0026quot;;//arr1是常量字符串，不能更改 char arr2[] = \u0026quot;bit\u0026quot;;//4 //错误的示范 //char arr2[] = { 'b', 'i', 't' }; my_strcpy(arr1, arr2); printf(\u0026quot;%s\\n\u0026quot;, arr1); return 0; }  strcat-追加字符串 char * strcat ( char * destination, const char * source );   源字符串必须以 \u0026lsquo;\\0\u0026rsquo; 结束。 目标空间必须有足够的大，能容纳下源字符串的内容。 目标空间必须可修改。  strcat函数的模拟实现 char *my_strcat(char *dest, const char *src) { char *ret = dest; assert(dest != NULL); assert(src); //1. 找到目的字符串的'\\0' while (*dest != '\\0') { dest++; } //2. 追加 while (*dest++ = *src++) { ; } return ret; } int main() { // char arr1[] = \u0026quot;hello\u0026quot;;err 空间不够，会造成越界访问 char arr1[30] = \u0026quot;hello\u0026quot;; char arr2[] = \u0026quot;world\u0026quot;; my_strcat(arr1, arr2); printf(\u0026quot;%s\\n\u0026quot;, arr1); return 0; }  strcmp-比较两个字符串 int strcmp (const char * str1, const char * str2 );  标准规定：\n 第一个字符串大于第二个字符串，则返回大于0的数字 第一个字符串等于第二个字符串，则返回0 第一个字符串小于第二个字符串，则返回小于0的数字  //VS2013 //\u0026gt; 1 //== 0 //\u0026lt; -1 //linux-gcc //\u0026gt; \u0026gt;0 //== 0 //\u0026lt; \u0026lt;0 char *p1 = \u0026quot;qbc\u0026quot;; //6 char *p2 = \u0026quot;abc\u0026quot;; //5 //int ret = strcmp(p1, p2); //printf(\u0026quot;%d\\n\u0026quot;, ret); if (strcmp(p1, p2) \u0026gt; 0) { printf(\u0026quot;p1\u0026gt;p2\\n\u0026quot;); } else if (strcmp(p1, p2) == 0) { printf(\u0026quot;pa == p2\\n\u0026quot;); } else if (strcmp(p1, p2) \u0026lt; 0) { printf(\u0026quot;p1\u0026lt;p2\\n\u0026quot;); }  strcmp函数的模拟实现 int my_strcmp(const char* str1, const char* str2) { assert(str1 \u0026amp;\u0026amp; str2); //比较 while (*str1 == *str2) { if (*str1 == '\\0') { return 0;//相等 } str1++; str2++; } //if (*str1 \u0026gt; *str2) // return 1;//大于 // else // return -1;//小于 return (*str1 - *str2);//linux gcc } int main() { char* p1 = \u0026quot;abcdef\u0026quot;; char* p2 = \u0026quot;qwert\u0026quot;; int ret = my_strcmp(p1, p2); printf(\u0026quot;ret = %d\\n\u0026quot;, ret); return 0; }  长度受限制的字符串函数介绍 strncpy-拷贝n个字符 char * strncpy ( char * destination, const char * source, size_t num );   拷贝num个字符从源字符串到目标空间。 如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个。  strncat-追加n个字符 char * strncat ( char * destination, const char * source, size_t num );  strncmp-比较前n个字符的两个字符串 int strncmp ( const char * str1, const char * str2, size_t num );   比较到出现另个字符不一样或者一个字符串结束或者num个字符全部比较完。  //strncmp - 字符串比较 const char* p1 = \u0026quot;abczdef\u0026quot;;//常量字符串 char* p2 = \u0026quot;abcqwer\u0026quot;; //int ret = strcmp(p1, p2); int ret = strncmp(p1, p2, 4); printf(\u0026quot;%d\\n\u0026quot;, ret);//1  字符串查找 strstr-查找字符串 char * strstr ( const char *, const char * );  strstr函数模拟实现 #include \u0026lt;assert.h\u0026gt; //还有KMP 算法 char* my_strstr(const char* p1, const char* p2) { assert(p1 != NULL); assert(p2 != NULL); char *s1 = NULL; char *s2 = NULL; char *cur = (char*)p1; if (*p2 == '\\0') { return (char*)p1; } while (*cur) { s1 = cur; s2 = (char*)p2; while (*s1 \u0026amp;\u0026amp; *s2 \u0026amp;\u0026amp; (*s1 == *s2)) //while((*s1!='\\0') \u0026amp;\u0026amp; (*s2!='\\0') \u0026amp;\u0026amp; (*s1 == *s2)) { s1++; s2++; } if (*s2 == '\\0') { return cur;//找到子串 } if (*s1 == '\\0') { return NULL;//找不到子串 s1\u0026lt;s2 } cur++; } return NULL;//找不到子串 } int main() { char *p1 = \u0026quot;abc\u0026quot;; char *p2 = \u0026quot;abcdef\u0026quot;; char* ret = my_strstr(p1, p2); if (ret == NULL) { printf(\u0026quot;子串不存在\\n\u0026quot;); } else { printf(\u0026quot;%s\\n\u0026quot;, ret); } return 0; }  strtok-分割字符串 char * strtok ( char * str, const char * sep );   sep参数是个字符串，定义了用作分隔符的字符集合。 第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记。 strtok函数找到str中的下一个标记，并将其用 \\0 结尾，返回一个指向这个标记的指针。 （注：strtok函数会改变被操作的字符串，所以在使用strtok函数切分的字符串一般都是临时拷贝的内容并且可修改。） strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置。 strtok函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标记。 如果字符串中不存在更多的标记，则返回 NULL 指针。  int main() { //192.168.31.121 . //192 168 31 121 - strtok ////ip地址的表达方式:点分十进制的表示方式 /*char arr[] = \u0026quot;123@234.@234\u0026quot;; char*p = \u0026quot;@.\u0026quot;;*/ //tgenkidu@qq.com @. //tgenkidu qq com char arr[] = \u0026quot;tgenkidu@qq.com\u0026quot;; char*p = \u0026quot;@.\u0026quot;; //tgenkidu\\0163.com char buf[1024] = { 0 }; strcpy(buf, arr);//将数据拷贝一份，处理arr数组的内容 //切割buf中的字符串 char* ret = NULL; for (ret = strtok(arr, p); ret != NULL; ret=strtok(NULL, p)) { printf(\u0026quot;%s\\n\u0026quot;, ret); } //char*ret = strtok(arr, p); //printf(\u0026quot;%s\\n\u0026quot;, ret); //ret = strtok(NULL, p); //printf(\u0026quot;%s\\n\u0026quot;, ret); //ret = strtok(NULL, p); //printf(\u0026quot;%s\\n\u0026quot;, ret); return 0; }  错误信息报告 strerror-获取错误信息 char * strerror ( int errnum );   返回错误码，所对应的错误信息。  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt;//必须包含的头文件 int main() { //错误码 错误信息 //0 - No error //1 - Operation not permitted //2 - No such file or directory //... //errno 是一个全局的错误码的变量 //当C语言的库函数在执行过程中，发生了错误，就会把对应的错误码，赋值到errno中 //char*str = strerror(errno); //printf(\u0026quot;%s\\n\u0026quot;, str); //打开文件 FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;r\u0026quot;); if (pf == NULL) { printf(\u0026quot;%s\\n\u0026quot;, strerror(errno)); } else { printf(\u0026quot;open file success\\n\u0026quot;); } return 0; }  字符操作 字符分类函数    函数 如果他的参数符合下列条件就返回真     iscntrl 任何控制字符   isspace 空白字符：空格‘ ’，换页‘\\f’，换行\u0026rsquo;\\n\u0026rsquo;，回车‘\\r’，制表符\u0026rsquo;\\t\u0026rsquo;或者垂直制表符\u0026rsquo;\\v\u0026rsquo;   isdigit 十进制数字 0~9   isxdigit 十六进制数字，包括所有十进制数字，小写字母a~f，大写字母A~F   islower 小写字母a~z   isupper 大写字母A~Z   isalpha 字母a~z或A~Z   isalnum 字母或者数字，a~z,A~Z,0~9   ispunct 标点符号，任何不属于数字或者字母的图形字符（可打印）   isgraph 任何图形字符   isprint 任何可打印字符，包括图形字符和空白字符    #include \u0026lt;ctype.h\u0026gt; int main() { char ch = '2'; //int ret = islower(ch);// int ret = isdigit(ch);// printf(\u0026quot;%d\\n\u0026quot;, ret); return 0; }  字符转换函数 int tolower ( int c ); int toupper ( int c );  #include \u0026lt;ctype.h\u0026gt; int main() { // char ch = tolower('q'); // char ch = toupper('q'); // putchar(ch); char arr[] = \u0026quot;I Am A Student\u0026quot;; int i = 0; while (arr[i]) { if (isupper(arr[i])) { arr[i] = tolower(arr[i]); } i++; } printf(\u0026quot;%s\\n\u0026quot;, arr);//i am a student return 0; }  内存操作函数 memcpy-内存拷贝 void * memcpy ( void * destination, const void * source, size_t num );   函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置。 这个函数在遇到 \u0026lsquo;\\0\u0026rsquo; 的时候并不会停下来。 如果source和destination有任何的重叠，复制的结果都是未定义的。  memcpy函数的模拟实现 void* my_memcpy(void* dest, const void* src, size_t num) { void* ret = dest; assert(dest != NULL); assert(src != NULL); while (num--) { *(char*)dest = *(char*)src; ++(char*)dest; ++(char*)src; } return ret; } int main() { int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; int i = 0; my_memcpy(arr+2, arr, 20); //memmove(arr + 2, arr, 20);//处理内存重叠的情况的 for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;%d \u0026quot;, arr[i]); } return 0; }  memmove-内存移动 void * memmove ( void * destination, const void * source, size_t num );   和memcpy的差别就是memmove函数处理的源内存块和目标内存块是可以重叠的。 如果源空间和目标空间出现重叠，就得使用memmove函数处理。  C语言标准：\n memcpy 只要处理 不重叠的内存拷贝就可以 - 60 - 100 memmove 处理重叠内存的拷贝 - 100  memmove函数的模拟实现 void* my_memmove(void* dest, const void*src, size_t count) { void* ret = dest; assert(dest != NULL); assert(src != NULL); if (dest \u0026lt; src) { //前-\u0026gt;后 while (count--) { *(char*)dest = *(char*)src; ++(char*)dest; ++(char*)src; } } else { //后-\u0026gt;前 while (count--) { *((char*)dest + count) = *((char*)src + count); } } return ret; } int main() { //int arr1[] = { 1, 2, 3, 4, 5 }; //int arr2[10] = { 0 }; //arr1中的数字拷贝到arr2中 //my_memcpy(arr2, arr1, sizeof(arr1)); // 1 2 1 2 3 4 5 8 9 10 int arr3[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; my_memmove(arr3, arr3+2, 20); //my_memcpy不能胜任重叠拷贝的 //my_memcpy(arr3+2, arr3, 20); //memmove可以胜任内存的重叠拷贝 //memmove(arr3+2, arr3, 20); //C语言标准说：memcpy函数可以拷贝不重叠的就可以了 //当下发现：VS2013/vs2017环境下的memcpy可以处理重叠拷贝 //memcpy(arr3+2, arr3, 20); return 0; }  memcmp-内存比较 int memcmp ( const void * ptr1, const void * ptr2, size_t num );   比较从ptr1和ptr2指针开始的num个字节  标准规定：\n第一个字段大于第二个字段，则返回大于0的数字 第一个字段等于第二个字段，则返回0 第一个字段小于第二个字段，则返回小于0的数字\n//01 00 00 00 02 00 00 00 03 00 00 00 ... //01 00 00 00 02 00 00 00 05 00 00 00 ... int arr1[] = { 1, 2, 3, 4, 5 }; int arr2[] = { 1, 2, 5, 4, 3 }; int ret = memcmp(arr1, arr2, 9);//9为字节数 printf(\u0026quot;%d\\n\u0026quot;, ret);  memset-内存设置 void * memset ( void * ptr, int value, size_t num );  //char arr[10] = \u0026quot;\u0026quot;; //memset(arr, '#', 10); int arr[10] = { 0 };//40个字节 //40 个字节 //01 01 01 01 01 01 01 01 01 01 00 00 00 00 00 ... memset(arr, 1, 10);//10为字节  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6656998d97c16f5c15c344220aa49540","permalink":"https://cytgenkidu.github.io/tutorial/c/11/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tutorial/c/11/","section":"tutorial","summary":"函数介绍  求字符串长度\nstrlen  长度不受限制的字符串函数\nstrcpy strcat strcmp  长度受限制的字符串函数介绍\nstrncpy strncat strncmp  字符串查找\nstrstr strtok  错误信息报告\nstrerror  字符操作\n 内存操作函数\nmemcpy memmove memset memcmp   求字符串长度 strlen-获取字符串长度 size_t strlen ( const char * str ); //size_t== unsigned int，是无符号的（ 易错 ）   字符串已经\u0026rsquo;\\0\u0026rsquo;作为结束标志， strlen函数返回的是在字符串中\u0026rsquo;\\0\u0026rsquo;前面出现的字符个数（不包含 \u0026lsquo;\\0\u0026rsquo; )。 参数指向的字符串必须要以 \u0026lsquo;\\0\u0026rsquo; 结束。  strlen函数的模拟实现  计数器方式 不能创建临时变量计数器 指针-指针的方式  int my_strlen(const char *str) //库里返回的是无符号数 { //法一：记数方式 int count = 0; while (*str !","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" 结构体 结构体类型的声明 结构的基础知识 结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。\n结构体的声明 struct tag { member-list;//成员列表 }variable-list ;  //声明一个结构体类型 //声明一个学生类型，是想过学生类型来创建学生变量（对象） //描述学生：属性-名字+电话+性别+年龄 struct Stu { char name[20];//名字 char tele[12];//电话 char sex[10];//性别 int age; } s4,s5,s6;//全局变量 struct Stu s3;//全局变量 int main() { //创建的结构体变量 struct Stu s1;//局部变量 struct Stu s2; return 0; }  特殊的声明 在声明结构的时候，可以不完全的声明。\n//匿名结构体类型，在声明的时候省略掉了结构体标签（tag） struct { int a; char c; }sa; //匿名结构体指针类型 struct { int a; char c; }* psa; int main() { psa = \u0026amp;sa; return 0; }  警告： 编译器会把上面的两个声明当成完全不同的两个类型。 所以是非法的。\n结构的自引用 //错误代码,sizeof(struct Node) struct Node { int data;//4 struct Node next; };  //正确代码，结构体的自引用 struct Node { int data;//4 struct Node* next;//4/8 };  //这种写法没问题 typedef struct Node { double d; int data;//4 struct Node* next;//4/8 }Node; //err // typedef Node // { // double d; // int data;//4 // Node* next;//4/8 // }Node; int main() { struct Node n1; Node n2; return 0; }  结构体变量的定义和初始化 struct T { double weight; short age; }; struct S { char c; struct T st; int a; double d; char arr[20]; }; int main() { //struct S s = {'c', 100, 3.14, \u0026quot;hello\u0026quot;};//初始化 struct S s = { 'c', {55.6, 30}, 100, 3.14, \u0026quot;hello\u0026quot; };//结构体嵌套初始化 printf(\u0026quot;%c %d %lf %s\\n\u0026quot;, s.c, s.a, s.d, s.arr); printf(\u0026quot;%lf\\n\u0026quot;, s.st.weight); return 0; }  结构体内存对齐 考点 如何计算？ 首先得掌握结构体的对齐规则：\n 第一个成员在与结构体变量偏移量为0的地址处。 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。 VS中默认的值为8 Linux gcc- 没有默认对齐数 该成员的大小就是对齐数 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所 有最大对齐数（含嵌套结构体的对齐数）的整数倍。  为什么存在内存对齐?\n大部分的参考资料都是如是说的：\n 平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。  总体来说： 结构体的内存对齐是拿空间来换取时间的做法。\n那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：\n让占用空间小的成员尽量集中在一起。  如下面代码S1和S2类型的成员一模一样，但是S1和S2所占空间的大小有了一些区别。\nstruct S1 { char c1;//1 int a;//4 char c2;//1 }; struct S2 { char c1;//1 char c2;//1 int a;//4 }; struct S3 { double d;//8 char c;//1 int i;//4 }; struct S4 { char c;//1 struct S3 s3;//16 double d;//8 }; int main() { struct S1 s1 = {0}; printf(\u0026quot;%d\\n\u0026quot;, sizeof(s1));//12 struct S2 s2 = { 0 }; printf(\u0026quot;%d\\n\u0026quot;, sizeof(s2));//8 struct S3 s3; printf(\u0026quot;%d\\n\u0026quot;, sizeof(s3));//16 struct S4 s4; printf(\u0026quot;%d\\n\u0026quot;, sizeof(s4));//32 return 0; }  修改默认对齐数 之前我们见过了 #pragma 这个预处理指令，这里我们再次使用，可以改变我们的默认对齐数。\n//设置默认对齐数位4 #pragma pack(4) struct S //12 不设置对齐数为16 { char c1;//1 //3 double d;//8 4 4 }; #pragma pack() //取消设置的默认对齐数 //设置默认对齐数位1 #pragma pack(1) struct S//9 不设置对对齐数为16 { char c1;//1 //3 double d;//8 4 4 }; #pragma pack() //取消设置的默认对齐数  写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明 考察： offsetof 宏的实现 。详细代码参考\noffsetof (type,member)//返回偏移量  #include \u0026lt;stddef.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; struct S { char c1; int a; char c2; }; #define OFFSETOF(struct_name, member_name) (int)\u0026amp;(((struct_name*)0)-\u0026gt;member_name) int main() { //offsetof(); printf(\u0026quot;%d\\n\u0026quot;, offsetof(struct S, c1));//0 printf(\u0026quot;%d\\n\u0026quot;, offsetof(struct S, a));//4 printf(\u0026quot;%d\\n\u0026quot;, offsetof(struct S, c2));//8 printf(\u0026quot;%d\\n\u0026quot;, OFFSETOF(struct S, c1) );//0 printf(\u0026quot;%d\\n\u0026quot;, OFFSETOF(struct S, a) );//4 printf(\u0026quot;%d\\n\u0026quot;, OFFSETOF(struct S, c2) );//8 return 0; }  结构体传参 struct S { int a; char c; double d; }; void Init(struct S* ps) { ps-\u0026gt;a = 100; ps-\u0026gt;c = 'w'; ps-\u0026gt;d = 3.14; } //传值 void Print1(struct S tmp) { printf(\u0026quot;%d %c %lf\\n\u0026quot;, tmp.a, tmp.c, tmp.d); } //传址 void Print2(const struct S* ps) { printf(\u0026quot;%d %c %lf\\n\u0026quot;, ps-\u0026gt;a, ps-\u0026gt;c, ps-\u0026gt;d); } int main() { struct S s = {0}; Init(\u0026amp;s); // Init(s);err//结构体传参的时候，要传结构体的地址。 Print1(s); Print2(\u0026amp;s); /*s.a = 100; s.c = 'w'; s.d = 3.14; printf(\u0026quot;%d\\n\u0026quot;, s.a);*/ return 0; }  print2 函数优于 print1 ,因为\n函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。  结论： 结构体传参的时候，要传结构体的地址。\n结构体实现位段（位段的填充\u0026amp;可移植性） 位段 位指的是二进制位 位段的声明和结构是类似的，有两个不同：\n1.位段的成员必须是 int、unsigned int 、signed int 、short char 位段成员类型必须一致 2.位段的成员名后边有一个冒号和一个数字。  struct S //位段类型 { int a : 2;//2个比特位，4个状态 int b : 5;//5个比特位 int c : 10; int d : 30; }; //2+5+10+30=47 //47bit - 6个字节*8 = 48bit int main() { struct S s; printf(\u0026quot;%d\\n\u0026quot;, sizeof(s));//8个字节 return 0; }  位段的内存分配  位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。  struct S { char a : 3; char b : 4; char c : 5; char d : 4; }; int main() { struct S s = {0}; s.a = 10; s.b = 20; s.c = 3; s.d = 4; return 0; }  位段的跨平台问题  int 位段被当成有符号数还是无符号数是不确定的。 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。  总结 跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。\n位段的应用 枚举 枚举顾名思义就是一一列举。\n把可能的取值一一列举。\n比如我们现实生活中：\n一周的星期一到星期日是有限的7天，可以一一列举。 性别有：男、女、保密，也可以一一列举。 月份有12个月，也可以一一列举 颜色也可以一一列举。  枚举类型的定义 取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值\n//枚举类型 enum Sex { //枚举的可能取值-常量 MALE, FEMALE =9,//初始值 SECRET }; enum Color { RED,//0 GREEN,//1 BLUE//2 } //c语言的源代码--预编译--\u0026gt;编译---链接---\u0026gt;可执行程序 #define RED 0 #define GREEN 1 #define BLUE 2 int main() { //enum Sex s = MALE; //enum Color c = 2;//int err //enum Color c = RED;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。 int color = RED; //printf(\u0026quot;%d %d %d\\n\u0026quot;, RED, GREEN, BLUE); //printf(\u0026quot;%d %d %d\\n\u0026quot;, MALE, FEMALE, SECRET); return 0; }  枚举的优点 我们可以使用 #define 定义常量，为什么非要使用枚举？ 枚举的优点：\n 增加代码的可读性和可维护性 和#define定义的标识符比较枚举有类型检查，更加严谨。 防止了命名污染（封装） 便于调试 使用方便，一次可以定义多个常量  枚举的大小 枚举变量的大小，实质是常数所占内存空间的大小（常数为int类型，当前主流的编译器中一般是32位机器和64位机器中int型都是4个字节），枚举类型所占内存大小也是这样。\nenum Sex { MALE, FEMALE, SECRET }; int main() { enum Sex s = MALE; printf(\u0026quot;%d\\n\u0026quot;, sizeof(s));//4 return 0; }  联合 联合类型的定义 联合也是一种特殊的自定义类型 这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）。\nunion Un { char c;//1 int i; //4 }; int main() { union Un u;//联合变量的定义 printf(\u0026quot;%d\\n\u0026quot;, sizeof(u));//4 printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;u);//00B6FD24 printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;(u.c));//00B6FD24 printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;(u.i));//00B6FD24 return 0; }  联合的特点 联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联合至少得有 能力保存最大的那个成员）。\n联合大小的计算 联合的大小至少是最大成员的大小。 当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。\nunion Un { int a;//4 8 4 char arr[5];//5 1 8 1 }; int main() { union Un u; printf(\u0026quot;%d\\n\u0026quot;, sizeof(u));//8 return 0; }  判断当前计算机的大小端存储 int a = 0x11223344; //低地址--------------------\u0026gt;高地址 //....[][][][][11][22][33][44][][][][][][][]... 大端字节序存储模式 //....[][][][][44][33][22][11][][][][][][][]... 小端字节序存储模式 //讨论一个数据，放在内存中的存放的字节顺序 //大小端字节序问题  // int check_sys() // { // int a = 1; // //返回1，表示小端 // //返回0，表示大端 // return *(char*)\u0026amp;a; // } int check_sys() { union //匿名结构体就用一次 { char c; int i; }u; u.i = 1;// //返回1，表示小端 //返回0，表示大端 return u.c; } int main() { int ret = check_sys(); if (1 == ret) { printf(\u0026quot;小端\\n\u0026quot;); } else { printf(\u0026quot;大端\\n\u0026quot;); } return 0; }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9577123ca583fcc20747672d4d1677a2","permalink":"https://cytgenkidu.github.io/tutorial/c/12/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tutorial/c/12/","section":"tutorial","summary":"结构体 结构体类型的声明 结构的基础知识 结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。\n结构体的声明 struct tag { member-list;//成员列表 }variable-list ;  //声明一个结构体类型 //声明一个学生类型，是想过学生类型来创建学生变量（对象） //描述学生：属性-名字+电话+性别+年龄 struct Stu { char name[20];//名字 char tele[12];//电话 char sex[10];//性别 int age; } s4,s5,s6;//全局变量 struct Stu s3;//全局变量 int main() { //创建的结构体变量 struct Stu s1;//局部变量 struct Stu s2; return 0; }  特殊的声明 在声明结构的时候，可以不完全的声明。\n//匿名结构体类型，在声明的时候省略掉了结构体标签（tag） struct { int a; char c; }sa; //匿名结构体指针类型 struct { int a; char c; }* psa; int main() { psa = \u0026amp;sa; return 0; }  警告： 编译器会把上面的两个声明当成完全不同的两个类型。 所以是非法的。","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" 为什么存在动态内存分配 当前已经知道的内存的使用方式： 1. 创建一个变量 int a=10;//局部变量 - 栈区 int g_a=10;//全局变量 - 静态区 2. 创建一个数组 int arr[10];//局部/全局\n但是上述的开辟空间的方式有两个特点： 1. 空间开辟大小是固定的。 2. 数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。\n但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。 这时候就只能试试动态存开辟了。\n动态内存函数的介绍 malloc-动态内存开辟 和 free-动态内存的释放和回收 void* malloc (size_t size);//动态内存开辟的函数   这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。 如果开辟成功，则返回一个指向开辟好空间的指针。 如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。 返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。 如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。  void free (void* ptr);//动态内存的释放和回收的函数   free函数用来释放动态开辟的内存。 如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。 如果参数 ptr 是NULL指针，则函数什么事都不做。  malloc和free都声明在 stdlib.h 头文件中。\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { //向内存申请10个整形的空间 //int* p = (int*)malloc(INT_MAX); int* p = (int*)malloc(10*sizeof(int));//动态内存开辟 if (p == NULL) { //打印错误原因的一个方式 printf(\u0026quot;%s\\n\u0026quot;, strerror(errno)); } else { //正常使用空间 int i = 0; for (i = 0; i \u0026lt; 10; i++) { *(p + i) = i; } for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;%d \u0026quot;, *(p + i)); } } //当动态申请的空间不再使用的时候 //就应该还给操作系统 free(p);//释放ptr所指向的动态内存 p = NULL;//必要 return 0; }  calloc-动态内存分配 void* calloc (size_t num, size_t size);   函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。 与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。  #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { //malloc(10*sizeof(int)) int*p = (int*)calloc(10, sizeof(int)); if (p == NULL) { printf(\u0026quot;%s\\n\u0026quot;, strerror(errno)); } else { int i = 0; for (i = 0; i \u0026lt; 10; i++) { *(p + i) = i; } for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;%d \u0026quot;, *(p + i)); } } //释放空间 //free函数是用来释放动态开辟的空间的 free(p); p = NULL; return 0; }  realloc-重新分配内存块  realloc函数调整动态开辟内存空间的大小。 有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时候内存， 我们一定会对内存的大小做灵活的调整。那 realloc 函数就可以做到对动态开辟内存大小的调整。  void* realloc (void* ptr, size_t size); //int *p = realloc(NULL, 40);//malloc(40)   ptr 是要调整的内存地址 size 调整之后新大小 返回值为调整之后的内存起始位置。 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到 新 的空间。\n realloc使用的注意事项：\n 如果p指向的空间之后有足够的内存空间可以追加，则直接追加，后返回p. 如果p指向的空间之后没有足够的内存空间可以追加，则realloc函数会重新找一个新的内存区域开辟一块满足需求的空间，并且把原来内存中的数据拷贝回来，释放旧的内存空间,最后返回新开辟的内存空间地址. 得用一个新的变量来接受realloc函数的返回值.   #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { int *p = (int*)malloc(20); if (p == NULL) { printf(\u0026quot;%s\\n\u0026quot;, strerror(errno)); } else { int i = 0; for (i = 0; i \u0026lt; 5; i++) { *(p + i) = i; } } //就是在使用malloc开辟的20个字节空间 //假设这里，20个自字节不能满足我们的使用了,希望我们能够有40个字节的空间 //这里就可以使用realloc来调整动态开辟的内存 int*ptr = realloc(p, 40); //int*ptr = realloc(p, INT_MAX);//会开辟失败 if (ptr != NULL) { p = ptr; int i = 0; for (i = 5; i \u0026lt; 10; i++) { *(p + i) = i; } for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;%d \u0026quot;, *(p + i)); } } //释放内存 free(p); p = NULL; return 0; }  常见的动态内存错误 对NULL指针的解引用操作 int *p = (int*)malloc(40); //万一malloc失败了，p就被赋值为NULL *p = 0;//err int i = 0; for (i = 0; i \u0026lt; 10; i++) { *(p + i) = i;//err } free(p); p = NULL;  对动态开辟空间的越界访问 int *p = (int*)malloc(5 * sizeof(int)); if (p == NULL) { return 0; } else { int i = 0; for (i = 0; i \u0026lt; 10; i++)//err 越界 { *(p + i) = i; } } // free(p); p = NULL;  对非动态开辟内存使用free释放 int a = 10; int* p = \u0026amp;a; *p = 20; free(p);//err 对非动态开辟内存使用free释放 p = NULL;  使用free释放一块动态开辟内存的一部分 int*p = (int*)malloc(40); if (p == NULL) { return 0; } int i = 0; for (i = 0; i \u0026lt; 5; i++) { *p++ = i; } //回收空间 // 使用free释放动态开辟内存的一部分 free(p); p =NULL;  对同一块动态内存多次释放 [谁申请谁回收] int *p = (int*)malloc(40); if (p == NULL) { return 0; } //使用 //释放 free(p); p = NULL; free(p);  动态开辟内存忘记释放（内存泄漏） while (1) { malloc(1);//会导致内存消耗 }  忘记释放不再使用的动态开辟的空间会造成内存泄漏。 切记： 动态开辟的空间一定要释放，并且正确释放。\n几个经典的笔试题 题目1 void GetMemory(char *p) { p = (char *)malloc(100);//没有free,存在内存泄露的可能 } void Test(void) { char *str = NULL; GetMemory(str); strcpy(str, \u0026quot;hello world\u0026quot;); printf(str);//==printf(\u0026quot;%s\u0026quot;,str); }  请问运行Test 函数会有什么样的结果？程序崩溃\n改正1\nvoid GetMemory(char **p) { *p = (char *)malloc(100); } void Test(void) { char *str = NULL; GetMemory(\u0026amp;str); strcpy(str, \u0026quot;hello world\u0026quot;); printf(str); free(str); str = NULL; }  改正2\nchar* GetMemory(char *p) { p = (char *)malloc(100); return p; } void Test(void) { char *str = NULL; str = GetMemory(str); strcpy(str, \u0026quot;hello world\u0026quot;); printf(str); free(str); str = NULL; }  题目2 char *GetMemory(void) { char p[] = \u0026quot;hello world\u0026quot;; return p; } void Test(void) { char *str = NULL; str = GetMemory(); printf(str); } int main() { Test(); return 0; }  请问运行Test 函数会有什么样的结果？打印随机值，非法访问内存\n题目3 void GetMemory(char **p, int num) { *p = (char *)malloc(num); } void Test(void) { char *str = NULL; GetMemory(\u0026amp;str, 100); strcpy(str, \u0026quot;hello\u0026quot;); printf(str); str = NULL; }  请问运行Test 函数会有什么样的结果？打印hello，但存在内存泄露\n改正\nvoid GetMemory(char **p, int num) { *p = (char *)malloc(num); } void Test(void) { char *str = NULL; GetMemory(\u0026amp;str, 100); strcpy(str, \u0026quot;hello\u0026quot;); printf(str); //忘记释放动态开辟的内存，会导致内存泄露 free(str); str = NULL; }  题目4 void Test(void) { char *str = (char *)malloc(100); strcpy(str, \u0026quot;hello\u0026quot;); free(str); if (str != NULL) { strcpy(str, \u0026quot;world\u0026quot;); printf(str); } }  请问运行Test 函数会有什么样的结果？打印world,非法访问内存\n改正\nvoid Test(void) { char *str = (char *)malloc(100); strcpy(str, \u0026quot;hello\u0026quot;); free(str);//free释放str指向的空间后，并不会把str置为NULL str = NULL; if (str != NULL) { strcpy(str, \u0026quot;world\u0026quot;); printf(str); } }  C/C++程序的内存开辟  栈区（stack）：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。 堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。 数据段（静态区）（static）存放全局变量、静态数据。程序结束后由系统释放。 代码段：存放函数体（类成员函数和全局函数）的二进制代码。  有了这幅图，我们就可以更好的理解在《C语言初识》中讲的static关键字修饰局部变量的例子了。\n 实际上普通的局部变量是在栈区分配空间的，栈区的特点是在上面创建的变量出了作用域就销毁。 但是被static修饰的变量存放在数据段（静态区），数据段的特点是在上面创建的变量，直到程序结束才销毁 所以生命周期变长。  柔性数组 也许你从来没有听说过柔性数组（flexible array）这个概念，但是它确实是存在的。 C99 中，结构中的最后一个元素允许是未知大小的数组，这就叫做『柔性数组』成员。\n如：\nstruct S { int n; int arr[];//未知大小的,//柔性数组成员 };  或\nstruct S { int n; int arr[0];//未知大小的-柔性数组成员-数组的大小是可以调整的 };  柔性数组的特点  结构中的柔性数组成员前面必须至少一个其他成员。 sizeof 返回的这种结构大小不包括柔性数组的内存。 包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。  柔性数组的使用 代码1\n//柔性数组，开辟连续空间，空间上也更节省。内存利用率高 struct S { int n; int arr[0];//未知大小的-柔性数组成员-数组的大小是可以调整的 }; int main() { //struct S s; //printf(\u0026quot;%d\\n\u0026quot;, sizeof(s));//4 struct S* ps = (struct S*)malloc(sizeof(struct S)+5*sizeof(int));//连续的空间 ps-\u0026gt;n = 100; int i = 0; for (i = 0; i \u0026lt; 5; i++) { ps-\u0026gt;arr[i] = i;//0 1 2 3 4 } struct S* ptr = realloc(ps, 44); if (ptr != NULL) { ps = ptr; } for (i = 5; i \u0026lt; 10; i++) { ps-\u0026gt;arr[i] = i; } for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;%d \u0026quot;, ps-\u0026gt;arr[i]); } //释放 free(ps); ps = NULL; return 0; }  代码2\nstruct S { int n; int* arr; }; int main() { struct S*ps = (struct S*)malloc(sizeof(struct S)); ps-\u0026gt;arr = malloc(5 * sizeof(int)); int i = 0; for (i = 0; i \u0026lt; 5; i++) { ps-\u0026gt;arr[i] = i; } for (i = 0; i \u0026lt; 5; i++) { printf(\u0026quot;%d \u0026quot;, ps-\u0026gt;arr[i]); } //调整大小 int *ptr = realloc(ps-\u0026gt;arr, 10 * sizeof(int)); if (ptr != NULL) { ps-\u0026gt;arr = ptr; } for (i = 5; i \u0026lt; 10; i++) { ps-\u0026gt;arr[i] = i; } for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;%d \u0026quot;, ps-\u0026gt;arr[i]); } //释放内存 free(ps-\u0026gt;arr); ps-\u0026gt;arr = NULL; free(ps);//两次free容易出错 ps = NULL; return 0; }  上述 代码1 和 代码2 可以完成同样的功能，但是 方法1 的实现有两个好处：\n 第一个好处是：方便内存释放\n如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉.\n 第二个好处是：有利于访问速度\n连续的内存有益于提高访问速度，也有益于减少内存碎片。\n 第三个好处是：有益于减少内存碎片\n若使用指针的结构体开辟的空间是不连续的，这样多次使用之后，就会造成许多内存碎片。有益于减少内存碎片。\n  扩展\nC语言结构体里的成员数组和指针\n练习 找出单身狗\n一个数组中只有两个数字是出现一次，其他所有数字都出现了两次\n编写一个函数找出这两个只出现一次的数字。\n法一 #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void find_num(int arr[], int sz) { int i, j, k = 0; for (i = 0; i \u0026lt; sz; i++) { k = 0; for (j = 0; j \u0026lt; sz; j++) { if (arr[j] == arr[i]) k++; } if (k == 1) printf(\u0026quot;单数为 %d\\n\u0026quot;, arr[i]); } printf(\u0026quot;\\n\u0026quot;); } int main() { int arr[] = { 1, 2, 3, 4, 1, 2, 3, 5 }; int sz = sizeof(arr) / sizeof(arr[0]); find_num(arr, sz); system(\u0026quot;pause\u0026quot;); return 0; }  法二：异或 异或运算相同为0，相异为1，则： a ^ a = 0; (1) 0 ^ a = a; (2) a ^ b ^ a = b; (3) 1 ^ 2 ^ 1 = 2 2 ^ 2 = 0 0 ^ 3 = 3  将数组里面所有的数字异或一遍，最终得到的那个数字就是只出现一次的数。\nvoid FindAppearOnce(int arr[], int len, int* pn1, int* pn2) { int num = 0;//记录整组异或的结果，即两个一次出现的数异或的结果 int i = 0; int k = 1; for (i = 0; i \u0026lt; len; i++) //得出整组异或的结果，即两个一次出现的数异或的结果 { num = num ^ arr[i]; } while (num \u0026amp; 1 != 1) //找出异或结果中第一个为1的bit位 { k++; num = num \u0026gt;\u0026gt; 1; } for (i = 0; i \u0026lt; len; i++)//将原数组分为两组，分别求出每组中出现一次的数字 { int k_bit = (arr[i] \u0026gt;\u0026gt; (k - 1)) \u0026amp; 1; //arr[i]第k位的值 if (k_bit == 1) { *pn1 = *pn1^arr[i]; } else { *pn2 = *pn2^arr[i]; } } } int main() { int num1 = 0; int num2 = 0; int arr[] = { 1, 2, 3, 4, 5, 1, 2, 3, 4, 8 }; int sz = sizeof(arr) / sizeof(arr[0]); FindAppearOnce(arr, sz, \u0026amp;num1, \u0026amp;num2); printf(\u0026quot;%d,%d\\n\u0026quot;, num1, num2); system(\u0026quot;pause\u0026quot;); return 0; }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ce83ba132e457b2f7cdfa72715f50922","permalink":"https://cytgenkidu.github.io/tutorial/c/13/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tutorial/c/13/","section":"tutorial","summary":"为什么存在动态内存分配 当前已经知道的内存的使用方式： 1. 创建一个变量 int a=10;//局部变量 - 栈区 int g_a=10;//全局变量 - 静态区 2. 创建一个数组 int arr[10];//局部/全局\n但是上述的开辟空间的方式有两个特点： 1. 空间开辟大小是固定的。 2. 数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。\n但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。 这时候就只能试试动态存开辟了。\n动态内存函数的介绍 malloc-动态内存开辟 和 free-动态内存的释放和回收 void* malloc (size_t size);//动态内存开辟的函数   这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。 如果开辟成功，则返回一个指向开辟好空间的指针。 如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。 返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。 如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。  void free (void* ptr);//动态内存的释放和回收的函数   free函数用来释放动态开辟的内存。 如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。 如果参数 ptr 是NULL指针，则函数什么事都不做。  malloc和free都声明在 stdlib.h 头文件中。\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { //向内存申请10个整形的空间 //int* p = (int*)malloc(INT_MAX); int* p = (int*)malloc(10*sizeof(int));//动态内存开辟 if (p == NULL) { //打印错误原因的一个方式 printf(\u0026quot;%s\\n\u0026quot;, strerror(errno)); } else { //正常使用空间 int i = 0; for (i = 0; i \u0026lt; 10; i++) { *(p + i) = i; } for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;%d \u0026quot;, *(p + i)); } } //当动态申请的空间不再使用的时候 //就应该还给操作系统 free(p);//释放ptr所指向的动态内存 p = NULL;//必要 return 0; }  calloc-动态内存分配 void* calloc (size_t num, size_t size);   函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。 与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。  #include \u0026lt;stdlib.","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" 什么是文件 磁盘上的文件是文件。\n但是在程序设计中，我们一般谈的文件有两种：程序文件、数据文件\n程序文件 包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。\n数据文件 文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。\n本章讨论的是数据文件。\n在以前各章所处理数据的输入输出都是以终端为对象的，即从终端的键盘输入数据，运行结果显示到显示器上。\n其实有时候我们会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使用，这里处理的就是磁盘上文件。\n文件名 一个文件要有一个唯一的文件标识，以便用户识别和引用。\n文件名包含3部分：文件路径+文件名主干+文件后缀\n例如：c:\\code\\test.txt 为了方便起见，文件标识常被称为文件名。\n文件类型 根据数据的组织形式，数据文件被称为文本文件或者二进制文件。\n数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是文本文件。\n一个数据在内存中是怎么存储的呢？\n字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。\n如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占用5个字节（每个字符一个字节），而二进制形式输出，则在磁盘上只占4个字节（VS2017测试）。\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10000; FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;wb\u0026quot;); fwrite(\u0026amp;a, 4, 1, pf);//二进制的形式写到文件中 fclose(pf); pf = NULL; return 0; }  文件缓冲区 ANSIC 标准采用“缓冲文件系统”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。\n文件指针 缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。\n每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是有系统声明的，取名FILE.\nstruct _iobuf { char *_ptr; int _cnt; char *_base; int _flag; int _file; int _charbuf; int _bufsiz; char *_tmpfname; }; typedef struct _iobuf FILE;  不同的C编译器的FILE类型包含的内容不完全相同，但是大同小异。\n每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息，使用者不必关心细节。\n一般都是通过一个FILE的指针来维护这个FILE结构的变量，这样使用起来更加方便。 下面我们可以创建一个FILE*的指针变量:\nFILE* pf;//文件指针变量  定义pf是一个指向FILE类型数据的指针变量。可以使pf指向某个文件的文件信息区（是一个结构体变量）。通过该文件信息区中的信息就能够访问该文件。也就是说，通过文件指针变量能够找到与它关联的文件。 比如：\n文件的打开和关闭 文件在读写之前应该先打开文件，在使用结束之后应该关闭文件。\n在编写程序的时候，在打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指针和文件的关系。\nANSIC 规定使用fopen函数来打开文件，fclose来关闭文件。\nFILE * fopen ( const char * filename, const char * mode ); int fclose ( FILE * stream );  打开方式如下：\n   使用方式 含义 如果指定文件不存在     \u0026ldquo;r”（只读） 为了输入数据，打开一个已经存在的文本文件 出错   \u0026ldquo;w”（只写） 为了输出数据，打开一个文本文件 建立一个新的文件   \u0026ldquo;a”（追加） 向文本文件尾添加数据 出错   \u0026ldquo;rb”（只读） 为了输入数据，打开一个二进制文件 出错   \u0026ldquo;wb”（只写） 为了输出数据，打开一个二进制文件 建立一个新的文件   \u0026ldquo;ab”（追加） 向一个二进制文件尾添加数据 出错   \u0026ldquo;r+”（读写） 为了读和写，打开一个文本文件 出错   \u0026ldquo;w+”（读写） 为了读和写，建议一个新的文件 建立一个新的文件   \u0026ldquo;a+”（读写） 打开一个文件，在文件尾进行读写 建立一个新的文件   \u0026ldquo;rb+”（读写） 为了读和写打开一个二进制文件 出错   \u0026ldquo;wb+”（读写） 为了读和写，新建一个新的二进制文件 建立一个新的文件   \u0026ldquo;ab+”（读写） 打开一个二进制文件，在文件尾进行读和写 建立一个新的文件    #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { //打开文件test.txt //相对路径 //.. 表示上一级路径 //. 表示当前路径 //fopen(\u0026quot;../../test.txt\u0026quot;, \u0026quot;r\u0026quot;) //fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;r\u0026quot;); //绝对路径的写法 //fopen(\u0026quot;D:\\\\A-yan\\\\C\\Project1\\\\Project1\\\\test.txt\u0026quot;, \u0026quot;r\u0026quot;); FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;w\u0026quot;); if(pf == NULL) { printf(\u0026quot;%s\\n\u0026quot;, strerror(errno)); return 0; } //打开成功 //读文件 //关闭文件 fclose(pf); pf = NULL; return 0; }  文件的顺序读写    功能 函数名 适用于     字符输入函数 fgetc 所有输入流   字符输出函数 fputc 所有输出流   文本行输入函数 fgets 所有输入流   文本行输出函数 fputs 所有输出流   格式化输入函数 fscanf 所有输入流   格式化输出函数 fprintf 所有输出流   二进制输入 fread 文件   二进制输出 fwrite 文件    对比一组函数 scanf/fscanf/sscanf printf/fprintf/sprintf  scanf/printf 是针对标准输入流/标准输出流 格式化输入/输出语句 fscanf/fprintf 是针对所有输入流/所有输出流 格式化输入/输出语句 sscanf/sprintf 是从字符串中读取格式化数据/把格式化数据输出成（存储成）字符串  fputc FILE* pfWrite = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;w\u0026quot;); if(pfWrite == NULL) { printf(\u0026quot;%s\\n\u0026quot;, strerror(errno)); return 0; } //写文件 fputc('H', pfWrite); fputc('I', pfWrite); fputc('!', pfWrite); //关闭文件 fclose(pfWrite); pfWrite = NULL;  fgetc FILE* pfRead = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;r\u0026quot;); if(pfRead == NULL) { printf(\u0026quot;%s\\n\u0026quot;, strerror(errno)); return 0; } //读文件 printf(\u0026quot;%c\u0026quot;, fgetc(pfRead));//b printf(\u0026quot;%c\u0026quot;, fgetc(pfRead));//i printf(\u0026quot;%c\u0026quot;, fgetc(pfRead));//t //关闭文件 fclose(pfRead); pfRead = NULL;  注：\n从键盘输入、输出到屏幕. 键盘\u0026amp;屏幕都是外部设备\n键盘-标准输入设备- stdin 屏幕-标准输出设备- stdout  是一个程序默认打开的两个流设备\nstdin FILE* stdout FILE* stderr FILE*  fgets int ch = fgetc(stdin); fputc(ch, stdout);  char buf[1024] = { 0 }; FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;r\u0026quot;); if (pf == NULL) { return 0; } //读文件 fgets(buf, 1024, pf); puts(buf);//自动换行 ==printf(\u0026quot;%s\\n\u0026quot;, buf); fclose(pf); pf = NULL;  fputs char buf[1024] = { 0 }; FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;w\u0026quot;); if (pf == NULL) { return 0; } //写文件 fputs(\u0026quot;hello\\n\u0026quot;, pf); fputs(\u0026quot;world\\n\u0026quot;, pf); fclose(pf); pf = NULL;  fscanf struct S { int n; float score; char arr[10]; }; int main() { struct S s = {0}; FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;r\u0026quot;); if (pf == NULL) { return 0; } //格式化的输入数据 fscanf(pf, \u0026quot;%d %f %s\u0026quot;, \u0026amp;(s.n), \u0026amp;(s.score), s.arr); printf(\u0026quot;%d %f %s\\n\u0026quot;, s.n, s.score, s.arr); fclose(pf); pf = NULL; return 0; }  fprintf struct S { int n; float score; char arr[10]; }; int main() { struct S s = { 100, 3.14f, \u0026quot;bit\u0026quot; }; FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;w\u0026quot;); if (pf == NULL) { return 0; } //格式化的形式写文件 fprintf(pf, \u0026quot;%d %f %s\u0026quot;, s.n, s.score, s.arr); fclose(pf); pf = NULL; return 0; }  sscanf 和 sprintf struct S { int n; float score; char arr[10]; }; int main() { struct S s = { 100, 3.14f, \u0026quot;abcdef\u0026quot; }; struct S tmp = {0}; char buf[1024] = { 0 }; //把格式化的数据转换成字符串存储到buf sprintf(buf, \u0026quot;%d %f %s\u0026quot;, s.n, s.score, s.arr); //printf(\u0026quot;%s\\n\u0026quot;, buf); //从buf中读取格式化的数据到tmp中 sscanf(buf, \u0026quot;%d %f %s\u0026quot;, \u0026amp;(tmp.n), \u0026amp;(tmp.score), tmp.arr); printf(\u0026quot;%d %f %s\\n\u0026quot;, tmp.n, tmp.score, tmp.arr); return 0; }  fwrite struct S { char name[20]; int age; double score; }; int main() { struct S s = { \u0026quot;张三\u0026quot;, 20, 55.6 }; FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;wb\u0026quot;); if (pf == NULL) { return 0; } //二进制的形式写文件 fwrite(\u0026amp;s, sizeof(struct S), 1, pf); fclose(pf); pf = NULL; return 0; }  fread struct S { char name[20]; int age; double score; }; int main() { //struct S s = { \u0026quot;张三\u0026quot;, 20, 55.6 }; struct S tmp = { 0 }; FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;rb\u0026quot;); if (pf == NULL) { return 0; } //二进制的形式都文件 fread(\u0026amp;tmp, sizeof(struct S), 1, pf); printf(\u0026quot;%s %d %lf\\n\u0026quot;, tmp.name, tmp.age, tmp.score); fclose(pf); pf = NULL; return 0; }  文件的随机读写 fseek 根据文件指针的位置和偏移量来定位文件指针。\nint fseek ( FILE * stream, long int offset, int origin ); //offset 偏移量 // origin 文件指针当前位置     Constant Reference position     SEEK_SET 文件开头   SEEK_CUR 文件指点的当前位置   SEEK_END 文件结束    FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;r\u0026quot;);//abcdefg if (pf == NULL) { return 0; } //1.定位文件指针 fseek(pf, -2, SEEK_END);//f //2.读取文件 int ch = fgetc(pf); printf(\u0026quot;%c\\n\u0026quot;, ch); fclose(pf); pf = NULL;  ftell 返回文件指针相对于起始位置的偏移量\nlong int ftell ( FILE * stream );  FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;r\u0026quot;);//abcdef if (pf == NULL) { return 0; } //1.定位文件指针 //fseek(pf, -2, SEEK_END); int ch = fgetc(pf);// printf(\u0026quot;%c\\n\u0026quot;, ch);//a int pos = ftell(pf);// printf(\u0026quot;%d\\n\u0026quot;, pos);//1 fclose(pf); pf = NULL;  rewind 让文件指针的位置回到文件的起始位置\nFILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;r\u0026quot;);//abcdefg if (pf == NULL) { return 0; } //1.定位文件指针 //fseek(pf, -2, SEEK_END); int ch = fgetc(pf); printf(\u0026quot;%c\\n\u0026quot;, ch);//a rewind(pf); ch = fgetc(pf); printf(\u0026quot;%c\\n\u0026quot;, ch);//a fclose(pf); pf = NULL;  文件结束的判定 被错误使用的 feof //EOF //feof();//EOF - end of file - 文件结束标志 FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;r\u0026quot;);//空文件 if (pf == NULL) return 0; int ch = fgetc(pf); printf(\u0026quot;%d\\n\u0026quot;, ch);//-1 fclose(pf); pf = NULL;  牢记：在文件读取过程中，不能用feof函数的返回值直接用来判断文件的是否结束。 而是应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束。\n 文本文件读取是否结束，判断返回值是否为EOF （fgetc），或者NULL（fgets）\n例如：\nfgetc判断是否为EOF. fgets判断返回值是否为NULL.  二进制文件的读取结束判断，判断返回值是否小于实际要读的个数。\n例如：\nfread判断返回值是否小于实际要读的个数。   正确的使用\n文本文件的例子：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { //strerror - 把错误码对应的错误信息的字符串地址返回 int c; // 注意：int，非char，要求处理EOF FILE* fp = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;r\u0026quot;); if(!fp) { perror(\u0026quot;File opening failed\u0026quot;); return EXIT_FAILURE; } //fgetc 当读取失败的时候或者遇到文件结束的时候，都会返回EOF while ((c = fgetc(fp)) != EOF) // 标准C I/O读取文件循环 { putchar(c); } //判断是什么原因结束的 if (ferror(fp)) puts(\u0026quot;I/O error when reading\u0026quot;); else if (feof(fp)) puts(\u0026quot;End of file reached successfully\u0026quot;); fclose(fp); }  二进制文件的例子：\n#include \u0026lt;stdio.h\u0026gt; enum { SIZE = 5 }; int main(void) { double a[SIZE] = {1.0, 2.0, 3.0, 4.0, 5.0}; double b = 0.0; size_t ret_code = 0; FILE *fp = fopen(\u0026quot;test.bin\u0026quot;, \u0026quot;wb\u0026quot;); // 必须用二进制模式 fwrite(a, sizeof(*a), SIZE, fp); // 写 double 的数组 fclose(fp); fp = fopen(\u0026quot;test.bin\u0026quot;, \u0026quot;rb\u0026quot;); // 读 double 的数组 while ((ret_code = fread(\u0026amp;b, sizeof(double), 1, fp)) \u0026gt;= 1) { printf(\u0026quot;%lf\\n\u0026quot;, b); } if (feof(fp)) printf(\u0026quot;Error reading test.bin: unexpected end of file\\n\u0026quot;); else if (ferror(fp)) { perror(\u0026quot;Error reading test.bin\u0026quot;); } fclose(fp); fp = NULL; }  参考链接：https://zh.cppreference.com/w/c\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2ed92e0dfe46d395f966f0519b65add5","permalink":"https://cytgenkidu.github.io/tutorial/c/14/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tutorial/c/14/","section":"tutorial","summary":"什么是文件 磁盘上的文件是文件。\n但是在程序设计中，我们一般谈的文件有两种：程序文件、数据文件\n程序文件 包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。\n数据文件 文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。\n本章讨论的是数据文件。\n在以前各章所处理数据的输入输出都是以终端为对象的，即从终端的键盘输入数据，运行结果显示到显示器上。\n其实有时候我们会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使用，这里处理的就是磁盘上文件。\n文件名 一个文件要有一个唯一的文件标识，以便用户识别和引用。\n文件名包含3部分：文件路径+文件名主干+文件后缀\n例如：c:\\code\\test.txt 为了方便起见，文件标识常被称为文件名。\n文件类型 根据数据的组织形式，数据文件被称为文本文件或者二进制文件。\n数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是文本文件。\n一个数据在内存中是怎么存储的呢？\n字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。\n如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占用5个字节（每个字符一个字节），而二进制形式输出，则在磁盘上只占4个字节（VS2017测试）。\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10000; FILE* pf = fopen(\u0026quot;test.txt\u0026quot;, \u0026quot;wb\u0026quot;); fwrite(\u0026amp;a, 4, 1, pf);//二进制的形式写到文件中 fclose(pf); pf = NULL; return 0; }  文件缓冲区 ANSIC 标准采用“缓冲文件系统”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。\n文件指针 缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。\n每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是有系统声明的，取名FILE.\nstruct _iobuf { char *_ptr; int _cnt; char *_base; int _flag; int _file; int _charbuf; int _bufsiz; char *_tmpfname; }; typedef struct _iobuf FILE;  不同的C编译器的FILE类型包含的内容不完全相同，但是大同小异。","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":" 程序的翻译环境和执行环境 在ANSI C的任何一种实现中，存在两个不同的环境。\n第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。 第2种是执行环境，它用于实际执行代码。  详解：C语言程序的编译+链接 翻译环境  组成一个程序的每个源文件通过编译过程分别转换成目标代码（object code）。 每个目标文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序。 链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。  编译本身也分为几个阶段  预处理 选项 gcc -E test.c -o test.i 预处理完成之后就停下来，预处理之后产生的结果都放在test.i文件中。 编译 选项 gcc -S test.c 编译完成之后就停下来，结果保存在test.s中。 汇编 gcc -c test.c 汇编完成之后就停下来，结果保存在test.o中。  运行环境 程序执行的过程：\n 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。 程序的执行便开始。接着便调用main函数。 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。 终止程序。正常终止main函数；也有可能是意外终止。  预编译（预处理）详解 预定义符号 __FILE__ //进行编译的源文件 __LINE__ //文件当前的行号 __DATE__ //文件被编译的日期 __TIME__ //文件被编译的时间 __STDC__ //如果编译器遵循ANSI C，其值为1，否则未定义  printf(\u0026quot;%s\\n\u0026quot;, __FILE__); printf(\u0026quot;%d\\n\u0026quot;, __LINE__); printf(\u0026quot;%s\\n\u0026quot;, __DATE__); printf(\u0026quot;%s\\n\u0026quot;, __TIME__);  应用-写日志log\n//写日志 int i = 0; int arr[10] = { 0 }; FILE* pf = fopen(\u0026quot;log.txt\u0026quot;, \u0026quot;w\u0026quot;); for (i = 0; i \u0026lt; 10; i++) { arr[i] = i; fprintf(pf, \u0026quot;file:%s line:%d date:%s time:%s i=%d\\n\u0026quot;, __FILE__, __LINE__, __DATE__, __TIME__, i); //printf(\u0026quot;%s\\n\u0026quot;, __FUNCTION__);//获得方法 } fclose(pf); pf = NULL; for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;%d \u0026quot;, arr[i]); }  #define #define 定义标识符 语法： #define name stuff\n#define name stuff #define MAX 1000 #define reg register //为 register这个关键字，创建一个简短的名字 #define do_forever for(;;) //用更形象的符号来替换一种实现 #define CASE break;case //在写case语句的时候自动把 break写上。 // 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。 #define DEBUG_PRINT printf(\u0026quot;file:%s\\tline:%d\\t \\ date:%s\\ttime:%s\\n\u0026quot; ,\\ __FILE__,__LINE__ , \\ __DATE__,__TIME__ )  define 建议不要加上 ; ,这样容易导致问题。\n#define 定义宏 #define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（define macro）。\n下面是宏的申明方式：\n#define name( parament-list ) stuff 其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在 stuff中。  注意： 参数列表的左括号必须与name紧邻。 如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分。\n#define SQUARE(X) ((X)*(X)) int main() { //int ret = SQUARE(5); ////int ret = 5* 5; //printf(\u0026quot;ret = %d\\n\u0026quot;, ret); int ret = SQUARE(5 + 1); printf(\u0026quot;%d\\n\u0026quot;, ret); return 0; }  提示：\n所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中的操作符或 邻近操作符之间不可预料的相互作用。\n#define 替换规则 在程序中扩展#define定义符号和宏时，需要涉及几个步骤。\n 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。  注意 1. 宏参数和#define 定义中可以出现其他#define定义的变量。但是对于宏，不能出现递归。 2. 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。\n预处理操作符#和##的介绍 #的作用 使用 # ，把一个宏参数变成对应的字符串\nvoid print(int a) //无法实现预期效果 { printf(\u0026quot;the value of a is %d\\n\u0026quot;, a); } #define PRINT(X) printf(\u0026quot;the value of \u0026quot; #X \u0026quot; is %d\\n\u0026quot;, X) //定义宏，一般用大写 int main() { int a = 10; int b = 20; //printf(\u0026quot;the value of a is %d\\n\u0026quot;, a); print(a);//the value of a is 10 print(b);//the value of a is 20 PRINT(a);//the value of a is 10 PRINT(b);//the value of b is 20 return 0; }  ##的作用 ##可以把位于它两边的符号合成一个符号。 它允许宏定义从分离的文本片段创建标识符。\n#define CAT(X, Y) X##Y int main() { int Class1 = 2021; //printf(\u0026quot;%d\\n\u0026quot;, class1); printf(\u0026quot;%d\\n\u0026quot;, CAT(Class, 84));//2021 //printf(\u0026quot;%d\\n\u0026quot;, Class##1); //printf(\u0026quot;%d\\n\u0026quot;, Class1); return 0; }  注： 这样的连接必须产生一个合法的标识符。否则其结果就是未定义的。\n带副作用的宏参数 当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。\n例如：\nx+1;//不带副作用 x++;//带有副作用  MAX宏可以证明具有副作用的参数所引起的问题。\n#define MAX(X, Y) ((X)\u0026gt;(Y)?(X):(Y)) int main() { int a = 10; int b = 11; int max = MAX(a++, b++); //int max = ((a++) \u0026gt; (b++) ? (a++) : (b++)); printf(\u0026quot;%d\\n\u0026quot;, max);//12 printf(\u0026quot;%d\\n\u0026quot;, a);//11 printf(\u0026quot;%d\\n\u0026quot;, b);//13 return 0; }  宏和函数对比 宏通常被应用于执行简单的运算。比如在两个数中找出较大的一个。\n//函数-1 int Max(int x, int y) { return (x \u0026gt; y ? x : y); } float Max2(float x, float y) { return (x \u0026gt; y ? x : y); } //宏-2 #define MAX(X, Y) ((X)\u0026gt;(Y)?(X):(Y)) int main() { int a = 10; int b = 20; float c = 3.0f; float d = 4.0f; //函数在调用的时候 //会有函数调用和返回的开销 float max = Max2(c, d); printf(\u0026quot;max = %d\\n\u0026quot;, max); //预处理阶段就完成了替换 //没有函数的调用和返回的开销 max = MAX(c, d); max = ((c) \u0026gt; (d) ? (c) : (d)); printf(\u0026quot;max = %d\\n\u0026quot;, max); /*int max = Max(a, b); printf(\u0026quot;max = %d\\n\u0026quot;, max); max = MAX(a, b); printf(\u0026quot;max = %d\\n\u0026quot;, max);*/ return 0; }  那为什么不用函数来完成这个任务？ 原因有二：\n 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以宏比函数在程序的规模和速度方面更胜一筹。 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于\u0026gt;来比较的类型。宏是类型无关的。  当然和宏相比函数也有劣势的地方：\n 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。 宏是没法调试的。 宏由于类型无关，也就不够严谨。 宏可能会带来运算符优先级的问题，导致程容易出现错。  宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。\n#define MALLOC(num, type) (type*)malloc(num*sizeof(type)) int main() { int* p = (int*)malloc(10*sizeof(int)); int* p = MALLOC(10, int); //int* p = (int*)malloc(10 * sizeof(int)); return 0; }     属性 #define定义宏 函数     代码长度 每次使用时，宏代码都会被插入到程序中。除了非常小的宏之外，程序的长度会大幅度增长 函数代码只出现于一个地方；每次使用这个函数时，都调用那个地方的同一份代码   执行速度 更快 存在函数的调用和返回的额外开销，所以相对慢一些   操作符优先级 宏参数的求值是在所有周围表达式的上下文环境里，除非加上括号，否则邻近操作符的优先级可能会产生不可预料的后果，所以建议宏在书写的时候多些括号。 函数参数只在函数调用的时候求值一次，它的结果值传递给函数。表达式的求值结果更容易预测。   带有副作用的参数 参数可能被替换到宏体中的多个位置，所以带有副作用的参数求值可能会产生不可预料的结果。 函数参数只在传参的时候求值一次，结果更容易控制。   参数类型 宏的参数与类型无关，只要对参数的操作是合法的，它就可以使用于任何参数类型。 函数的参数是与类型有关的，如果参数的类型不同，就需要不同的函数，即使他们执行的任务是不同的。   调试 宏是不方便调试的 函数是可以逐语句调试的   递归 宏是不能递归的 函数是可以递归的    命名约定 一般来讲函数的宏的使用语法很相似。所以语言本身没法帮我们区分二者。 那我们平时的一个习惯是：\n把宏名全部大写 函数名不要全部大写  #undef 这条指令用于移除一个宏定义。\n#define MAX 100 int main() { printf(\u0026quot;MAX = %d\\n\u0026quot;, MAX); #undef MAX //如果现存的一个名字需要被重新定义，那么它的旧名字首先要被移除。 //printf(\u0026quot;MAX = %d\\n\u0026quot;, MAX);//err return 0; }  命令行定义 许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。 例如：当我们根据同一个源文件要编译出不同的一个程序的不同版本的时候，这个特性有点用处。（假定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一个机器内存大写，我们需要一个数组能够大写。）\n#include \u0026lt;stdio.h\u0026gt; int main() { int array [ARRAY_SIZE]; int i = 0; for(i = 0; i\u0026lt; ARRAY_SIZE; i ++) { array[i] = i; } for(i = 0; i\u0026lt; ARRAY_SIZE; i ++) { printf(\u0026quot;%d \u0026quot; ,array[i]); } printf(\u0026quot;\\n\u0026quot; ); return 0; }  编译指令：\ngcc -D ARRAY_SIZE=10 programe.c  条件编译 在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件编译指令。\n比如说：\n调试性的代码，删除可惜，保留又碍事，所以我们可以选择性的编译。  #define DEBUG int main() { int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 }; int i = 0; for (i = 0; i \u0026lt; 10; i++) { arr[i] = 0; #ifdef DEBUG printf(\u0026quot;%d \u0026quot;, arr[i]); #endif } return 0; }  常见的条件编译指令：\n #if 常量表达式 //... #endif //常量表达式由预处理器求值。 如： #define __DEBUG__ 1 #if __DEBUG__ //.. #endif  多个分支的条件编译\n#if 常量表达式 //... #elif 常量表达式 //... #else //... #endif  判断是否被定义\n#if defined(symbol) #ifdef symbol #if !defined(symbol) #ifndef symbol  嵌套指令\n#if defined(OS_UNIX) #ifdef OPTION1 unix_version_option1(); #endif #ifdef OPTION2 unix_version_option2(); #endif #elif defined(OS_MSDOS) #ifdef OPTION2 msdos_version_option2(); #endif #endif   文件包含 我们已经知道， #include 指令可以使另外一个文件被编译。就像它实际出现于 #include 指令的地方一样。\n这种替换的方式很简单： 预处理器先删除这条指令，并用包含文件的内容替换。 这样一个源文件被包含10次，那就实际被编译10次。\n头文件被包含的方式：  本地文件包含  #include \u0026quot;filename\u0026quot;  查找策略：先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件。 如果找不到就提示编译错误。 linux环境的标准头文件的路径：\n/usr/include  VS环境的标准头文件的路径：\nC:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include  注意按照自己的安装路径去找。\n 库文件包含  #include \u0026lt;filename.h\u0026gt;  查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。\n这样是不是可以说，对于库文件也可以使用 “” 的形式包含？ 答案是肯定的，可以。\n但是这样做查找的效率就低些，当然这样也不容易区分是库文件还是本地文件了。\n嵌套文件包含 如果出现这样的场景：\ncomm.h和comm.c是公共模块。 test1.h和test1.c使用了公共模块。 test2.h和test2.c使用了公共模块。 test.h和test.c使用了test1模块和test2模块。 这样最终程序中就会出现两份comm.h的内容。这样就造成了文件内容的重复。\n如何解决这个问题？ 答案：条件编译。\n每个头文件的开头写：\n#ifndef __TEST_H__ #define __TEST_H__ //头文件的内容 #endif //__TEST_H__  或者：\n#pragma once  就可以避免头文件的重复引入。\n注： 推荐《高质量C/C++编程指南》中附录的考试试卷（很重要）。\n笔试题：\n 头文件中的 ifndef/define/endif是干什么用的? #include  和 #include \u0026ldquo;filename.h\u0026rdquo;有什么区别?  其他预处理指令 #error #pragma #line \u0026hellip;\n不做介绍，自己去了解。\n#pragma pack()在结构体部分介绍。\n参考《C语言深度解剖》学习\n本章完\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"dd081a83cf273aa021a95675334f47fd","permalink":"https://cytgenkidu.github.io/tutorial/c/15/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tutorial/c/15/","section":"tutorial","summary":"程序的翻译环境和执行环境 在ANSI C的任何一种实现中，存在两个不同的环境。\n第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。 第2种是执行环境，它用于实际执行代码。  详解：C语言程序的编译+链接 翻译环境  组成一个程序的每个源文件通过编译过程分别转换成目标代码（object code）。 每个目标文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序。 链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。  编译本身也分为几个阶段  预处理 选项 gcc -E test.c -o test.i 预处理完成之后就停下来，预处理之后产生的结果都放在test.i文件中。 编译 选项 gcc -S test.c 编译完成之后就停下来，结果保存在test.s中。 汇编 gcc -c test.c 汇编完成之后就停下来，结果保存在test.o中。  运行环境 程序执行的过程：\n 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。 程序的执行便开始。接着便调用main函数。 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。 终止程序。正常终止main函数；也有可能是意外终止。  预编译（预处理）详解 预定义符号 __FILE__ //进行编译的源文件 __LINE__ //文件当前的行号 __DATE__ //文件被编译的日期 __TIME__ //文件被编译的时间 __STDC__ //如果编译器遵循ANSI C，其值为1，否则未定义  printf(\u0026quot;%s\\n\u0026quot;, __FILE__); printf(\u0026quot;%d\\n\u0026quot;, __LINE__); printf(\u0026quot;%s\\n\u0026quot;, __DATE__); printf(\u0026quot;%s\\n\u0026quot;, __TIME__);  应用-写日志log\n//写日志 int i = 0; int arr[10] = { 0 }; FILE* pf = fopen(\u0026quot;log.","tags":null,"title":"","type":"docs"},{"authors":[],"categories":null,"content":"\rClick on the Slides button above to view the built-in slides feature.\n\r\rSlides can be added in a few ways:\n Create slides using Academic\u0026rsquo;s Slides feature and link using url_slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further talk details can easily be added to this page using Markdown and $\\rm \\LaTeX$ math code.\n","date":1906520400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1906520400,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"https://cytgenkidu.github.io/talk/example/","publishdate":"2017-01-01T00:00:00+08:00","relpermalink":"/talk/example/","section":"talk","summary":"An example talk using Academic's Markdown slides feature.","tags":[],"title":"Example Talk","type":"talk"},{"authors":[],"categories":["python"],"content":" 方法一：写入新建文档 安装第三方库 pip install python-docx  实现代码 # pip install python-docx from docx import Document from docx.shared import Pt # 简单的打开word，输入数据，关闭word document = Document() # 向word里增加段落 document.add_paragraph('hello') document.save('./doc/test.docx') # 在一个段落中增加文字 document = Document() paragraph = document.add_paragraph('Hello, ') # 增加文字 paragraph.add_run('tgenkidu') # 设置word字体大小 style = document.styles['Normal'] font = style.font font.size = Pt(10) document.save('./doc/test.docx')  运行结果 注意 运行python时，要写入的word文档应处于关闭状态。\n方法二：运用模板写入word文档 本例创建了 模板.docx生成模板2.docx,也可使用已有模板进行修改，加以应用。\n安装第三方库 pip3 install docxtpl -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com  因直接安装报错，所以选择了国内的库\n创建模板或修改模板 将所填空使用{{ }}重命名，如图 实现代码 import datetime from docxtpl import DocxTemplate, RichText # pip3 install docxtpl -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com def generate_report(tpl_file, report_file): tpl= DocxTemplate(tpl_file) context = { 'time' : datetime.datetime.now(), 'biaoti' : \u0026quot;标题\u0026quot;, 'mingzi' : \u0026quot;名字\u0026quot; } tpl.render(context) tpl.save(report_file) def main(): tpl_file = \u0026quot;./doc/模板.docx\u0026quot; report_file = \u0026quot;./doc/模板2.docx\u0026quot; generate_report(tpl_file, report_file) if __name__ == \u0026quot;__main__\u0026quot;: main()  实现效果 注 若不想他仍更改生成好的word文档，可将文档加密使用。\nwps加密文档 文件\u0026gt;选项\u0026gt;安全 word加密文档 审阅\u0026gt;限制编辑 ","date":1617778221,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1617778221,"objectID":"e24d2fc6d911320d9a05d9a81d3f604d","permalink":"https://cytgenkidu.github.io/post/python%E7%94%9F%E6%88%90word/","publishdate":"2021-04-07T14:50:21+08:00","relpermalink":"/post/python%E7%94%9F%E6%88%90word/","section":"post","summary":"方法一：写入新建文档 安装第三方库 pip install python-docx  实现代码 # pip install python-docx from docx import Document from docx.shared import Pt # 简单的打开word，输入数据，关闭word document = Document() # 向word里增加段落 document.add_paragraph('hello') document.save('./doc/test.docx') # 在一个段落中增加文字 document = Document() paragraph = document.add_paragraph('Hello, ') # 增加文字 paragraph.add_run('tgenkidu') # 设置word字体大小 style = document.styles['Normal'] font = style.font font.size = Pt(10) document.save('./doc/test.docx')  运行结果 注意 运行python时，要写入的word文档应处于关闭状态。\n方法二：运用模板写入word文档 本例创建了 模板.docx生成模板2.docx,也可使用已有模板进行修改，加以应用。\n安装第三方库 pip3 install docxtpl -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com  因直接安装报错，所以选择了国内的库","tags":["python"],"title":"Python生成word","type":"post"},{"authors":[],"categories":["Angular","ECharts"],"content":" @TOC\n安装插件 npm install echarts npm install ngx-echarts  配置ngx-echarts import { NgxEchartsModule } from 'ngx-echarts'; @NgModule({ imports: [ ..., NgxEchartsModule ], }) export class AppModule { }  引入百度地图 申请百度地图密钥 申请链接：http://lbsyun.baidu.com/index.php?title=jspopular/guide/getkey） 记住ak码，在浏览器端使用，请选择“浏览器端AK”，例如JavaScript API只支持浏览器类型AK。\n在index.html中引入 \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;https://api.map.baidu.com/api?v=2.0\u0026amp;ak=xxxxxxxxxxxxx\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  注：百度地图必须在根组件index.html页面引入，否则会报错\n新建组件，显示地图 修改echarts的effectScatter-bmap示例https://echarts.apache.org/examples/zh/editor.html?c=effectScatter-bmap\nHTML \u0026lt;div echarts [options]=\u0026quot;Options\u0026quot; (chartInit)=\u0026quot;onChartInit($event)\u0026quot; class=\u0026quot;chart-container\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;  ts import { Component, OnInit } from \u0026quot;@angular/core\u0026quot;; @Component({ selector: \u0026quot;bmap\u0026quot;, templateUrl: \u0026quot;./bmap.component.html\u0026quot;, styleUrls: [\u0026quot;./bmap.component.scss\u0026quot;] }) export class BmapComponent implements OnInit { constructor() { } Options: any; Intance: any; data: any = [ { name: '海门', value: 9 }, { name: '鄂尔多斯', value: 12 }, { name: '招远', value: 12 }, { name: '舟山', value: 12 }, { name: '齐齐哈尔', value: 14 }, { name: '盐城', value: 15 }, { name: '赤峰', value: 16 }, { name: '青岛', value: 18 }, { name: '乳山', value: 18 }, { name: '金昌', value: 19 }, { name: '泉州', value: 21 }, { name: '莱西', value: 21 }, { name: '日照', value: 21 }, { name: '胶南', value: 22 }, { name: '南通', value: 23 }, { name: '拉萨', value: 24 }, { name: '云浮', value: 24 }, { name: '梅州', value: 25 }, { name: '文登', value: 25 }, { name: '上海', value: 25 }, { name: '攀枝花', value: 25 }, { name: '威海', value: 25 }, { name: '承德', value: 25 }, { name: '厦门', value: 26 }, { name: '汕尾', value: 26 }, { name: '潮州', value: 26 }, { name: '丹东', value: 27 }, { name: '太仓', value: 27 }, { name: '曲靖', value: 27 }, { name: '烟台', value: 28 }, { name: '福州', value: 29 }, { name: '瓦房店', value: 30 }, { name: '即墨', value: 30 }, { name: '抚顺', value: 31 }, { name: '玉溪', value: 31 }, { name: '张家口', value: 31 }, { name: '阳泉', value: 31 }, { name: '莱州', value: 32 }, { name: '湖州', value: 32 }, { name: '汕头', value: 32 }, { name: '昆山', value: 33 }, { name: '宁波', value: 33 }, { name: '湛江', value: 33 }, { name: '揭阳', value: 34 }, { name: '荣成', value: 34 }, { name: '连云港', value: 35 }, { name: '葫芦岛', value: 35 }, { name: '常熟', value: 36 }, { name: '东莞', value: 36 }, { name: '河源', value: 36 }, { name: '淮安', value: 36 }, { name: '泰州', value: 36 }, { name: '南宁', value: 37 }, { name: '营口', value: 37 }, { name: '惠州', value: 37 }, { name: '江阴', value: 37 }, { name: '蓬莱', value: 37 }, { name: '韶关', value: 38 }, { name: '嘉峪关', value: 38 }, { name: '广州', value: 38 }, { name: '延安', value: 38 }, { name: '太原', value: 39 }, { name: '清远', value: 39 }, { name: '中山', value: 39 }, { name: '昆明', value: 39 }, { name: '寿光', value: 40 }, { name: '盘锦', value: 40 }, { name: '长治', value: 41 }, { name: '深圳', value: 41 }, { name: '珠海', value: 42 }, { name: '宿迁', value: 43 }, { name: '咸阳', value: 43 }, { name: '铜川', value: 44 }, { name: '平度', value: 44 }, { name: '佛山', value: 44 }, { name: '海口', value: 44 }, { name: '江门', value: 45 }, { name: '章丘', value: 45 }, { name: '肇庆', value: 46 }, { name: '大连', value: 47 }, { name: '临汾', value: 47 }, { name: '吴江', value: 47 }, { name: '石嘴山', value: 49 }, { name: '沈阳', value: 50 }, { name: '苏州', value: 50 }, { name: '茂名', value: 50 }, { name: '嘉兴', value: 51 }, { name: '长春', value: 51 }, { name: '胶州', value: 52 }, { name: '银川', value: 52 }, { name: '张家港', value: 52 }, { name: '三门峡', value: 53 }, { name: '锦州', value: 54 }, { name: '南昌', value: 54 }, { name: '柳州', value: 54 }, { name: '三亚', value: 54 }, { name: '自贡', value: 56 }, { name: '吉林', value: 56 }, { name: '阳江', value: 57 }, { name: '泸州', value: 57 }, { name: '西宁', value: 57 }, { name: '宜宾', value: 58 }, { name: '呼和浩特', value: 58 }, { name: '成都', value: 58 }, { name: '大同', value: 58 }, { name: '镇江', value: 59 }, { name: '桂林', value: 59 }, { name: '张家界', value: 59 }, { name: '宜兴', value: 59 }, { name: '北海', value: 60 }, { name: '西安', value: 61 }, { name: '金坛', value: 62 }, { name: '东营', value: 62 }, { name: '牡丹江', value: 63 }, { name: '遵义', value: 63 }, { name: '绍兴', value: 63 }, { name: '扬州', value: 64 }, { name: '常州', value: 64 }, { name: '潍坊', value: 65 }, { name: '重庆', value: 66 }, { name: '台州', value: 67 }, { name: '南京', value: 67 }, { name: '滨州', value: 70 }, { name: '贵阳', value: 71 }, { name: '无锡', value: 71 }, { name: '本溪', value: 71 }, { name: '克拉玛依', value: 72 }, { name: '渭南', value: 72 }, { name: '马鞍山', value: 72 }, { name: '宝鸡', value: 72 }, { name: '焦作', value: 75 }, { name: '句容', value: 75 }, { name: '北京', value: 79 }, { name: '徐州', value: 79 }, { name: '衡水', value: 80 }, { name: '包头', value: 80 }, { name: '绵阳', value: 80 }, { name: '乌鲁木齐', value: 84 }, { name: '枣庄', value: 84 }, { name: '杭州', value: 84 }, { name: '淄博', value: 85 }, { name: '鞍山', value: 86 }, { name: '溧阳', value: 86 }, { name: '库尔勒', value: 86 }, { name: '安阳', value: 90 }, { name: '开封', value: 90 }, { name: '济南', value: 92 }, { name: '德阳', value: 93 }, { name: '温州', value: 95 }, { name: '九江', value: 96 }, { name: '邯郸', value: 98 }, { name: '临安', value: 99 }, { name: '兰州', value: 99 }, { name: '沧州', value: 100 }, { name: '临沂', value: 103 }, { name: '南充', value: 104 }, { name: '天津', value: 105 }, { name: '富阳', value: 106 }, { name: '泰安', value: 112 }, { name: '诸暨', value: 112 }, { name: '郑州', value: 113 }, { name: '哈尔滨', value: 114 }, { name: '聊城', value: 116 }, { name: '芜湖', value: 117 }, { name: '唐山', value: 119 }, { name: '平顶山', value: 119 }, { name: '邢台', value: 119 }, { name: '德州', value: 120 }, { name: '济宁', value: 120 }, { name: '荆州', value: 127 }, { name: '宜昌', value: 130 }, { name: '义乌', value: 132 }, { name: '丽水', value: 133 }, { name: '洛阳', value: 134 }, { name: '秦皇岛', value: 136 }, { name: '株洲', value: 143 }, { name: '石家庄', value: 147 }, { name: '莱芜', value: 148 }, { name: '常德', value: 152 }, { name: '保定', value: 153 }, { name: '湘潭', value: 154 }, { name: '金华', value: 157 }, { name: '岳阳', value: 169 }, { name: '长沙', value: 175 }, { name: '衢州', value: 177 }, { name: '廊坊', value: 193 }, { name: '菏泽', value: 194 }, { name: '合肥', value: 229 }, { name: '武汉', value: 273 }, { name: '大庆', value: 279 } ]; geoCoordMap: any = { '海门': [121.15, 31.89], '鄂尔多斯': [109.781327, 39.608266], '招远': [120.38, 37.35], '舟山': [122.207216, 29.985295], '齐齐哈尔': [123.97, 47.33], '盐城': [120.13, 33.38], '赤峰': [118.87, 42.28], '青岛': [120.33, 36.07], '乳山': [121.52, 36.89], '金昌': [102.188043, 38.520089], '泉州': [118.58, 24.93], '莱西': [120.53, 36.86], '日照': [119.46, 35.42], '胶南': [119.97, 35.88], '南通': [121.05, 32.08], '拉萨': [91.11, 29.97], '云浮': [112.02, 22.93], '梅州': [116.1, 24.55], '文登': [122.05, 37.2], '上海': [121.48, 31.22], '攀枝花': [101.718637, 26.582347], '威海': [122.1, 37.5], '承德': [117.93, 40.97], '厦门': [118.1, 24.46], '汕尾': [115.375279, 22.786211], '潮州': [116.63, 23.68], '丹东': [124.37, 40.13], '太仓': [121.1, 31.45], '曲靖': [103.79, 25.51], '烟台': [121.39, 37.52], '福州': [119.3, 26.08], '瓦房店': [121.979603, 39.627114], '即墨': [120.45, 36.38], '抚顺': [123.97, 41.97], '玉溪': [102.52, 24.35], '张家口': [114.87, 40.82], '阳泉': [113.57, 37.85], '莱州': [119.942327, 37.177017], '湖州': [120.1, 30.86], '汕头': [116.69, 23.39], '昆山': [120.95, 31.39], '宁波': [121.56, 29.86], '湛江': [110.359377, 21.270708], '揭阳': [116.35, 23.55], '荣成': [122.41, 37.16], '连云港': [119.16, 34.59], '葫芦岛': [120.836932, 40.711052], '常熟': [120.74, 31.64], '东莞': [113.75, 23.04], '河源': [114.68, 23.73], '淮安': [119.15, 33.5], '泰州': [119.9, 32.49], '南宁': [108.33, 22.84], '营口': [122.18, 40.65], '惠州': [114.4, 23.09], '江阴': [120.26, 31.91], '蓬莱': [120.75, 37.8], '韶关': [113.62, 24.84], '嘉峪关': [98.289152, 39.77313], '广州': [113.23, 23.16], '延安': [109.47, 36.6], '太原': [112.53, 37.87], '清远': [113.01, 23.7], '中山': [113.38, 22.52], '昆明': [102.73, 25.04], '寿光': [118.73, 36.86], '盘锦': [122.070714, 41.119997], '长治': [113.08, 36.18], '深圳': [114.07, 22.62], '珠海': [113.52, 22.3], '宿迁': [118.3, 33.96], '咸阳': [108.72, 34.36], '铜川': [109.11, 35.09], '平度': [119.97, 36.77], '佛山': [113.11, 23.05], '海口': [110.35, 20.02], '江门': [113.06, 22.61], '章丘': [117.53, 36.72], '肇庆': [112.44, 23.05], '大连': [121.62, 38.92], '临汾': [111.5, 36.08], '吴江': [120.63, 31.16], '石嘴山': [106.39, 39.04], '沈阳': [123.38, 41.8], '苏州': [120.62, 31.32], '茂名': [110.88, 21.68], '嘉兴': [120.76, 30.77], '长春': [125.35, 43.88], '胶州': [120.03336, 36.264622], '银川': [106.27, 38.47], '张家港': [120.555821, 31.875428], '三门峡': [111.19, 34.76], '锦州': [121.15, 41.13], '南昌': [115.89, 28.68], '柳州': [109.4, 24.33], '三亚': [109.511909, 18.252847], '自贡': [104.778442, 29.33903], '吉林': [126.57, 43.87], '阳江': [111.95, 21.85], '泸州': [105.39, 28.91], '西宁': [101.74, 36.56], '宜宾': [104.56, 29.77], '呼和浩特': [111.65, 40.82], '成都': [104.06, 30.67], '大同': [113.3, 40.12], '镇江': [119.44, 32.2], '桂林': [110.28, 25.29], '张家界': [110.479191, 29.117096], '宜兴': [119.82, 31.36], '北海': [109.12, 21.49], '西安': [108.95, 34.27], '金坛': [119.56, 31.74], '东营': [118.49, 37.46], '牡丹江': [129.58, 44.6], '遵义': [106.9, 27.7], '绍兴': [120.58, 30.01], '扬州': [119.42, 32.39], '常州': [119.95, 31.79], '潍坊': [119.1, 36.62], '重庆': [106.54, 29.59], '台州': [121.420757, 28.656386], '南京': [118.78, 32.04], '滨州': [118.03, 37.36], '贵阳': [106.71, 26.57], '无锡': [120.29, 31.59], '本溪': [123.73, 41.3], '克拉玛依': [84.77, 45.59], '渭南': [109.5, 34.52], '马鞍山': [118.48, 31.56], '宝鸡': [107.15, 34.38], '焦作': [113.21, 35.24], '句容': [119.16, 31.95], '北京': [116.46, 39.92], '徐州': [117.2, 34.26], '衡水': [115.72, 37.72], '包头': [110, 40.58], '绵阳': [104.73, 31.48], '乌鲁木齐': [87.68, 43.77], '枣庄': [117.57, 34.86], '杭州': [120.19, 30.26], '淄博': [118.05, 36.78], '鞍山': [122.85, 41.12], '溧阳': [119.48, 31.43], '库尔勒': [86.06, 41.68], '安阳': [114.35, 36.1], '开封': [114.35, 34.79], '济南': [117, 36.65], '德阳': [104.37, 31.13], '温州': [120.65, 28.01], '九江': [115.97, 29.71], '邯郸': [114.47, 36.6], '临安': [119.72, 30.23], '兰州': [103.73, 36.03], '沧州': [116.83, 38.33], '临沂': [118.35, 35.05], '南充': [106.110698, 30.837793], '天津': [117.2, 39.13], '富阳': [119.95, 30.07], '泰安': [117.13, 36.18], '诸暨': [120.23, 29.71], '郑州': [113.65, 34.76], '哈尔滨': [126.63, 45.75], '聊城': [115.97, 36.45], '芜湖': [118.38, 31.33], '唐山': [118.02, 39.63], '平顶山': [113.29, 33.75], '邢台': [114.48, 37.05], '德州': [116.29, 37.45], '济宁': [116.59, 35.38], '荆州': [112.239741, 30.335165], '宜昌': [111.3, 30.7], '义乌': [120.06, 29.32], '丽水': [119.92, 28.45], '洛阳': [112.44, 34.7], '秦皇岛': [119.57, 39.95], '株洲': [113.16, 27.83], '石家庄': [114.48, 38.03], '莱芜': [117.67, 36.19], '常德': [111.69, 29.05], '保定': [115.48, 38.85], '湘潭': [112.91, 27.87], '金华': [119.64, 29.12], '岳阳': [113.09, 29.37], '长沙': [113, 28.21], '衢州': [118.88, 28.97], '廊坊': [116.7, 39.53], '菏泽': [115.480656, 35.23375], '合肥': [117.27, 31.86], '武汉': [114.31, 30.52], '大庆': [125.03, 46.58] }; convertData(data: any) { var res = []; for (var i = 0; i \u0026lt; data.length; i++) { var geoCoord = this.geoCoordMap[data[i].name]; if (geoCoord) { res.push({ name: data[i].name, value: geoCoord.concat(data[i].value) }); } } return res; } ngOnInit(): void { this.Options = { title: { text: '全国主要城市空气质量 - 百度地图', subtext: 'data from PM25.in', sublink: 'http://www.pm25.in', left: 'center' }, tooltip: { trigger: 'item' }, bmap: { center: [104.114129, 37.550339], zoom: 5, roam: true, mapStyle: { styleJson: [{ 'featureType': 'water', 'elementType': 'all', 'stylers': { 'color': '#d1d1d1' } }, { 'featureType': 'land', 'elementType': 'all', 'stylers': { 'color': '#f3f3f3' } }, { 'featureType': 'railway', 'elementType': 'all', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'highway', 'elementType': 'all', 'stylers': { 'color': '#fdfdfd' } }, { 'featureType': 'highway', 'elementType': 'labels', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'arterial', 'elementType': 'geometry', 'stylers': { 'color': '#fefefe' } }, { 'featureType': 'arterial', 'elementType': 'geometry.fill', 'stylers': { 'color': '#fefefe' } }, { 'featureType': 'poi', 'elementType': 'all', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'green', 'elementType': 'all', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'subway', 'elementType': 'all', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'manmade', 'elementType': 'all', 'stylers': { 'color': '#d1d1d1' } }, { 'featureType': 'local', 'elementType': 'all', 'stylers': { 'color': '#d1d1d1' } }, { 'featureType': 'arterial', 'elementType': 'labels', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'boundary', 'elementType': 'all', 'stylers': { 'color': '#fefefe' } }, { 'featureType': 'building', 'elementType': 'all', 'stylers': { 'color': '#d1d1d1' } }, { 'featureType': 'label', 'elementType': 'labels.text.fill', 'stylers': { 'color': '#999999' } }] } }, series: [ { name: 'pm2.5', type: 'scatter', coordinateSystem: 'bmap', data: this.convertData(this.data), symbolSize: function (val) { return val[2] / 10; }, encode: { value: 2 }, label: { formatter: '{b}', position: 'right', show: false }, emphasis: { label: { show: true } } }, { name: 'Top 5', type: 'effectScatter', coordinateSystem: 'bmap', data: this.convertData(this.data.sort(function (a, b) { return b.value - a.value; }).slice(0, 6)), symbolSize: function (val) { return val[2] / 10; }, encode: { value: 2 }, showEffectOn: 'render', rippleEffect: { brushType: 'stroke' }, hoverAnimation: true, label: { formatter: '{b}', position: 'right', show: true }, itemStyle: { shadowBlur: 10, shadowColor: '#333' }, zlevel: 1 } ] }; this.Intance.setOption(this.Options, true); } onChartInit(ec: any) { this.Intance = ec; } }  展示效果 官网示例[https://echarts.apache.org/examples/zh/editor.html?c=effectScatter-bmap] 实现效果 ","date":1617778116,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1617778116,"objectID":"22315ec94f4a6a22d4c244a2a368e073","permalink":"https://cytgenkidu.github.io/post/angular-ngxecharts-baidu-bmap/","publishdate":"2021-04-07T14:48:36+08:00","relpermalink":"/post/angular-ngxecharts-baidu-bmap/","section":"post","summary":"@TOC\n安装插件 npm install echarts npm install ngx-echarts  配置ngx-echarts import { NgxEchartsModule } from 'ngx-echarts'; @NgModule({ imports: [ ..., NgxEchartsModule ], }) export class AppModule { }  引入百度地图 申请百度地图密钥 申请链接：http://lbsyun.baidu.com/index.php?title=jspopular/guide/getkey） 记住ak码，在浏览器端使用，请选择“浏览器端AK”，例如JavaScript API只支持浏览器类型AK。\n在index.html中引入 \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;https://api.map.baidu.com/api?v=2.0\u0026amp;ak=xxxxxxxxxxxxx\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  注：百度地图必须在根组件index.html页面引入，否则会报错\n新建组件，显示地图 修改echarts的effectScatter-bmap示例https://echarts.apache.org/examples/zh/editor.html?c=effectScatter-bmap\nHTML \u0026lt;div echarts [options]=\u0026quot;Options\u0026quot; (chartInit)=\u0026quot;onChartInit($event)\u0026quot; class=\u0026quot;chart-container\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;  ts import { Component, OnInit } from \u0026quot;@angular/core\u0026quot;; @Component({ selector: \u0026quot;bmap\u0026quot;, templateUrl: \u0026quot;./bmap.component.html\u0026quot;, styleUrls: [\u0026quot;./bmap.component.scss\u0026quot;] }) export class BmapComponent implements OnInit { constructor() { } Options: any; Intance: any; data: any = [ { name: '海门', value: 9 }, { name: '鄂尔多斯', value: 12 }, { name: '招远', value: 12 }, { name: '舟山', value: 12 }, { name: '齐齐哈尔', value: 14 }, { name: '盐城', value: 15 }, { name: '赤峰', value: 16 }, { name: '青岛', value: 18 }, { name: '乳山', value: 18 }, { name: '金昌', value: 19 }, { name: '泉州', value: 21 }, { name: '莱西', value: 21 }, { name: '日照', value: 21 }, { name: '胶南', value: 22 }, { name: '南通', value: 23 }, { name: '拉萨', value: 24 }, { name: '云浮', value: 24 }, { name: '梅州', value: 25 }, { name: '文登', value: 25 }, { name: '上海', value: 25 }, { name: '攀枝花', value: 25 }, { name: '威海', value: 25 }, { name: '承德', value: 25 }, { name: '厦门', value: 26 }, { name: '汕尾', value: 26 }, { name: '潮州', value: 26 }, { name: '丹东', value: 27 }, { name: '太仓', value: 27 }, { name: '曲靖', value: 27 }, { name: '烟台', value: 28 }, { name: '福州', value: 29 }, { name: '瓦房店', value: 30 }, { name: '即墨', value: 30 }, { name: '抚顺', value: 31 }, { name: '玉溪', value: 31 }, { name: '张家口', value: 31 }, { name: '阳泉', value: 31 }, { name: '莱州', value: 32 }, { name: '湖州', value: 32 }, { name: '汕头', value: 32 }, { name: '昆山', value: 33 }, { name: '宁波', value: 33 }, { name: '湛江', value: 33 }, { name: '揭阳', value: 34 }, { name: '荣成', value: 34 }, { name: '连云港', value: 35 }, { name: '葫芦岛', value: 35 }, { name: '常熟', value: 36 }, { name: '东莞', value: 36 }, { name: '河源', value: 36 }, { name: '淮安', value: 36 }, { name: '泰州', value: 36 }, { name: '南宁', value: 37 }, { name: '营口', value: 37 }, { name: '惠州', value: 37 }, { name: '江阴', value: 37 }, { name: '蓬莱', value: 37 }, { name: '韶关', value: 38 }, { name: '嘉峪关', value: 38 }, { name: '广州', value: 38 }, { name: '延安', value: 38 }, { name: '太原', value: 39 }, { name: '清远', value: 39 }, { name: '中山', value: 39 }, { name: '昆明', value: 39 }, { name: '寿光', value: 40 }, { name: '盘锦', value: 40 }, { name: '长治', value: 41 }, { name: '深圳', value: 41 }, { name: '珠海', value: 42 }, { name: '宿迁', value: 43 }, { name: '咸阳', value: 43 }, { name: '铜川', value: 44 }, { name: '平度', value: 44 }, { name: '佛山', value: 44 }, { name: '海口', value: 44 }, { name: '江门', value: 45 }, { name: '章丘', value: 45 }, { name: '肇庆', value: 46 }, { name: '大连', value: 47 }, { name: '临汾', value: 47 }, { name: '吴江', value: 47 }, { name: '石嘴山', value: 49 }, { name: '沈阳', value: 50 }, { name: '苏州', value: 50 }, { name: '茂名', value: 50 }, { name: '嘉兴', value: 51 }, { name: '长春', value: 51 }, { name: '胶州', value: 52 }, { name: '银川', value: 52 }, { name: '张家港', value: 52 }, { name: '三门峡', value: 53 }, { name: '锦州', value: 54 }, { name: '南昌', value: 54 }, { name: '柳州', value: 54 }, { name: '三亚', value: 54 }, { name: '自贡', value: 56 }, { name: '吉林', value: 56 }, { name: '阳江', value: 57 }, { name: '泸州', value: 57 }, { name: '西宁', value: 57 }, { name: '宜宾', value: 58 }, { name: '呼和浩特', value: 58 }, { name: '成都', value: 58 }, { name: '大同', value: 58 }, { name: '镇江', value: 59 }, { name: '桂林', value: 59 }, { name: '张家界', value: 59 }, { name: '宜兴', value: 59 }, { name: '北海', value: 60 }, { name: '西安', value: 61 }, { name: '金坛', value: 62 }, { name: '东营', value: 62 }, { name: '牡丹江', value: 63 }, { name: '遵义', value: 63 }, { name: '绍兴', value: 63 }, { name: '扬州', value: 64 }, { name: '常州', value: 64 }, { name: '潍坊', value: 65 }, { name: '重庆', value: 66 }, { name: '台州', value: 67 }, { name: '南京', value: 67 }, { name: '滨州', value: 70 }, { name: '贵阳', value: 71 }, { name: '无锡', value: 71 }, { name: '本溪', value: 71 }, { name: '克拉玛依', value: 72 }, { name: '渭南', value: 72 }, { name: '马鞍山', value: 72 }, { name: '宝鸡', value: 72 }, { name: '焦作', value: 75 }, { name: '句容', value: 75 }, { name: '北京', value: 79 }, { name: '徐州', value: 79 }, { name: '衡水', value: 80 }, { name: '包头', value: 80 }, { name: '绵阳', value: 80 }, { name: '乌鲁木齐', value: 84 }, { name: '枣庄', value: 84 }, { name: '杭州', value: 84 }, { name: '淄博', value: 85 }, { name: '鞍山', value: 86 }, { name: '溧阳', value: 86 }, { name: '库尔勒', value: 86 }, { name: '安阳', value: 90 }, { name: '开封', value: 90 }, { name: '济南', value: 92 }, { name: '德阳', value: 93 }, { name: '温州', value: 95 }, { name: '九江', value: 96 }, { name: '邯郸', value: 98 }, { name: '临安', value: 99 }, { name: '兰州', value: 99 }, { name: '沧州', value: 100 }, { name: '临沂', value: 103 }, { name: '南充', value: 104 }, { name: '天津', value: 105 }, { name: '富阳', value: 106 }, { name: '泰安', value: 112 }, { name: '诸暨', value: 112 }, { name: '郑州', value: 113 }, { name: '哈尔滨', value: 114 }, { name: '聊城', value: 116 }, { name: '芜湖', value: 117 }, { name: '唐山', value: 119 }, { name: '平顶山', value: 119 }, { name: '邢台', value: 119 }, { name: '德州', value: 120 }, { name: '济宁', value: 120 }, { name: '荆州', value: 127 }, { name: '宜昌', value: 130 }, { name: '义乌', value: 132 }, { name: '丽水', value: 133 }, { name: '洛阳', value: 134 }, { name: '秦皇岛', value: 136 }, { name: '株洲', value: 143 }, { name: '石家庄', value: 147 }, { name: '莱芜', value: 148 }, { name: '常德', value: 152 }, { name: '保定', value: 153 }, { name: '湘潭', value: 154 }, { name: '金华', value: 157 }, { name: '岳阳', value: 169 }, { name: '长沙', value: 175 }, { name: '衢州', value: 177 }, { name: '廊坊', value: 193 }, { name: '菏泽', value: 194 }, { name: '合肥', value: 229 }, { name: '武汉', value: 273 }, { name: '大庆', value: 279 } ]; geoCoordMap: any = { '海门': [121.","tags":["Angular","ECharts","Bmap"],"title":"Angular Ngxecharts Baidu Bmap","type":"post"},{"authors":[],"categories":["mysql"],"content":" Mysql命令导入 前提 已安装好mysql并打开服务，配置好环境变量。 配置环境变量 找到mysql 安装位置，此为我的安装位置C:\\Program Files\\MySQL\\MySQL Server 5.6\\bin 此电脑 \u0026gt; 右键 属性 \u0026gt; 高级系统设置 操作 mysql -h 123.55.133.0 -u root -p -P 3306  SHOW VARIABLES LIKE 'character%';  LOAD DATA LOCAL INFILE 'D:/1.csv' INTO TABLE test.data FIELDS TERMINATED BY ',';  ","date":1617777856,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1617777856,"objectID":"3a7752811bed25ead70471695fa553bf","permalink":"https://cytgenkidu.github.io/post/mysql%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AEcsv/","publishdate":"2021-04-07T14:44:16+08:00","relpermalink":"/post/mysql%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AEcsv/","section":"post","summary":" Mysql命令导入 前提 已安装好mysql并打开服务，配置好环境变量。 配置环境变量 找到mysql 安装位置，此为我的安装位置C:\\Program Files\\MySQL\\MySQL Server 5.6\\bin 此电脑 \u0026gt; 右键 属性 \u0026gt; 高级系统设置 操作 mysql -h 123.55.133.0 -u root -p -P 3306  SHOW VARIABLES LIKE 'character%';  LOAD DATA LOCAL INFILE 'D:/1.csv' INTO TABLE test.data FIELDS TERMINATED BY ',';  ","tags":["mysql"],"title":"mysql导入数据【mysql 配置环境变量、处理中文乱码】","type":"post"},{"authors":["Tgenkidu Cy"],"categories":["java","mybatis"],"content":" 如果你想在mybatis generator 自动生成mapper xml model等的时候，调整生成java的数据库类型（数据类型转换）、生成分页语句、or连接的多列模糊查询、含中文特殊字符处理。末尾有源码的地址和jar.\n准备工作 下载源码：https://github.com/mybatis/generator 其中，mybatis-generator-core目录 是该项目的源码，主要修改这里。 注：本例是对mybatis-generator-core1.4.1的扩展，其他版本修改过程类似。 目录如下： 修改 mybatis-generator 中数据库类型和 Java 类型的映射关系 本例是将原本数据库的TIMESTAMP 映射为 Date 类型， 改为 数据库的TIMESTAMP 映射为 LocalDateTime类型。\n注： 仅为示例，其他类型修改类似。 mybatis generator 本身可直接将TIMESTAMP映射为LocalDateTime。具体使用方法请参考http://mybatis.org/generator/configreference/javaTypeResolver.html\n修改文件位置为src\\main\\java\\org\\mybatis\\generator\\internal\\types\\JavaTypeResolverDefaultImpl.java // typeMap.put(Types.TIMESTAMP, new JdbcTypeInformation(\u0026quot;TIMESTAMP\u0026quot;, //$NON-NLS-1$ // new FullyQualifiedJavaType(Date.class.getName()))); typeMap.put(Types.TIMESTAMP, new JdbcTypeInformation(\u0026quot;TIMESTAMP\u0026quot;, //$NON-NLS-1$ new FullyQualifiedJavaType(LocalDateTime.class.getName())));  这样就会将数据库的TIMESTAMP映射为java的LocalDateTime。\n增加物理分页 适用于targetRuntime=\u0026ldquo;MyBatis3\u0026rdquo;\n增加代码位置 src\\main\\java\\org\\mybatis\\generator\\codegen\\mybatis3\\xmlmapper\\elements\\SelectByExampleWithBLOBsElementGenerator.java 和 src\\main\\java\\org\\mybatis\\generator\\codegen\\mybatis3\\xmlmapper\\elements\\SelectByExampleWithoutBLOBsElementGenerator.java\nifElement = new XmlElement(\u0026quot;if\u0026quot;); //$NON-NLS-1$ ifElement.addAttribute(new Attribute(\u0026quot;test\u0026quot;, \u0026quot;limitStart \u0026gt;= 0 and limitEnd \u0026gt; 0\u0026quot;)); //$NON-NLS-1$ //$NON-NLS-2$ ifElement.addElement(new TextElement(\u0026quot;limit ${limitStart},${limitEnd}\u0026quot;)); //$NON-NLS-1$ answer.addElement(ifElement);  生成效果 增加“or连接的多列模糊查询”getMultiseriateOrLike和“and连接的多列模糊查询”getMultiseriateAndLike 增加代码位置src\\main\\java\\org\\mybatis\\generator\\codegen\\mybatis3\\model\\ExampleGenerator.java 找到getSetNotLikeMethod方法，在起下面或上面增加getMultiseriateOrLike方法和getMultiseriateAndLike，代码如下\ngetMultiseriateAndLike // Generate the multiseriateAndLike() method private Method getMultiseriateAndLike() { // Set method name StringBuilder sb = new StringBuilder(); sb.append(\u0026quot;andMultiseriateAndLike\u0026quot;); Method method = new Method(sb.toString()); // Sets the access level of the method method.setVisibility(JavaVisibility.PUBLIC); // Sets the method's parameters, which are of type hashMap and named map method.addParameter( new Parameter(new FullyQualifiedJavaType(\u0026quot;java.util.HashMap\u0026lt;String, String\u0026gt;\u0026quot;), \u0026quot;map\u0026quot;)); //$NON-NLS-1$ // Sets the return type of the method method.setReturnType(FullyQualifiedJavaType.getCriteriaInstance()); // clear sb; sb.setLength(0); method.addBodyLine(\u0026quot;if(map.isEmpty()) return (Criteria) this;\u0026quot;); method.addBodyLine(\u0026quot;StringBuilder sb = new StringBuilder();\u0026quot;); method.addBodyLine(\u0026quot;sb.append(\\\u0026quot;(\\\u0026quot;);\u0026quot;); method.addBodyLine(\u0026quot;java.util.Set\u0026lt;String\u0026gt; keySet = map.keySet();\u0026quot;); method.addBodyLine(\u0026quot;for (String str : keySet) {\u0026quot;); method.addBodyLine(\u0026quot;sb.append(\\\u0026quot; and \\\u0026quot;+str+\\\u0026quot; like '%%\\\u0026quot;+map.get(str)+\\\u0026quot;%%'\\\u0026quot;);\u0026quot;); method.addBodyLine(\u0026quot;}\u0026quot;); method.addBodyLine(\u0026quot;sb.append(\\\u0026quot;)\\\u0026quot;);\u0026quot;); method.addBodyLine(\u0026quot;int index = sb.indexOf(\\\u0026quot;and\\\u0026quot;);\u0026quot;); method.addBodyLine(\u0026quot;sb.delete(index, index+3);\u0026quot;); method.addBodyLine(\u0026quot;addCriterion(sb.toString());\u0026quot;); method.addBodyLine(\u0026quot;return (Criteria) this;\u0026quot;); return method; }  getMultiseriateOrLike // Generate the multiseriateOrLike() method private Method getMultiseriateOrLike() { // Set method name StringBuilder sb = new StringBuilder(); sb.append(\u0026quot;andMultiseriateOrLike\u0026quot;); Method method = new Method(sb.toString()); // Sets the access level of the method method.setVisibility(JavaVisibility.PUBLIC); // Sets the method's parameters, which are of type hashMap and named map method.addParameter( new Parameter(new FullyQualifiedJavaType(\u0026quot;java.util.HashMap\u0026lt;String, String\u0026gt;\u0026quot;), \u0026quot;map\u0026quot;)); //$NON-NLS-1$ // Sets the return type of the method method.setReturnType(FullyQualifiedJavaType.getCriteriaInstance()); // clear sb; sb.setLength(0); method.addBodyLine(\u0026quot;if(map.isEmpty()) return (Criteria) this;\u0026quot;); method.addBodyLine(\u0026quot;StringBuilder sb = new StringBuilder();\u0026quot;); method.addBodyLine(\u0026quot;sb.append(\\\u0026quot;(\\\u0026quot;);\u0026quot;); method.addBodyLine(\u0026quot;java.util.Set\u0026lt;String\u0026gt; keySet = map.keySet();\u0026quot;); method.addBodyLine(\u0026quot;for (String str : keySet) {\u0026quot;); method.addBodyLine(\u0026quot;sb.append(\\\u0026quot; or \\\u0026quot;+str+\\\u0026quot; like '%%\\\u0026quot;+map.get(str)+\\\u0026quot;%%'\\\u0026quot;);\u0026quot;); method.addBodyLine(\u0026quot;}\u0026quot;); method.addBodyLine(\u0026quot;sb.append(\\\u0026quot;)\\\u0026quot;);\u0026quot;); method.addBodyLine(\u0026quot;int index = sb.indexOf(\\\u0026quot;or\\\u0026quot;);\u0026quot;); method.addBodyLine(\u0026quot;sb.delete(index, index+2);\u0026quot;); method.addBodyLine(\u0026quot;addCriterion(sb.toString());\u0026quot;); method.addBodyLine(\u0026quot;return (Criteria) this;\u0026quot;); return method; }  修改getGeneratedCriteriaInnerClass方法内代码 找到getGeneratedCriteriaInnerClass代码位置，在方法return anwer;之前加入以下代码\nanswer.addMethod(getMultiseriateOrLike()); answer.addMethod(getMultiseriateAndLike());  效果 example文件将会增加一个andMultiseriateAndLike() 方法和andMultiseriateOrLike()方法。 使用 andMultiseriateAndLike() 方法和andMultiseriateOrLike()方法 接收一个HashMap类型的参数， 里面的key值为要查询的字段名， 对应的value即为模糊查询的条件。\n使用此方法与使用example其他方法一样：\nTestgenExample example = new TestgenExample(); TestgenExample.Criteria criteria = example.createCriteria(); HashMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Field[] fileds = filter.getClass().getDeclaredFields(); map.put(\u0026quot;col1\u0026quot;, \u0026quot;h\u0026quot;); map.put(\u0026quot;col2\u0026quot;, \u0026quot;a\u0026quot;); criteria.andMultiseriateAndLike(map); mapper.selectByExample(example)  增加中文字段特殊字符转化 特殊字符替换，中文转拼音首字母大写，重复加“_”\n先增加标记数据库对象名的符号 beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； 增加处理中文字段特殊字符转化的标记 修改路径 src\\main\\java\\org\\mybatis\\generator\\config\\PropertyRegistry.java\npublic static final String TABLE_USE_GG_COLUMN_NAMES = \u0026quot;useGGColumnNames\u0026quot;; //$NON-NLS-1$  增加ChineseCharToEn.java 在src\\main\\java\\org\\mybatis\\generator\\internal\\util下增加ChineseCharToEn.java package org.mybatis.generator.internal.util; import java.util.regex.Matcher; import java.util.regex.Pattern; public final class ChineseCharToEn { /** * 汉字转拼音缩写 * * @param str 要转换的汉字字符串 * @return String 拼音缩写 */ public static String getPYString(String str) { String tempStr = \u0026quot;\u0026quot;; str = matchCheck(str); for (int i = 0; i \u0026lt; str.length(); i++) { char c = str.charAt(i); if (c \u0026gt;= 33 \u0026amp;\u0026amp; c \u0026lt;= 126) {// 字母和符号原样保留 tempStr += String.valueOf(c); } else {// 累加拼音声母 tempStr += getPYChar(String.valueOf(c)); } } return tempStr; } /** * 取单个字符的拼音声母 * * @param c //要转换的单个汉字 * @return String 拼音声母 */ public static String getPYChar(String c) { byte[] array = new byte[2]; array = String.valueOf(c).getBytes(); int i = (short) (array[0] - '\\0' + 256) * 256 + ((short) (array[1] - '\\0' + 256)); if (i \u0026lt; 0xB0A1) return \u0026quot;_\u0026quot;; if (i \u0026lt; 0xB0C5) return \u0026quot;A\u0026quot;; if (i \u0026lt; 0xB2C1) return \u0026quot;B\u0026quot;; if (i \u0026lt; 0xB4EE) return \u0026quot;C\u0026quot;; if (i \u0026lt; 0xB6EA) return \u0026quot;D\u0026quot;; if (i \u0026lt; 0xB7A2) return \u0026quot;E\u0026quot;; if (i \u0026lt; 0xB8C1) return \u0026quot;F\u0026quot;; if (i \u0026lt; 0xB9FE) return \u0026quot;G\u0026quot;; if (i \u0026lt; 0xBBF7) return \u0026quot;H\u0026quot;; if (i \u0026lt; 0xBFA6) return \u0026quot;J\u0026quot;; if (i \u0026lt; 0xC0AC) return \u0026quot;K\u0026quot;; if (i \u0026lt; 0xC2E8) return \u0026quot;L\u0026quot;; if (i \u0026lt; 0xC4C3) return \u0026quot;M\u0026quot;; if (i \u0026lt; 0xC5B6) return \u0026quot;N\u0026quot;; if (i \u0026lt; 0xC5BE) return \u0026quot;O\u0026quot;; if (i \u0026lt; 0xC6DA) return \u0026quot;P\u0026quot;; if (i \u0026lt; 0xC8BB) return \u0026quot;Q\u0026quot;; if (i \u0026lt; 0xC8F6) return \u0026quot;R\u0026quot;; if (i \u0026lt; 0xCBFA) return \u0026quot;S\u0026quot;; if (i \u0026lt; 0xCDDA) return \u0026quot;T\u0026quot;; if (i \u0026lt; 0xCEF4) return \u0026quot;W\u0026quot;; if (i \u0026lt; 0xD1B9) return \u0026quot;X\u0026quot;; if (i \u0026lt; 0xD4D1) return \u0026quot;Y\u0026quot;; if (i \u0026lt; 0xD7FA) return \u0026quot;Z\u0026quot;; return \u0026quot;_\u0026quot;; } public static String matchCheck(String a) { // 正则表达式 // String regEx = // \u0026quot;[\\n`~!@#$%^\u0026amp;*()+=\\\\-|{}':;',\\\\[\\\\].\u0026lt;\u0026gt;/?~！@#￥%……\u0026amp;*（）——+|{}【】‘；：”“’。， 、？]\u0026quot;; Pattern pattern = Pattern.compile(\u0026quot;[^\\\\x{4e00}-\\\\x{9fa5}a-zA-Z0-9_]\u0026quot;); Matcher matcher = pattern.matcher(a); StringBuffer buffer = new StringBuffer(); while (matcher.find()) { matcher.appendReplacement(buffer, \u0026quot;\u0026quot;); } // 合法部分添加到缓冲区 matcher.appendTail(buffer); return buffer.toString(); } }  修改src\\main\\java\\org\\mybatis\\generator\\internal\\db\\DatabaseIntrospector.java 增加calculateExtraColumnInformationProcessingDuplicateValues方法 在calculateExtraColumnInformation方法下方增加calculateExtraColumnInformationProcessingDuplicateValues方法\nprivate void calculateExtraColumnInformationProcessingDuplicateValues(String introspectedColumnJavaProperty, Map.Entry\u0026lt;ActualTableName, List\u0026lt;IntrospectedColumn\u0026gt;\u0026gt; entry) { int count = 0; for (IntrospectedColumn introspectedColumn : entry.getValue()) { if (introspectedColumn.getJavaProperty().equals(introspectedColumnJavaProperty)) { count++; if (count \u0026gt; 1) { introspectedColumn.setJavaProperty(introspectedColumnJavaProperty + \u0026quot;_\u0026quot;); calculateExtraColumnInformationProcessingDuplicateValues(introspectedColumnJavaProperty + \u0026quot;_\u0026quot;, entry); } } } }  修改calculateExtraColumnInformation方法 else if (isTrue(tc.getProperty(PropertyRegistry.TABLE_USE_GG_COLUMN_NAMES))) { introspectedColumn.setJavaProperty(ChineseCharToEn.getPYString(calculatedColumnName)); introspectedColumn.setColumnNameDelimited(true); }  for (IntrospectedColumn introspectedColumn : entry.getValue()) { calculateExtraColumnInformationProcessingDuplicateValues(introspectedColumn.getJavaProperty(), entry); }  使用 效果 使用前 使用后 mvn打包 修改pom.xml 打包 mvn clean install 或 mvn package  使用 使用jar包 mysql-connector-java-8.0.19.jar 下载地址 刚刚生成好的mybatis-generator-core-1.4.1-GG2.jar 下载地址 generatorConfig.xml 详细写法请参考http://mybatis.org/generator/configreference/xmlconfig.html\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026quot;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;classPathEntry location=\u0026quot;mysql-connector-java-8.0.19.jar\u0026quot; /\u0026gt; \u0026lt;context id=\u0026quot;MySql\u0026quot; defaultModelType=\u0026quot;flat\u0026quot; targetRuntime=\u0026quot;MyBatis3\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;mergeable\u0026quot; value=\u0026quot;false\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;beginningDelimiter\u0026quot; value=\u0026quot;`\u0026quot; /\u0026gt;\u0026lt;!-- 增加标记` --\u0026gt; \u0026lt;property name=\u0026quot;endingDelimiter\u0026quot; value=\u0026quot;`\u0026quot; /\u0026gt; \u0026lt;plugin type=\u0026quot;org.mybatis.generator.plugins.ToStringPlugin\u0026quot; /\u0026gt; \u0026lt;plugin type=\u0026quot;org.mybatis.generator.plugins.SerializablePlugin\u0026quot; /\u0026gt; \u0026lt;commentGenerator\u0026gt; \u0026lt;property name=\u0026quot;suppressDate\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;suppressAllComments\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;/commentGenerator\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026quot;com.mysql.cj.jdbc.Driver\u0026quot; connectionURL=\u0026quot;jdbc:mysql://localhost:3306/gen-test?characterEncoding=utf-8\u0026amp;amp;serverTimezone=GMT%2B8\u0026amp;amp;useSSL=false\u0026amp;amp;allowPublicKeyRetrieval=true\u0026quot; userId=\u0026quot;root\u0026quot; password=\u0026quot;123456\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;nullCatalogMeansCurrent\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;/jdbcConnection\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026quot;com.gen.springbootserver.mybatis.model\u0026quot; targetProject=\u0026quot;../src/main/java\u0026quot;\u0026gt;\u0026lt;/javaModelGenerator\u0026gt; \u0026lt;sqlMapGenerator targetPackage=\u0026quot;mapper\u0026quot; targetProject=\u0026quot;../src/main/resources\u0026quot;\u0026gt;\u0026lt;/sqlMapGenerator\u0026gt; \u0026lt;javaClientGenerator targetPackage=\u0026quot;com.gen.springbootserver.mybatis.dao\u0026quot; targetProject=\u0026quot;../src/main/java\u0026quot; type=\u0026quot;XMLMAPPER\u0026quot;\u0026gt;\u0026lt;/javaClientGenerator\u0026gt; \u0026lt;table tableName=\u0026quot;testgen\u0026quot; domainObjectName=\u0026quot;Testgen\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;modelOnly\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;useGGColumnNames\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt;\u0026lt;!-- 中文字段转首字母大写，特殊字符替换 --\u0026gt; \u0026lt;generatedKey column=\u0026quot;id\u0026quot; sqlStatement=\u0026quot;Mysql\u0026quot; identity=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 插入或修改返回主键 --\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt;  执行命令 进入目标文件目录，cmd执行\njava -jar mybatis-generator-core-1.4.1-GG.jar -configfile generatorConfig.xml -overwrite  源码下载地址\n","date":1617503933,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1617503933,"objectID":"710713512de5daf9689f43d580f80cd1","permalink":"https://cytgenkidu.github.io/post/mybatis-generator-core%E6%89%A9%E5%B1%95/","publishdate":"2021-04-04T10:38:53+08:00","relpermalink":"/post/mybatis-generator-core%E6%89%A9%E5%B1%95/","section":"post","summary":"如果你想在mybatis generator 自动生成mapper xml model等的时候，调整生成java的数据库类型（数据类型转换）、生成分页语句、or连接的多列模糊查询、含中文特殊字符处理。末尾有源码的地址和jar.\n准备工作 下载源码：https://github.com/mybatis/generator 其中，mybatis-generator-core目录 是该项目的源码，主要修改这里。 注：本例是对mybatis-generator-core1.4.1的扩展，其他版本修改过程类似。 目录如下： 修改 mybatis-generator 中数据库类型和 Java 类型的映射关系 本例是将原本数据库的TIMESTAMP 映射为 Date 类型， 改为 数据库的TIMESTAMP 映射为 LocalDateTime类型。\n注： 仅为示例，其他类型修改类似。 mybatis generator 本身可直接将TIMESTAMP映射为LocalDateTime。具体使用方法请参考http://mybatis.org/generator/configreference/javaTypeResolver.html\n修改文件位置为src\\main\\java\\org\\mybatis\\generator\\internal\\types\\JavaTypeResolverDefaultImpl.java // typeMap.put(Types.TIMESTAMP, new JdbcTypeInformation(\u0026quot;TIMESTAMP\u0026quot;, //$NON-NLS-1$ // new FullyQualifiedJavaType(Date.class.getName()))); typeMap.put(Types.TIMESTAMP, new JdbcTypeInformation(\u0026quot;TIMESTAMP\u0026quot;, //$NON-NLS-1$ new FullyQualifiedJavaType(LocalDateTime.class.getName())));  这样就会将数据库的TIMESTAMP映射为java的LocalDateTime。\n增加物理分页 适用于targetRuntime=\u0026ldquo;MyBatis3\u0026rdquo;\n增加代码位置 src\\main\\java\\org\\mybatis\\generator\\codegen\\mybatis3\\xmlmapper\\elements\\SelectByExampleWithBLOBsElementGenerator.java 和 src\\main\\java\\org\\mybatis\\generator\\codegen\\mybatis3\\xmlmapper\\elements\\SelectByExampleWithoutBLOBsElementGenerator.java\nifElement = new XmlElement(\u0026quot;if\u0026quot;); //$NON-NLS-1$ ifElement.addAttribute(new Attribute(\u0026quot;test\u0026quot;, \u0026quot;limitStart \u0026gt;= 0 and limitEnd \u0026gt; 0\u0026quot;)); //$NON-NLS-1$ //$NON-NLS-2$ ifElement.addElement(new TextElement(\u0026quot;limit ${limitStart},${limitEnd}\u0026quot;)); //$NON-NLS-1$ answer.","tags":["java","mybatis"],"title":"mybatis generator插件自定义修改-[修改数据类型与java类型映射关系+增加分页+增加多字段模糊查询+增加中文字段特殊字符转化]","type":"post"},{"authors":[],"categories":[],"content":" 思维题-智力题 赛马问题 赛马问题: 有36匹马，6个跑道，没有计时器，请赛马确定，36匹马中的前三名。 请问最少比赛几次？ 赛马问题：有25匹马，5个跑道，没有计时器，请赛马确定，25匹马中的前三名。 请问最少比赛几次？ ...  烧香问题 烧香问题: 有一个种香，材质不均匀,但是每一根这样的香，燃烧完恰好是1个小时 给你2跟香，帮我确定一个15分钟的时间段  ","date":1614823174,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1614823174,"objectID":"e593d2cd997a1431d8ed117801871695","permalink":"https://cytgenkidu.github.io/post/%E6%80%9D%E7%BB%B4%E9%A2%98%E6%99%BA%E5%8A%9B%E9%A2%98/","publishdate":"2021-03-04T09:59:34+08:00","relpermalink":"/post/%E6%80%9D%E7%BB%B4%E9%A2%98%E6%99%BA%E5%8A%9B%E9%A2%98/","section":"post","summary":" 思维题-智力题 赛马问题 赛马问题: 有36匹马，6个跑道，没有计时器，请赛马确定，36匹马中的前三名。 请问最少比赛几次？ 赛马问题：有25匹马，5个跑道，没有计时器，请赛马确定，25匹马中的前三名。 请问最少比赛几次？ ...  烧香问题 烧香问题: 有一个种香，材质不均匀,但是每一根这样的香，燃烧完恰好是1个小时 给你2跟香，帮我确定一个15分钟的时间段  ","tags":[],"title":"思维题智力题","type":"post"},{"authors":[],"categories":["前端","Nodejs"],"content":" 环境准备 安装 images 库 npm install images  安装 imageinfo 库 npm install imageinfo  实现 本例 addimageinfo.js 与 marklogo.png 、imagest文件夹、node_modules 文件夹 在同一目录下。\n含子文件也可实现\nJS代码 若直接使用需修改一下信息\nvar logomarkimg = images('./marklogo.png');//水印位置 var rmimgpath = \u0026quot;./imagest/img/\u0026quot;;//添加图片文件加位置 var mark = \u0026quot;logo_\u0026quot;;//另存图片前缀，若为\u0026quot;\u0026quot;则替换原图片  完整代码 addimageinfo.js\n//引用文件系统模块 var fs = require(\u0026quot;fs\u0026quot;); //引用imageinfo模块 var imageInfo = require(\u0026quot;imageinfo\u0026quot;); //引用images模块 var images = require('images'); var logomarkimg = images('./marklogo.png');//水印位置 var rmimgpath = \u0026quot;./imagest/img/\u0026quot;;//添加图片文件加位置 var mark = \u0026quot;logo_\u0026quot;;//另存图片前缀，若为\u0026quot;\u0026quot;则替换原图片 function readFileList(path, filesList) { var files = fs.readdirSync(path); files.forEach(function (itm, index) { var stat = fs.statSync(path + itm); if (stat.isDirectory()) { //递归读取文件 readFileList(path + itm + \u0026quot;/\u0026quot;, filesList) } else { var obj = {};//定义一个对象存放文件的路径和名字 obj.path = path;//路径 obj.filename = itm//名字 filesList.push(obj); } }) } var getFiles = { //获取文件夹下的所有文件 getFileList: function (path) { var filesList = []; readFileList(path, filesList); return filesList; }, //获取文件夹下的所有图片 getImageFiles: function (path) { var imageList = []; this.getFileList(path).forEach((item) =\u0026gt; { var ms = imageInfo(fs.readFileSync(item.path + item.filename)); ms.mimeType \u0026amp;\u0026amp; (imageList.push(item)) }); return imageList; } }; //获取文件夹下的所有图片 var photos = getFiles.getImageFiles(rmimgpath); for (var i = 0; i \u0026lt; photos.length; i++) { var sourceImgpath = photos[i].path; var sourceImgname = photos[i].filename; var sourceImg = images(sourceImgpath + sourceImgname); var sWidth = sourceImg.width(); var sHeight = sourceImg.height(); var wmWidth = logomarkimg.width(); var wmHeight = logomarkimg.height(); images(sourceImg) // 设置绘制的坐标位置，右下角距离 10px .draw(logomarkimg, sWidth - wmWidth - 10, sHeight - wmHeight - 10) // 保存格式会自动识别 .save(sourceImgpath + mark + sourceImgname + ''); }  运行 在目录下，运行node命令\nnode ./addimageinfo.js  查看效果 ","date":1613571780,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1613571780,"objectID":"1ca8fa35f339bdfe95f0dfb374a6dffa","permalink":"https://cytgenkidu.github.io/post/nodejs%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0/","publishdate":"2021-02-17T22:23:00+08:00","relpermalink":"/post/nodejs%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0/","section":"post","summary":"环境准备 安装 images 库 npm install images  安装 imageinfo 库 npm install imageinfo  实现 本例 addimageinfo.js 与 marklogo.png 、imagest文件夹、node_modules 文件夹 在同一目录下。\n含子文件也可实现\nJS代码 若直接使用需修改一下信息\nvar logomarkimg = images('./marklogo.png');//水印位置 var rmimgpath = \u0026quot;./imagest/img/\u0026quot;;//添加图片文件加位置 var mark = \u0026quot;logo_\u0026quot;;//另存图片前缀，若为\u0026quot;\u0026quot;则替换原图片  完整代码 addimageinfo.js\n//引用文件系统模块 var fs = require(\u0026quot;fs\u0026quot;); //引用imageinfo模块 var imageInfo = require(\u0026quot;imageinfo\u0026quot;); //引用images模块 var images = require('images'); var logomarkimg = images('./marklogo.png');//水印位置 var rmimgpath = \u0026quot;./imagest/img/\u0026quot;;//添加图片文件加位置 var mark = \u0026quot;logo_\u0026quot;;//另存图片前缀，若为\u0026quot;\u0026quot;则替换原图片 function readFileList(path, filesList) { var files = fs.","tags":["Nodejs","图片批量添加水印"],"title":"Nodejs给图片批量添加水印","type":"post"},{"authors":[],"categories":[],"content":" 连接出错：检查mysql连接，数据库的大小写 Mysql Connector Net 未安装或版本太高 写在过高版本，下载Mysql Connector Net 8.0.16 版本，安装。 重启PowerBI.  注 ：mysql-connector-net-8.0.16.msi下载地址：\n链接：https://pan.baidu.com/s/1gxDwPStOjYSQmFFwNPI1ew 提取码：7goq 复制这段内容后打开百度网盘手机App，操作更方便哦\u0026ndash;来自百度网盘超级会员V5的分享\n\r\r\r\r\r\r ","date":1611570457,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611570457,"objectID":"cce0ab0f133b6fccb1c4004e20f33903","permalink":"https://cytgenkidu.github.io/post/powerbi-mysql-error2/","publishdate":"2021-01-25T18:27:37+08:00","relpermalink":"/post/powerbi-mysql-error2/","section":"post","summary":" 连接出错：检查mysql连接，数据库的大小写 Mysql Connector Net 未安装或版本太高 写在过高版本，下载Mysql Connector Net 8.0.16 版本，安装。 重启PowerBI.  注 ：mysql-connector-net-8.0.16.msi下载地址：\n链接：https://pan.baidu.com/s/1gxDwPStOjYSQmFFwNPI1ew 提取码：7goq 复制这段内容后打开百度网盘手机App，操作更方便哦\u0026ndash;来自百度网盘超级会员V5的分享\n\r\r\r\r\r\r ","tags":[],"title":"power BI 连接mysql出现:“MySQL: Authentication method 'caching_sha2_password' not supported by any of the available plugins.”","type":"post"},{"authors":[],"categories":[],"content":" 检查是否开启mysql服务 设置中清除权限，重新建立mysql数据库   清除权限【若第一次设置链接错误后，重写会一直显示错误。产生原因是设置的内容被PBI记录，需清空在重新设置。】  \r\r\r\r\r\r\r\r\r\r 设置好后点击连接，完成。\n","date":1611560157,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611560157,"objectID":"61e03ba77711697c256283a9083e985c","permalink":"https://cytgenkidu.github.io/post/powerbi-mysql-error1/","publishdate":"2021-01-25T15:35:57+08:00","relpermalink":"/post/powerbi-mysql-error1/","section":"post","summary":"检查是否开启mysql服务 设置中清除权限，重新建立mysql数据库   清除权限【若第一次设置链接错误后，重写会一直显示错误。产生原因是设置的内容被PBI记录，需清空在重新设置。】  \r\r\r\r\r\r\r\r\r\r 设置好后点击连接，完成。","tags":[],"title":"PowerBI连接Mysql数据库出现未将对象引用设置到对象的实例的问题","type":"post"},{"authors":[],"categories":["VSCode","C语言","环境配置"],"content":" VSCode安装 下载地址：https://code.visualstudio.com/Download\nMingw-w64 下载 下载地址：https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/\n下载并解压后配置PATH\n\r\r\r\r\r\r\r\r\r\r\r\r 安装VSCode 插件 \r\r\r 配置运行文件 \r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r  新建一个工程，然后建一个.c文件，随便写点代码，运行它，.vscode文件夹，文件夹下会生成launch.json文件，另外可以通过在该文件夹下新建 tasks.json。 配置 launch.json文件  { \u0026quot;configurations\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;(gdb) Launch\u0026quot;, // 配置名称，将会在启动配置的下拉菜单中显示 \u0026quot;type\u0026quot;: \u0026quot;cppdbg\u0026quot;, // 配置类型，这里只能为cppdbg \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;, // 请求配置类型，可以为launch（启动）或attach（附加） \u0026quot;program\u0026quot;: \u0026quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe\u0026quot;, // 将要进行调试的程序的路径 \u0026quot;stopAtEntry\u0026quot;: false, // 设为true时程序将暂停在程序入口处，一般设置为false \u0026quot;cwd\u0026quot;: \u0026quot;${workspaceFolder}\u0026quot;, // 调试程序时的工作目录，一般为${workspaceFolder}即代码所在目录 \u0026quot;environment\u0026quot;: [], \u0026quot;externalConsole\u0026quot;: false, // 如果为true，则为调试对象启动控制台。如果为false，它在Linux和Windows上会显示在集成控制台中 \u0026quot;MIMode\u0026quot;: \u0026quot;gdb\u0026quot;, \u0026quot;miDebuggerPath\u0026quot;: \u0026quot;D:\\\\软件安装位置\\\\mingw64\\\\bin\\\\gdb.exe\u0026quot;, // miDebugger的路径，注意这里要与MinGw的路径对应 \u0026quot;preLaunchTask\u0026quot;: \u0026quot;gcc\u0026quot;, \u0026quot;setupCommands\u0026quot;: [ { \u0026quot;description\u0026quot;: \u0026quot;为 gdb 启用整齐打印\u0026quot;, \u0026quot;text\u0026quot;: \u0026quot;-enable-pretty-printing\u0026quot;, \u0026quot;ignoreFailures\u0026quot;: true } ] } ] }   配置 task.json文件  { \u0026quot;version\u0026quot;: \u0026quot;2.0.0\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;gcc\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-g\u0026quot;, \u0026quot;${file}\u0026quot;, \u0026quot;-o\u0026quot;, \u0026quot;${fileDirname}/${fileBasenameNoExtension}.exe\u0026quot; ],// 编译命令参数 \u0026quot;problemMatcher\u0026quot;: { \u0026quot;owner\u0026quot;: \u0026quot;cpp\u0026quot;, \u0026quot;fileLocation\u0026quot;: [ \u0026quot;relative\u0026quot;, \u0026quot;${workspaceRoot}\u0026quot; ], \u0026quot;pattern\u0026quot;: { \u0026quot;regexp\u0026quot;: \u0026quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\u0026quot;, \u0026quot;file\u0026quot;: 1, \u0026quot;line\u0026quot;: 2, \u0026quot;column\u0026quot;: 3, \u0026quot;severity\u0026quot;: 4, \u0026quot;message\u0026quot;: 5 } }, \u0026quot;group\u0026quot;: { \u0026quot;kind\u0026quot;: \u0026quot;build\u0026quot;, \u0026quot;isDefault\u0026quot;: true } }   配置 c_cpp_properties.json 文件  { \u0026quot;configurations\u0026quot;: [{ \u0026quot;name\u0026quot;: \u0026quot;MinGW64\u0026quot;, \u0026quot;includePath\u0026quot;: [ \u0026quot;${workspaceFolder}/**\u0026quot;, \u0026quot;D:/软件安装位置/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include\u0026quot;, \u0026quot;D:/软件安装位置/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed\u0026quot;, \u0026quot;D:/软件安装位置/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include\u0026quot; ], \u0026quot;defines\u0026quot;: [ \u0026quot;_DEBUG\u0026quot;, \u0026quot;UNICODE\u0026quot;, \u0026quot;_UNICODE\u0026quot; ], \u0026quot;compilerPath\u0026quot;: \u0026quot;D:\\\\软件安装位置\\\\mingw64\\\\bin\\\\gcc.exe\u0026quot;, \u0026quot;cStandard\u0026quot;: \u0026quot;c11\u0026quot;, \u0026quot;cppStandard\u0026quot;: \u0026quot;c++17\u0026quot;, \u0026quot;intelliSenseMode\u0026quot;: \u0026quot;gcc-x64\u0026quot; }], \u0026quot;version\u0026quot;: 4 }   运行  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { printf(\u0026quot;hello world\u0026quot;); return 0; }  ","date":1611221098,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611221098,"objectID":"400cef0c5c9885e3a40f4f547641cd5f","permalink":"https://cytgenkidu.github.io/post/%E4%BD%BF%E7%94%A8vscode%E8%BF%90%E8%A1%8Cc%E8%AF%AD%E8%A8%80/","publishdate":"2021-01-21T17:24:58+08:00","relpermalink":"/post/%E4%BD%BF%E7%94%A8vscode%E8%BF%90%E8%A1%8Cc%E8%AF%AD%E8%A8%80/","section":"post","summary":"使用VSCode运行C语言","tags":["VSCode","环境配置"],"title":"使用VSCode运行C语言","type":"post"},{"authors":[],"categories":["VSCode","环境配置","java"],"content":" 安装扩展 \r\r\r\r 安装完成重启 VSCode。\n配置Maven 点击左下角设置图标-\u0026gt;设置，打开设置内容,然后点击右侧的打开json格式setting：\n\r\r\r\r 然后把maven的可执行文件路径配置、maven的setting路径配置、java.home的路径配置，拷贝到右侧的用户设置区域并且设置为自己电脑的实际路径。\n设置内容如下：\n{ \u0026quot;workbench.startupEditor\u0026quot;: \u0026quot;newUntitledFile\u0026quot;, \u0026quot;java.errors.incompleteClasspath.severity\u0026quot;: \u0026quot;ignore\u0026quot;, \u0026quot;java.home\u0026quot;:\u0026quot;C:\\\\Program Files (x86)\\\\Java\\\\jdk1.8.0_192\u0026quot;, \u0026quot;java.configuration.maven.userSettings\u0026quot;: \u0026quot;D:\\\\软件安装位置\\\\apache-maven-3.6.0\\\\conf\\\\settings.xml\u0026quot;, \u0026quot;maven.executable.path\u0026quot;: \u0026quot;D:\\\\软件安装位置\\\\apache-maven-3.6.0\\\\bin\\\\mvn.cmd\u0026quot;, \u0026quot;maven.terminal.useJavaHome\u0026quot;: true, \u0026quot;maven.terminal.customEnv\u0026quot;: [ { \u0026quot;environmentVariable\u0026quot;: \u0026quot;JAVA_HOME\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;C:\\\\Program Files (x86)\\\\Java\\\\jdk1.8.0_192\u0026quot; } ], \u0026quot;git.path\u0026quot;: \u0026quot;C:\\\\Program Files\\\\Git\\\\bin\\\\git.exe\u0026quot;, \u0026quot;workbench.colorTheme\u0026quot;: \u0026quot;Visual Studio Dark\u0026quot;, // \u0026quot;vscodePluginDemo.showTip\u0026quot;: false, \u0026quot;files.encoding\u0026quot;: \u0026quot;utf8\u0026quot;, \u0026quot;javascript.implicitProjectConfig.experimentalDecorators\u0026quot;: true, \u0026quot;vscodePluginDemo.showTip\u0026quot;: true, \u0026quot;files.exclude\u0026quot;: { \u0026quot;**/.classpath\u0026quot;: true, \u0026quot;**/.project\u0026quot;: true, \u0026quot;**/.settings\u0026quot;: true, \u0026quot;**/.factorypath\u0026quot;: true }, \u0026quot;editor.largeFileOptimizations\u0026quot;: false, \u0026quot;terminal.integrated.shell.windows\u0026quot;: \u0026quot;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe\u0026quot;, \u0026quot;java.jdt.ls.vmargs\u0026quot;: \u0026quot;-noverify -Xmx1G -XX:+UseG1GC -XX:+UseStringDeduplication -javaagent:\\\u0026quot;C:\\\\Users\\\\15762\\\\.vscode\\\\extensions\\\\gabrielbb.vscode-lombok-0.9.8/server/lombok.jar\\\u0026quot;\u0026quot;, \u0026quot;terminal.integrated.rendererType\u0026quot;: \u0026quot;dom\u0026quot;, \u0026quot;editor.suggestSelection\u0026quot;: \u0026quot;first\u0026quot;, \u0026quot;vsintellicode.modify.editor.suggestSelection\u0026quot;: \u0026quot;automaticallyOverrodeDefaultValue\u0026quot;, \u0026quot;git.enableSmartCommit\u0026quot;: true, \u0026quot;typescript.updateImportsOnFileMove.enabled\u0026quot;: \u0026quot;always\u0026quot;, \u0026quot;[html]\u0026quot;: { \u0026quot;editor.defaultFormatter\u0026quot;: \u0026quot;HookyQR.beautify\u0026quot; }, \u0026quot;[json]\u0026quot;: { \u0026quot;editor.defaultFormatter\u0026quot;: \u0026quot;HookyQR.beautify\u0026quot; }, \u0026quot;vsicons.projectDetection.autoReload\u0026quot;: true }  如果mvn更新包速度很慢，建议使用阿里云的镜像速度会快点（修改maven的setting.xml配置如下）：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;settings xmlns=\u0026quot;http://maven.apache.org/SETTINGS/1.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\u0026quot;\u0026gt; \u0026lt;pluginGroups\u0026gt; \u0026lt;/pluginGroups\u0026gt; \u0026lt;proxies\u0026gt; \u0026lt;/proxies\u0026gt; \u0026lt;servers\u0026gt; \u0026lt;/servers\u0026gt; \u0026lt;mirrors\u0026gt; \u0026lt;!-- 阿里云仓库 --\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/repositories/central/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;/settings\u0026gt;  配置完成重启 VSCode。\n创建Spring Boot项目 使用快捷键(Ctrl+Shift+P)命令窗口，输入 Spring 选择创建 Gradle 项目。\n","date":1560349917,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1560349917,"objectID":"094212e2128834f09ed79fd017fb3a74","permalink":"https://cytgenkidu.github.io/post/vscode%E6%90%AD%E5%BB%BAjava%E7%8E%AF%E5%A2%83/","publishdate":"2019-06-12T22:31:57+08:00","relpermalink":"/post/vscode%E6%90%AD%E5%BB%BAjava%E7%8E%AF%E5%A2%83/","section":"post","summary":"VSCode搭建java环境","tags":["VSCode","环境配置","java"],"title":"VSCode搭建java环境","type":"post"},{"authors":["Tgenkidu Cy"],"categories":["JHipster"],"content":" 在本章中，我们将看到如何使用业务实体和模型。\n使用命令行生成实体 \u0026gt; jhipster entity Invoice  使用JHipster域语言进行实体建模 JHipster Domain Language (JDL)用于为JHipster应用程序创建域模型。它提供了一个简单且用户友好的DSL来描述实体及其关系(仅适用于SQL数据库)。\nJDL是为应用程序创建实体的推荐方法，它可以替代JHipster提供的实体生成器，在创建大量实体时，可能很难使用JHipster提供的实体生成器。JDL通常写在一个或多个扩展名为.jh的文件中。\n使用JDL进行实体建模 实体声明语法\nentity \u0026lt;entity name\u0026gt; ([\u0026lt;table name\u0026gt;]) { \u0026lt;field name\u0026gt; \u0026lt;type\u0026gt; [\u0026lt;validation\u0026gt;*] }   \u0026lt;entity name\u0026gt;是实体的名称，将用于类名和表名。可以使用可选的\u0026lt;Table name\u0026gt;参数重写表名。 \u0026lt;field name\u0026gt;是您希望用于实体的字段(属性)的名称，\u0026lt;type\u0026gt;是字段类型，如String、Integer等。  \r请参考JHipster 域语言 (JDL)，查看所有支持类型。\n\r\r ID字段将自动创建，因此不需要在JDL中指定。 \u0026lt;validation\u0026gt;是可选的，可以根据字段类型支持的验证指定一个或多个字段的\u0026lt;validation\u0026gt;。对于max length和pattern等验证，可以在大括号中指定值。  示例如下：\nentity Customer { /** Name field */ name String required, age Integer, address String maxlength(100) pattern(/[a-Z0-9]+/) }  枚举也可以使用以下语法声明:\nenum \u0026lt;enum name\u0026gt; { \u0026lt;VALUE\u0026gt;* }  示例如下：\nenum Language { ENGLISH, DUTCH, FRENCH }  关系管理 实体之间的关系可以使用以下语法声明:\nrelationship \u0026lt;type\u0026gt; { \u0026lt;from entity\u0026gt;[{\u0026lt;relationship name\u0026gt;[(\u0026lt;display field\u0026gt;)] \u0026lt;validation\u0026gt;*}] to \u0026lt;to entity\u0026gt;[{\u0026lt;relationship name\u0026gt;[(\u0026lt;display field\u0026gt;)] \u0026lt;validation\u0026gt;*}] }   \u0026lt;type\u0026gt;是来自OneToMany、ManyToOne、OneToOne或ManyToMany的类型，它声明了\u0026lt;from entity\u0026gt; and \u0026lt;to entity\u0026gt;之间的关系类型。 \u0026lt;from entity\u0026gt;是关系或源的所有者实体的名称。\u0026lt;to entity\u0026gt;是关系的目标。 \u0026lt;relationship name\u0026gt;是可选的，可用于指定要在域对象中为关系创建的字段名。\u0026lt;display field\u0026gt;可以在大括号中指定来控制要在生成的web页面的下拉菜单中显示的实体的字段，默认情况下将使用ID字段。\u0026lt;validation\u0026gt;可以在\u0026lt;from entity\u0026gt;或\u0026lt;to entity\u0026gt;上指定，并且是可选的。目前，只支持required。 同一类型的多个关系可以在同一个块中声明，用逗号分隔。  示例如下：\nentity Book entity Author entity Tag relationship OneToMany { Author{book} to Book{writer(name) required}, Book{tag} to Tag }  DTO、服务和分页选项 JDL还允许我们轻松地声明与实体相关的选项。目前支持的选项有:\n service :默认情况下，JHipster生成直接调用实体存储库的REST资源类。这是最简单的选择，但在实际场景中，我们可能需要一个服务层来处理业务逻辑。该选项允许我们使用简单的Spring服务bean类或传统的服务bean接口和实现创建服务层。可能的值是serviceClass和serviceImpl。 dto :默认情况下，域对象直接用于创建的REST端点，这在某些情况下可能不太理想，您可能希望使用中介数据传输对象(DTO)来进行更多的控制。JHipster允许我们使用Mapstruct生成DTO层，这是一个自动生成DTO类的注释预处理器库。建议在使用DTO时使用服务层。一个可能的值是mapstruct。更多细节请参考https://www.jhipster.tech/using-dtos。 filter ：该选项允许我们为实体启用基于JPA的过滤功能。这只在使用服务层时才有效。更多细节请参考http://www.jhipster.tech/entities-filtering。 paginate ：这个选项允许我们为实体启用分页。这将在资源层上启用分页，并在客户端实现分页选项。可能的值是分页器、分页和无限滚动。 noFluentMethod ：这允许我们为生成的实体域对象禁用Fluent API样式设置器。 skipClient/skipServer ：这些选项允许我们在生成期间跳过客户端代码或服务器端代码。 angularSuffix ：该选项允许我们在前端代码中为文件夹和类名指定后缀。  选项声明的一般语法：\n\u0026lt; option \u0026gt; \u0026lt;ENTITIES | * | all\u0026gt; [with \u0026lt;VALUE\u0026gt;] [except \u0026lt;ENTITIES\u0026gt;]。  示例如下：\nentity A entity B ... entity Z dto * with mapstruct service A with serviceImpl service B with serviceClass paginate * with pagination except B, C paginate B, C with infinite-scroll filter A, B  JDL Studio 可使用JDL Studio来创建我们的JDL文件。它是由JHipster团队构建的一个在线web应用程序，用于在可视化编辑器中创建JDL文件。该工具显示了创建实体模型的可视化表示，并允许您导入/导出JDL和捕获图像快照:\n\r\r 使用JHipster生成实体 \u0026gt; cd my-shop \u0026gt; jhipster import-jdl shop.jh  \r\r 生成代码 以Project实体为例：\n.jhipster文件夹 将会在根目录下生成一个.jhipster文件夹，查看project.json。\n{ \u0026quot;name\u0026quot;: \u0026quot;Product\u0026quot;, \u0026quot;fields\u0026quot;: [ { \u0026quot;fieldName\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;fieldType\u0026quot;: \u0026quot;String\u0026quot;, \u0026quot;fieldValidateRules\u0026quot;: [ \u0026quot;required\u0026quot; ] }, { \u0026quot;fieldName\u0026quot;: \u0026quot;description\u0026quot;, \u0026quot;fieldType\u0026quot;: \u0026quot;String\u0026quot; }, { \u0026quot;fieldName\u0026quot;: \u0026quot;price\u0026quot;, \u0026quot;fieldType\u0026quot;: \u0026quot;BigDecimal\u0026quot;, \u0026quot;fieldValidateRules\u0026quot;: [ \u0026quot;required\u0026quot;, \u0026quot;min\u0026quot; ], \u0026quot;fieldValidateRulesMin\u0026quot;: 0 }, { \u0026quot;fieldName\u0026quot;: \u0026quot;size\u0026quot;, \u0026quot;fieldType\u0026quot;: \u0026quot;Size\u0026quot;, \u0026quot;fieldValues\u0026quot;: \u0026quot;S,M,L,XL,XXL\u0026quot;, \u0026quot;fieldValidateRules\u0026quot;: [ \u0026quot;required\u0026quot; ] }, { \u0026quot;fieldName\u0026quot;: \u0026quot;image\u0026quot;, \u0026quot;fieldType\u0026quot;: \u0026quot;byte[]\u0026quot;, \u0026quot;fieldTypeBlobContent\u0026quot;: \u0026quot;image\u0026quot; } ], \u0026quot;relationships\u0026quot;: [ { \u0026quot;relationshipType\u0026quot;: \u0026quot;many-to-one\u0026quot;, \u0026quot;otherEntityName\u0026quot;: \u0026quot;productCategory\u0026quot;, \u0026quot;otherEntityRelationshipName\u0026quot;: \u0026quot;product\u0026quot;, \u0026quot;relationshipName\u0026quot;: \u0026quot;productCategory\u0026quot;, \u0026quot;otherEntityField\u0026quot;: \u0026quot;name\u0026quot; } ], \u0026quot;changelogDate\u0026quot;: \u0026quot;20190415054558\u0026quot;, \u0026quot;javadoc\u0026quot;: \u0026quot;shop\u0026quot;, \u0026quot;entityTableName\u0026quot;: \u0026quot;product\u0026quot;, \u0026quot;dto\u0026quot;: \u0026quot;no\u0026quot;, \u0026quot;pagination\u0026quot;: \u0026quot;pagination\u0026quot;, \u0026quot;service\u0026quot;: \u0026quot;serviceClass\u0026quot;, \u0026quot;jpaMetamodelFiltering\u0026quot;: false, \u0026quot;fluentMethods\u0026quot;: true, \u0026quot;clientRootFolder\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;applications\u0026quot;: \u0026quot;*\u0026quot; }  服务器端源代码 实体类 在src/main/java/com/mycompany/myapp/domain文件加下，将会生成Project.java。\n实体类定义字段和关系。\n//Swagger使用这个注释在端点中使用实体时显示有用的文档: @ApiModel(description = \u0026quot;shop\u0026quot;) //这些JPA注释将POJO声明为一个实体并将其映射到一个SQL表: @Entity @Table(name = \u0026quot;product\u0026quot;) //是Hibernate注释，它允许我们为这个实体启用二级缓存。在我们使用Hazelcast的情况下: @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE) public class Product implements Serializable { private static final long serialVersionUID = 1L; //id字段是特殊的，它被映射为一个生成的值字段。根据数据库的不同，这个字段将使用Hibernate提供的本地生成技术或序列。 @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \u0026quot;sequenceGenerator\u0026quot;) @SequenceGenerator(name = \u0026quot;sequenceGenerator\u0026quot;) private Long id; @NotNull @Column(name = \u0026quot;name\u0026quot;, nullable = false) private String name; @Column(name = \u0026quot;description\u0026quot;) private String description; //JPA注释用于将列映射到字段，还可以用于声明字段的属性，如可空、精度、比例、惟一等等: @NotNull @DecimalMin(value = \u0026quot;0\u0026quot;) @Column(name = \u0026quot;price\u0026quot;, precision = 10, scale = 2, nullable = false) private BigDecimal price; @NotNull @Enumerated(EnumType.STRING) @Column(name = \u0026quot;jhi_size\u0026quot;, nullable = false) private Size size; //是Bean验证注释，支持对字段进行验证 @Lob @Column(name = \u0026quot;image\u0026quot;) private byte[] image; @Column(name = \u0026quot;image_content_type\u0026quot;) private String imageContentType; //枚举数据 @ManyToOne @JsonIgnoreProperties(\u0026quot;products\u0026quot;) private ProductCategory productCategory; //setter、getter }  对应的表定义和约束使用Liquibase创建，可以在src/main/resources/config/Liquibase/changelog中找到，文件名\u0026lt;timestamp\u0026gt;_added_entity_Product和\u0026lt;timestamp\u0026gt;_added_entity_constraints_Product.xml，当我们重新加载或启动应用程序时，它会自动应用到数据库。\n实体的存储库接口 在src/main/java/com/mycompany/myapp/repository文件夹中，您将找到实体存储库服务。打开ProductRepository.java:\n@SuppressWarnings(\u0026quot;unused\u0026quot;) @Repository public interface ProjecyRepository extends JpaRepository\u0026lt;Projecy, Long\u0026gt; { }  repository服务只是一个扩展JpaRepository类的空接口。因为它是一个Spring数据存储库，所以实现是自动创建的，允许我们使用这个简单的接口声明执行所有CRUD操作。\n实体的服务类 由于我们选择为实体生成服务类，让我们来看一个在src/main/java/com/mycompany/myapp/service文件夹中，将找到实体存储库服务。打开ProductService.java:\n@Service @Transactional public class ProductService { private final Logger log = LoggerFactory.getLogger(ProductService.class); private final ProductRepository productRepository; public ProductService(ProductRepository productRepository) { this.productRepository = productRepository; } ... }  该服务使用构造函数注入来获取依赖项，这些依赖项在bean实例化期间由Spring自动注入。该服务还被标记为@Transactional，以启用数据访问的事务管理。该服务定义了CRUD操作方法。例如，findAll方法在向其添加只读事务规则时调用等效的存储库方法。您可以看到该方法已经支持分页并将结果作为Page返回。页面和可分页对象由Spring提供，让我们轻松控制分页:\n@Transactional(readOnly = true) public Page\u0026lt;Product\u0026gt; findAll(Pageable pageable) { log.debug(\u0026quot;Request to get all Products\u0026quot;); return productRepository.findAll(pageable); }  实体的资源类 在src/main/java/com/mycompany/myapp/web/rest文件夹中，您将找到实体资源服务。打开ProductResource.java:\n@RestController @RequestMapping(\u0026quot;/api\u0026quot;) public class ProductResource { ··· }  资源充当控制器层，在我们的示例中，它服务于客户端代码使用的其余端点。端点有一个到“/api”的基本映射:\n@PostMapping(\u0026quot;/products\u0026quot;) public ResponseEntity\u0026lt;Product\u0026gt; createProduct(@Valid @RequestBody Product product) throws URISyntaxException { log.debug(\u0026quot;REST request to save Product : {}\u0026quot;, product); if (product.getId() != null) { throw new BadRequestAlertException(\u0026quot;A new product cannot already have an ID\u0026quot;, ENTITY_NAME, \u0026quot;idexists\u0026quot;); } Product result = productService.save(product); return ResponseEntity.created(new URI(\u0026quot;/api/products/\u0026quot; + result.getId())) .headers(HeaderUtil.createEntityCreationAlert(ENTITY_NAME, result.getId().toString())) .body(result); }  这里所有的CRUD操作都有等价的映射方法。\n客户端源代码 实体的客户端资源在src/main/webapp/app/entities文件夹中创建。让我们看一下为Product文件夹中的Product实体创建的代码。\n实体的TypeScript模型类 让我们看看在src\\main\\webapp\\app\\shared\\model\\product.model.ts中生成的TypeScript模型。这直接映射到域对象:\nimport { IProductCategory } from 'app/shared/model/product-category.model'; export const enum Size { S = 'S', M = 'M', L = 'L', XL = 'XL', XXL = 'XXL' } export interface IProduct { id?: number; name?: string; description?: string; price?: number; size?: Size; imageContentType?: string; image?: any; productCategory?: IProductCategory; } export class Product implements IProduct { constructor( public id?: number, public name?: string, public description?: string, public price?: number, public size?: Size, public imageContentType?: string, public image?: any, public productCategory?: IProductCategory ) {} }  实体的Angular服务 ProductService是一个Angular服务，它与我们的REST端点交互，并在src\\main\\webapp\\app\\entities\\product\\product.service.ts中创建:\n@Injectable({ providedIn: 'root' }) export class ProductService { public resourceUrl = SERVER_API_URL + 'api/products'; constructor(protected http: HttpClient) {} create(product: IProduct): Observable\u0026lt;EntityResponseType\u0026gt; { return this.http.post\u0026lt;IProduct\u0026gt;(this.resourceUrl, product, { observe: 'response' }); } ··· }  正如您所看到的，服务有一个构造函数，按照与服务器端代码类似的模式注入依赖项。有一些方法将所有CRUD操作映射到后端REST资源。HTTP调用使用RxJS Observables提供异步流API。\n实体的Angular组件 对于一个实体，在组件中使用的四个文件和四个HTML文件中生成了六个组件类。\n在product.component.ts中定义的ProductComponent处理主清单屏幕。它使用product.component.html作为模板。组件管理视图及其操作。它还调用多个服务来获取数据并执行其他操作，如警报和事件广播:\n@Component({ selector: 'jhi-product', templateUrl: './product.component.html' }) export class ProductComponent implements OnInit, OnDestroy { ··· }  实体的Angular路由 我们需要一个路由声明，以便访问实体页面。这在product.route.ts中声明。\n{ path: ':id/view', component: ProductDetailComponent, resolve: { product: ProductResolve }, data: { authorities: ['ROLE_USER'], pageTitle: 'shopApp.product.home.title' }, canActivate: [UserRouteAccessService] }  data属性用于将元数据(如允许的角色和页面标题)传递给组件。canActivate属性中定义的UserRouteAccessService决定用户是否具有查看页面的授权，并使用权威元数据和身份验证细节进行验证。具有弹出框的路由，声明outlet: \u0026lsquo;popup\u0026rsquo;属性。\n实体的Angular模块 最后，我们有一个实体模块。Angular模块可以用来整合一个实体的所有组件、指令、管道和服务，这样它们就可以很容易地导入到其他模块中。ShopProductModule模块定义在product.module.ts中:\n@NgModule({ imports: [ShopSharedModule, RouterModule.forChild(ENTITY_STATES)], declarations: [ ProductComponent, ProductDetailComponent, ProductUpdateComponent, ProductDeleteDialogComponent, ProductDeletePopupComponent ], entryComponents: [ProductComponent, ProductUpdateComponent, ProductDeleteDialogComponent, ProductDeletePopupComponent], providers: [{ provide: JhiLanguageService, useClass: JhiLanguageService }], schemas: [CUSTOM_ELEMENTS_SCHEMA] }) export class ShopProductModule { constructor(private languageService: JhiLanguageService, private languageHelper: JhiLanguageHelper) { this.languageHelper.language.subscribe((languageKey: string) =\u0026gt; { if (languageKey !== undefined) { this.languageService.changeLanguage(languageKey); } }); } }  模块声明组件并注册它提供的服务。模块还导入共享模块，以便访问共享服务和组件。模块由src/main/webapp/app/entities/entity.module.ts中定义的ShopEntityModule导入。\n提交Git（可选择行执行） \u0026gt; git add --all \u0026gt; git commit -am \u0026quot;generated shop entity model\u0026quot;  链接与资源 jhipster学习网\n","date":1555036733,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1555036733,"objectID":"d042d655e84120b66c4118d40b655894","permalink":"https://cytgenkidu.github.io/post/jhipster-monoliyhic-entitymodel/","publishdate":"2019-04-12T10:38:53+08:00","relpermalink":"/post/jhipster-monoliyhic-entitymodel/","section":"post","summary":"在本章中，我们将看到如何使用业务实体和模型。\n使用命令行生成实体 \u0026gt; jhipster entity Invoice  使用JHipster域语言进行实体建模 JHipster Domain Language (JDL)用于为JHipster应用程序创建域模型。它提供了一个简单且用户友好的DSL来描述实体及其关系(仅适用于SQL数据库)。\nJDL是为应用程序创建实体的推荐方法，它可以替代JHipster提供的实体生成器，在创建大量实体时，可能很难使用JHipster提供的实体生成器。JDL通常写在一个或多个扩展名为.jh的文件中。\n使用JDL进行实体建模 实体声明语法\nentity \u0026lt;entity name\u0026gt; ([\u0026lt;table name\u0026gt;]) { \u0026lt;field name\u0026gt; \u0026lt;type\u0026gt; [\u0026lt;validation\u0026gt;*] }   \u0026lt;entity name\u0026gt;是实体的名称，将用于类名和表名。可以使用可选的\u0026lt;Table name\u0026gt;参数重写表名。 \u0026lt;field name\u0026gt;是您希望用于实体的字段(属性)的名称，\u0026lt;type\u0026gt;是字段类型，如String、Integer等。  \r请参考JHipster 域语言 (JDL)，查看所有支持类型。\n\r\r ID字段将自动创建，因此不需要在JDL中指定。 \u0026lt;validation\u0026gt;是可选的，可以根据字段类型支持的验证指定一个或多个字段的\u0026lt;validation\u0026gt;。对于max length和pattern等验证，可以在大括号中指定值。  示例如下：\nentity Customer { /** Name field */ name String required, age Integer, address String maxlength(100) pattern(/[a-Z0-9]+/) }  枚举也可以使用以下语法声明:\nenum \u0026lt;enum name\u0026gt; { \u0026lt;VALUE\u0026gt;* }  示例如下：","tags":["JHipster"],"title":"使用JHipster构建单一的Web应用程序-实体建模","type":"post"},{"authors":["Tgenkidu Cy"],"categories":["JHipster"],"content":" 文件结构 \r\r  src: 这是源文件夹，其中包含主应用程序源文件和测试源文件。 webpack: 这个文件夹包含用于开发、生产和测试的所有webpack客户端构建配置。 gradle: 这个文件夹有gradle包装器和额外的gradle构建脚本，这些脚本将由主要的gradle构建文件使用(如果选择Maven, JHipster也提供了类似的包装器)。 build.gradle: 这是gradle构建文件，它指定了应用程序的构建生命周期。它还指定了服务器端依赖项。构建使用gradle中定义的gradle.properties。还可以找到一个名为gradlew (gradlew.bat，用于Windows)的可执行文件，它允许您使用Gradle而无需安装它。 .yo-rc.json: 这是JHipster的配置文件。这个文件存储了我们在创建应用程序时选择的选项，并用于应用程序的更新和升级。 package.json: 这是NPM配置文件，它指定了所有客户端依赖项、客户端构建依赖项和任务。 tsconfig.json: 这是Typescript的配置。还有tsconfig-aot.json,用于Angular AOT (Ahead-of-Time) compilation。 tslint.json: 这是Typescript的lint配置。  src src文件夹内结构\nmain  docker: 保存应用程序的Dockerfile，并保存所选选项的docker配置。 java: 保存应用程序的主要java源代码。 resources: 保存Spring引导配置文件、Liquibase更改日志以及应用程序使用的静态资源，如服务器端i18n文件和电子邮件模板。 webapp: 保存Angular应用程序源代码和客户端静态内容，如图像、样式表、i18n文件等。  test  java:保存服务器端单元和集成测试源。 javascript:为客户端应用程序保存Karma单元测试规范和量角器端到端规范。 resources:保存应用程序用于测试的Spring配置文件和静态资源，如服务器端i18n文件和电子邮件模板。  服务端src/main/java src/main/java文件夹内重要部分。\n\r\r ShopApp.java 这是应用程序的主入口类。由于这是一个Spring引导应用程序，主类是可执行的，您可以通过在IDE中运行这个类来启动应用程序。\n注解 Spring JavaConfig注解\n@SpringBootApplication @EnableConfigurationProperties({LiquibaseProperties.class, ApplicationProperties.class})   @SpringBootApplication:是一个复合注解，包括@ComponentScan，和@SpringBootConfiguration，@EnableAutoConfiguration。  @ComponentScan：扫描当前包及其子包下被@Component，@Controller，@Service，@Repository注解标记的类并纳入到spring容器中进行管理。 @EnableAutoConfiguration：作用是启动自动的配置，意思就是Springboot根据你添加的jar包来配置你项目的默认配置。 @SpringBootConfiguration：继承自@Configuration，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到srping容器中，并且实例名就是方法名。  @EnableConfigurationProperties：帮助通过属性文件注册应用程序的其他配置。  main方法 public static void main(String[] args) { SpringApplication app = new SpringApplication(ShopApp.class); DefaultProfileUtil.addDefaultProfile(app); Environment env = app.run(args).getEnvironment(); logApplicationStartup(env); }  config 这个包包含用于数据库、缓存、WebSocket等的Spring bean配置。我们将在这里为应用程序配置各种选项。其中一些重要的类是:\nCacheConfiguration.java 该类为应用程序配置Hibernate二级缓存。由于我们选择Hazelcast作为缓存提供程序，所以该类的配置方式相同。\nDatabaseConfiguration.java 该类为应用程序配置数据库，并为应用程序启用事务管理、JPA审计和JPA存储库。它还配置Liquibase来管理用于开发的DB迁移和H2数据库。\nWebConfigurer.java 这是我们设置HTTP缓存头、MIME映射、静态资产位置和CORS(跨源资源共享)的地方。\nSecurityConfiguration.java 配置了应用程序的安全性。\n 启用了WebSecurity和MethodSecurity，因此我们可以在单个方法上使用 @Secured and @Pre/PostAuthorize。  @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)   忽略Spring安全配置中的静态内容和某些api：  @Override public void configure(WebSecurity web) throws Exception { web.ignoring() .antMatchers(HttpMethod.OPTIONS, \u0026quot;/**\u0026quot;) .antMatchers(\u0026quot;/app/**/*.{js,html}\u0026quot;) .antMatchers(\u0026quot;/i18n/**\u0026quot;) .antMatchers(\u0026quot;/content/**\u0026quot;) .antMatchers(\u0026quot;/swagger-ui/index.html\u0026quot;) .antMatchers(\u0026quot;/test/**\u0026quot;); }   下面的配置告诉Spring security哪些端点允许所有用户使用，哪些端点应该进行身份验证，以及哪些端点需要特定的角色(本例中是管理员)  @Override public void configure(HttpSecurity http) throws Exception { http .csrf() .disable() .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class) .exceptionHandling() .authenticationEntryPoint(problemSupport) .accessDeniedHandler(problemSupport) .and() .headers() .frameOptions() .disable() .and() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() .antMatchers(\u0026quot;/api/register\u0026quot;).permitAll() .antMatchers(\u0026quot;/api/activate\u0026quot;).permitAll() .antMatchers(\u0026quot;/api/authenticate\u0026quot;).permitAll() .antMatchers(\u0026quot;/api/account/reset-password/init\u0026quot;).permitAll() .antMatchers(\u0026quot;/api/account/reset-password/finish\u0026quot;).permitAll() .antMatchers(\u0026quot;/api/**\u0026quot;).authenticated() .antMatchers(\u0026quot;/websocket/tracker\u0026quot;).hasAuthority(AuthoritiesConstants.ADMIN) .antMatchers(\u0026quot;/websocket/**\u0026quot;).permitAll() .antMatchers(\u0026quot;/management/health\u0026quot;).permitAll() .antMatchers(\u0026quot;/management/info\u0026quot;).permitAll() .antMatchers(\u0026quot;/management/**\u0026quot;).hasAuthority(AuthoritiesConstants.ADMIN) .and() .apply(securityConfigurerAdapter()); }  domain 应用程序的域模型类在这个包中。这些简单的pojo具有JPA注解，将其映射到Hibernate实体。当选择Elasticsearch选项时，它们还充当文档对象。以User.java为例.\n类的注解 @Entity @Table(name = \u0026quot;jhi_user\u0026quot;) @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)  字段的注解  @Id :标记实体主键 @Column：字段映射到数据表列 @NotNull、@Pattern和@Size：用于验证的注释。 @JsonIgnore：ackson在将对象转换为JSON时，是否使用它来忽略字段，这些对象将在REST API请求中返回  @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \u0026quot;sequenceGenerator\u0026quot;) @SequenceGenerator(name = \u0026quot;sequenceGenerator\u0026quot;) private Long id; @NotNull @Pattern(regexp = Constants.LOGIN_REGEX) @Size(min = 1, max = 50) @Column(length = 50, unique = true, nullable = false) private String login; @JsonIgnore @NotNull @Size(min = 60, max = 60) @Column(name = \u0026quot;password_hash\u0026quot;, length = 60, nullable = false) private String password;  数据表之间的注释 @JsonIgnore @ManyToMany @JoinTable( name = \u0026quot;jhi_user_authority\u0026quot;, joinColumns = {@JoinColumn(name = \u0026quot;user_id\u0026quot;, referencedColumnName = \u0026quot;id\u0026quot;)}, inverseJoinColumns = {@JoinColumn(name = \u0026quot;authority_name\u0026quot;, referencedColumnName = \u0026quot;name\u0026quot;)}) @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE) @BatchSize(size = 20) private Set\u0026lt;Authority\u0026gt; authorities = new HashSet\u0026lt;\u0026gt;();  repository 包含实体的Spring Data存储库。这些接口定义通常由Spring Data自动实现。这样就不需要为数据访问层编写任何样板实现。以UserRepository.java示例。\n@Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { String USERS_BY_LOGIN_CACHE = \u0026quot;usersByLogin\u0026quot;; String USERS_BY_EMAIL_CACHE = \u0026quot;usersByEmail\u0026quot;; Optional\u0026lt;User\u0026gt; findOneByActivationKey(String activationKey); List\u0026lt;User\u0026gt; findAllByActivatedIsFalseAndCreatedDateBefore(Instant dateTime); ··· }   @Repository注释将其标记为Spring Data存储库组件。 该接口扩展了JpaRepository，它允许继承所有默认的CRUD操作，如findOne、findAll、save、count和delete。 自定义方法按照Spring数据命名约定编写为简单的方法定义，以便方法名称指定要生成的查询。例如，findOneByEmailIgnoreCase生成一个等价的查询 SELECT * FROM user WHERE LOWER(email) = LOWER(:email)。  security 包含Spring安全相关的组件和utils，由于我们选择JWT作为身份验证机制，它还包含与JWT相关的类，如TokenProvider、JWTFilter和JWTConfigurer。\nservice 包含由Spring服务bean、DTO、Mapstruct DTO映射器和服务实用程序组成的服务层。\nweb 包含web资源类、视图模型类和实用程序类。\nrest 包含REST API的Spring资源类。它还包含视图模型对象和实用程序。以UserResource.java为例。\n 资源类由@RestController和@RequestMapping(\u0026ldquo;/api\u0026rdquo;)注解标记。 请求方法根据其用途使用注释进行注释，例如，下面的标记将createUser方法标记为“/users”的PostMapping，这意味着所有到\u0026lt;applicationContext\u0026gt;/api/users的POST请求都将由该方法提供服务。  @PostMapping(\u0026quot;/users\u0026quot;) @PreAuthorize(\u0026quot;hasRole(\\\u0026quot;\u0026quot; + AuthoritiesConstants.ADMIN + \u0026quot;\\\u0026quot;)\u0026quot;) public ResponseEntity\u0026lt;User\u0026gt; createUser(@Valid @RequestBody UserDTO userDTO) throws URISyntaxException { ··· }  WebSocket 包含Websocket控制器和视图模型。\n\rJHipster在服务器端使用DTO(数据传输对象)和VM(视图模型)。dto用于在服务层和资源层之间传输数据。它们中断Hibernate事务，并避免由资源层触发进一步的延迟加载。vm仅用于在web前端显示数据，不与服务层交互。\n\r\rResources Resources下的config 它包含应用程序属性YAML文件和Liquibase更改日志。\ni18n 它包含服务器端i18n资源文件。\nmails 这保存了电子邮件的Thymeleaf模板。\ntemplates 它为客户端保存Thymeleaf模板。\n客户端src/main/webapp \r\r app 包含Angular应用的Typescript源代码，每个组织都有一个文件夹\napp.main.ts 这是Angular应用程序的主文件。注意，它使用了platformBrowserDynamic，这使得应用程序可以在浏览器中使用JIT(即时)编译。\nplatformBrowserDynamic() .bootstrapModule(ShopAppModule, { preserveWhitespaces: true }) .then(success =\u0026gt; console.log(`Application started`)) .catch(err =\u0026gt; console.error(err));  app.module.ts 这是Angular应用程序的主模块。它声明了应用程序级的组件和提供者，并导入了应用程序的其他模块。它还引导主应用程序组件。\n@NgModule({ imports: [ BrowserModule, Ng2Webstorage.forRoot({ prefix: 'jhi', separator: '-' }), NgJhipsterModule.forRoot({ // set below to true to make alerts look like toast alertAsToast: false, alertTimeout: 5000, i18nEnabled: true, defaultI18nLang: 'zh-cn' }), ShopSharedModule.forRoot(), ShopCoreModule, ShopHomeModule, ShopAccountModule, // jhipster-needle-angular-add-module JHipster will add new module here ShopEntityModule, ShopAppRoutingModule ], declarations: [JhiMainComponent, NavbarComponent, ErrorComponent, PageRibbonComponent, ActiveMenuDirective, FooterComponent], providers: [ { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: AuthExpiredInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: ErrorHandlerInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: NotificationInterceptor, multi: true } ], bootstrap: [JhiMainComponent] }) export class ShopAppModule { constructor(private dpConfig: NgbDatepickerConfig) { this.dpConfig.minDate = { year: moment().year() - 100, month: 1, day: 1 }; } }  account 此模块包含与帐户相关的功能，如激活、密码、密码重置、注册和设置。每个组件都由component.html, component.ts, route.ts, and service.ts文件组成。\nadmin 此模块包含与管理相关的特性，如审核、配置、文档、服务状态、日志、资源监控、跟踪器和用户管理。每个组件都由component.html, component.ts, route.ts, and service.ts文件组成。\nblocks 该文件夹由HTTP拦截器和应用程序使用的其他配置组成。\nentities 实体模块\nhome 首页模块\nlayouts 该文件夹包含导航栏、页脚、错误页面等布局组件。\nshared 此模块包含应用程序所需的所有共享服务(auth、跟踪器、用户)、组件(登录、警报)、实体模型和实用程序。\ncontent 此文件夹包含静态内容，如图像、CSS和SASS文件。\ni18n 国际化 这是i18n JSON文件所在的位置。每种语言都有一个文件夹，其中包含许多由模块组织的JSON文件。\nswagger-ui 该文件夹具有用于API文档开发的Swagger UI客户机。\nindex.html 这是web应用程序的索引文件。这包含了加载angular应用程序主组件的非常少的代码。它是一个单页Angular应用程序。您还将在这个文件中发现一些注释掉的实用程序代码，比如谷歌分析脚本和服务工作者脚本。如果需要，可以启用这些。\n\u0026lt;!doctype html\u0026gt; \u0026lt;html class=\u0026quot;no-js\u0026quot; lang=\u0026quot;en\u0026quot; dir=\u0026quot;ltr\u0026quot;\u0026gt; \u0026lt;head\u0026gt; ... \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;jhi-main\u0026gt;\u0026lt;/jhi-main\u0026gt; \u0026lt;noscript\u0026gt; \u0026lt;h1\u0026gt;You must enable javascript to view this page.\u0026lt;/h1\u0026gt; \u0026lt;/noscript\u0026gt; ... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  \r要使用服务工作者启用PWA模式，只需在src/main/webapp/index.html中取消相应代码的注释，以注册服务工作者。JHipster使用workbox，它创建相应的服务工作者并动态生成sw.js。\n\r\r链接与资源 jhipster学习网\n","date":1554968021,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554968021,"objectID":"71e1d658cdaf23ad22e60ada207af41f","permalink":"https://cytgenkidu.github.io/post/jhipster-monolithic-structure/","publishdate":"2019-04-11T15:33:41+08:00","relpermalink":"/post/jhipster-monolithic-structure/","section":"post","summary":"文件结构 \r\r  src: 这是源文件夹，其中包含主应用程序源文件和测试源文件。 webpack: 这个文件夹包含用于开发、生产和测试的所有webpack客户端构建配置。 gradle: 这个文件夹有gradle包装器和额外的gradle构建脚本，这些脚本将由主要的gradle构建文件使用(如果选择Maven, JHipster也提供了类似的包装器)。 build.gradle: 这是gradle构建文件，它指定了应用程序的构建生命周期。它还指定了服务器端依赖项。构建使用gradle中定义的gradle.properties。还可以找到一个名为gradlew (gradlew.bat，用于Windows)的可执行文件，它允许您使用Gradle而无需安装它。 .yo-rc.json: 这是JHipster的配置文件。这个文件存储了我们在创建应用程序时选择的选项，并用于应用程序的更新和升级。 package.json: 这是NPM配置文件，它指定了所有客户端依赖项、客户端构建依赖项和任务。 tsconfig.json: 这是Typescript的配置。还有tsconfig-aot.json,用于Angular AOT (Ahead-of-Time) compilation。 tslint.json: 这是Typescript的lint配置。  src src文件夹内结构\nmain  docker: 保存应用程序的Dockerfile，并保存所选选项的docker配置。 java: 保存应用程序的主要java源代码。 resources: 保存Spring引导配置文件、Liquibase更改日志以及应用程序使用的静态资源，如服务器端i18n文件和电子邮件模板。 webapp: 保存Angular应用程序源代码和客户端静态内容，如图像、样式表、i18n文件等。  test  java:保存服务器端单元和集成测试源。 javascript:为客户端应用程序保存Karma单元测试规范和量角器端到端规范。 resources:保存应用程序用于测试的Spring配置文件和静态资源，如服务器端i18n文件和电子邮件模板。  服务端src/main/java src/main/java文件夹内重要部分。\n\r\r ShopApp.java 这是应用程序的主入口类。由于这是一个Spring引导应用程序，主类是可执行的，您可以通过在IDE中运行这个类来启动应用程序。\n注解 Spring JavaConfig注解\n@SpringBootApplication @EnableConfigurationProperties({LiquibaseProperties.class, ApplicationProperties.class})   @SpringBootApplication:是一个复合注解，包括@ComponentScan，和@SpringBootConfiguration，@EnableAutoConfiguration。  @ComponentScan：扫描当前包及其子包下被@Component，@Controller，@Service，@Repository注解标记的类并纳入到spring容器中进行管理。 @EnableAutoConfiguration：作用是启动自动的配置，意思就是Springboot根据你添加的jar包来配置你项目的默认配置。 @SpringBootConfiguration：继承自@Configuration，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到srping容器中，并且实例名就是方法名。  @EnableConfigurationProperties：帮助通过属性文件注册应用程序的其他配置。  main方法 public static void main(String[] args) { SpringApplication app = new SpringApplication(ShopApp.","tags":["JHipster"],"title":"使用JHipster构建单一的Web应用程序-文件结构与部分代码","type":"post"},{"authors":[],"categories":["Git"],"content":" 安装  下载git Mac OS X 版 下载git Windows版 下载git Linux 和 Unix版  配置Git 设置名字和邮箱地址\ngit config --global user.name cytgenkidu git config --global user.email tgenkidu@163.com  检查配置信息,执行 git config --list\n\r\r \r更多自定义配置请查看。\n\r\r创建新仓库（repository） 创建repository(仓库) \r\r\r\r 建立本地新仓库 创建新文件夹，打开，然后执行 git init 创建新的 git 仓库。\n存储库克隆到新目录  创建一个本地仓库的克隆版本 git clone /path/to/repository 创建一个远程仓库的克隆版本 git clone username@host:/path/to/repository  Git工作流 Git有三种状态：已提交（committed）、已修改（modified）和已暂存（staged）。 由此引出三个工作区域的概念：Git 仓库、工作目录以及暂存区域(Index)。\n Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’\u0026rsquo;，不过一般说法还是叫暂存区域。  \r\r 基本的 Git 工作流程如下：\n 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。  添加和提交 提出更改（把它们添加到暂存区），命令如下：\n 添加某个文件：git add \u0026lt;filename\u0026gt; 添加所有更改：git add *  提交改动(改动已经提交到了本地的Git 仓库的 HEAD 中，但是还没到远端仓库)，命令如下：git commit -m \u0026quot;代码提交信息\u0026quot;\n推送改动 将改动提交到远程仓库：git push origin master，可将master改为任何分支。\n若未克隆现有仓库，并欲将你的仓库连接到某个远程服务器，可执行 git remote add origin \u0026lt;server\u0026gt;，可将改动推送到所添加的服务器上去。\n分支 分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。\n创建分支 创建一个叫做“test”的分支：git branch test ，切换到“test”分支：git checkout test。也可直接执行git checkout -b test，创建并切换。\n切换分支 切换回主分支：git checkout master\n删掉分支 删除“test”分支：git branch -d test， 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：git push origin \u0026lt;branch\u0026gt;\n更新与合并 更新你的本地仓库至最新改动，执行：git pull，在你的工作目录将获取（fetch）并合并（merge）远端的改动。\n要合并其他分支到你的当前分支（例如 master），执行：git merge \u0026lt;branch\u0026gt;。\n在这两种情况下，git 都会尝试去自动合并改动。但很有可能并非每次都成功，还有可能出现冲突（conflicts）。 这时候需要修改文件来手动合并这些冲突（conflicts）。改后，你需要执行如下命令git add \u0026lt;filename\u0026gt;将它们标记为合并成功。\n在合并改动之前，你可以使用如下命令预览差异：git diff \u0026lt;source_branch\u0026gt; \u0026lt;target_branch\u0026gt;\n示例  获取最新代码到本地，并自动合并到当前分支：\n//查询当前远程的版本 $ git remote -v //直接拉取并合并最新代码 $ git pull origin master [拉取远端origin/master分支并合并到当前分支]  获取最新代码到本地，然后手动合并分支,需额外建立本地分支\n//查看当前远程的版本 $ git remote -v //获取最新代码到本地临时分支(本地当前分支为[branch]，获取的远端的分支为[origin/branch]) $ git fetch origin master:master1 [在本地建立master1分支，并下载远端的origin/master分支到master1分支中] //查看版本差异 $ git diff master1 [查看本地master1分支与当前分支的版本差异] //合并最新分支到本地分支 $ git merge master1 [合并本地分支master1到当前分支] //删除本地临时分支 $ git branch -D master1 [删除本地分支master1]  获取最新代码到本地，然后手动合并分支,不额外建立本地分支\n//查询当前远程的版本 $ git remote -v //获取最新代码到本地(本地当前分支为[branch]，获取的远端的分支为[origin/branch]) $ git fetch origin master [获取远端的origin/master分支] //查看版本差异 $ git log -p master..origin/master [查看本地master与远端origin/master的版本差异] //合并最新代码到本地分支 $ git merge origin/master [合并远端分支origin/master到当前分支]   链接与资源 Git 社区参考书\n","date":1554875820,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554875820,"objectID":"5bdf3653ef5d0ac495de1f045b115233","permalink":"https://cytgenkidu.github.io/post/git-guide/","publishdate":"2019-04-10T13:57:00+08:00","relpermalink":"/post/git-guide/","section":"post","summary":"安装  下载git Mac OS X 版 下载git Windows版 下载git Linux 和 Unix版  配置Git 设置名字和邮箱地址\ngit config --global user.name cytgenkidu git config --global user.email tgenkidu@163.com  检查配置信息,执行 git config --list\n\r\r \r更多自定义配置请查看。\n\r\r创建新仓库（repository） 创建repository(仓库) \r\r\r\r 建立本地新仓库 创建新文件夹，打开，然后执行 git init 创建新的 git 仓库。\n存储库克隆到新目录  创建一个本地仓库的克隆版本 git clone /path/to/repository 创建一个远程仓库的克隆版本 git clone username@host:/path/to/repository  Git工作流 Git有三种状态：已提交（committed）、已修改（modified）和已暂存（staged）。 由此引出三个工作区域的概念：Git 仓库、工作目录以及暂存区域(Index)。\n Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’\u0026rsquo;，不过一般说法还是叫暂存区域。  \r\r 基本的 Git 工作流程如下：","tags":["Git"],"title":"Git简要说明","type":"post"},{"authors":["Tgenkidu Cy"],"categories":["JHipster"],"content":" 准备 从Oracle网站安装Java 8。\n从Node.js网站安装Node.js（LTS 64位版本，不支持非LTS版本）。\n如使用docker，请从docker网站安装docker。\n安装JHipster 使用yarn安装，在终端运行:\nyarn add global generator-jhipster\n使用npm安装,在终端运行：\nnpm install -g generator-jhipster\n等待安装完毕，执行jhipster --version ，你将会看到版本信息。\n\r\r 生成应用 在此之前,可以先准备一个github repository(仓库)，之后将在这个仓库上创建许多Git Branchs(分支)。\n\r可以查看本博客关于Git简要说明。\n\r\r准备工作区 为工作区创建一个新文件夹,导航到该文件夹。\nmkdir my-test-app cd my-test-app  为应用创建一个文件夹，导航到该文件夹。\nmkdir my-shop cd my-shop  在开始前执行jhipster --version确保准备完成，最好使用最新版本的工具,执行yarn global upgrade generator-jhipster或npm update -g generator-jhipster更新版本。\n使用JHipster生成代码 生成代码只需要在应用文件夹下终端执行jhipster命令，终端将输出。\n\r\r JHipster将询问一些问题，以获得有关所需的不同选项输入。\n? (1/19) Which *type* of application would you like to create? (Use arrow keys) //选择创建的应用类型 \u0026gt; Monolithic application (recommended for simple projects) //综合应用 Microservice application //微服务应用 Microservice gateway //微服务网关 [BETA] JHipster UAA server (for microservice OAuth2 authentication) //微服务OAuth2的身份认证服务  服务器选择 ? (2/19) What is the base name of your application? (shop) //服务名 ? (3/19) What is your default Java package name? (com.mycompany.app) //默认包名 ? (4/19) ? Do you want to use the JHipster Registry to configure, monitor and scale your application? (Use arrow keys) //微服务注册中心和统一配置中心，只有在微服务架构时才会使用 \u0026gt; No Yes ? (5/19) Which *type* of authentication would you like to use? (Use arrow keys) //选择认证方式 \u0026gt; JWT authentication (stateless, with a token) //使用JSON Web Token OAuth 2.0 / OIDC Authentication (stateful, works with Keycloak and Okta) //使用OpenID连接服务，类似于Keycloak或者Okta HTTP Session Authentication (stateful, default Spring Security mechanism) //经典的基于session认证的机制 Authentication with JHipster UAA server // 此种方式必须提前生成JHipster UAA Server (Q1的选项)，它是基于OAuth2的验证服务 ? (6/19) Which *type* of database would you like to use? (Use arrow keys) //选择数据库类型 \u0026gt; SQL (H2, MySQL, MariaDB, PostgreSQL, Oracle, MSSQL) //关系型数据库 MongoDB Couchbase Cassandra ? (7/19) Which *production* database would you like to use? //生产数据库 MySQL MariaDB \u0026gt; PostgreSQL Oracle (Please follow our documentation to use the Oracle proprietary driver) Microsoft SQL Server ? (8/19) Which *development* database would you like to use? //开发数据库 H2 with disk-based persistence //数据存储在磁盘的H2 H2 with in-memory persistence //内存H2（服务关闭数据丢失） \u0026gt; PostgreSQL ? (9/19) Do you want to use the Spring cache abstraction? Yes, with the Ehcache implementation (local cache, for a single node) //本地缓存方案 ehcache \u0026gt; Yes, with the Hazelcast implementation (distributed cache, for multiple nodes) //集群缓存方案，多节点缓存，适合多微服务的分布式环境 [BETA] Yes, with the Infinispan implementation (hybrid cache, for multiple nodes) Yes, with Memcached (distributed cache) - Warning, when using an SQL database, this will disable the Hib ernate 2nd level cache! No - Warning, when using an SQL database, this will disable the Hibernate 2nd level cache! ? (10/19) Do you want to use Hibernate 2nd level cache? (Y/n) y //Hibernate 二级缓存 ? (11/19) Would you like to use Maven or Gradle for building the backend? //选择后台构建系统 Maven //更成熟，稳定，用户群体更大 \u0026gt; Gradle //更灵活，易于扩展，支持maven一键转Gradle ? (12/19) Which other technologies would you like to use? //可选技术 ( ) Search engine using Elasticsearch //集成搜索开源搜索引擎 ElasticSearch \u0026gt;(*) WebSockets using Spring Websocket //使用Spring WebSocket、SocketJS和Stomp协议添加WebSocket支持 ( ) Asynchronous messages using Apache Kafka //使用Kafka添加对异步队列的支持 ( ) API first development using OpenAPI-generator //添加Swagger codegen对API优先开发的支持  客户端选择 ? (13/19) Which *Framework* would you like to use for the client? (Use arrow keys) //客户端框架 \u0026gt; Angular React ? (14/19) Would you like to enable *SASS* stylesheet preprocessor? (Y/n) y //SASS支持  国际化选择 ? (15/19) Would you like to enable internationalization support? (Y/n) y //是否使用国际化 ? (16/19) Please choose the native language of the application (Use arrow keys) //选择本地化语言 Belorussian Bengali Catalan \u0026gt; Chinese (Simplified) Chinese (Traditional) Czech Danish (Move up and down to reveal more choices) ? (17/19) Please choose additional languages to install //选择其余支持语言 ( ) Czech ( ) Danish ( ) Dutch \u0026gt;(*) English ( ) Estonian ( ) Farsi ( ) French (Move up and down to reveal more choices)  测试选择 ? (18/19) Besides JUnit and Jest, which testing frameworks would you like to use? //应用程序选择测试选项 ( ) Gatling ( ) Cucumber \u0026gt;(*) Protractor  其他 ? (19/19) Would you like to install other generators from the JHipster Marketplace? (y/N) n //是否需要去JHipster商城安装第三方插件模块  生成成功 \r\r\r\r 运行 执行./gradlew,相当于执行./gradlew bootRun -Pdev。\n\r\r 该应用程序已经成功启动，可以在 http://localhost:8080 上查看。\n测试 服务端测试 运行./gradlew test,如果运行成功，将会看到BUILD SUCCESSFUL。\n客户端测试 运行npm test或运行yarn test。\ne2e测试，需确保服务端正在运行，然后在运行npm e2e或yarn e2e。\n热启动 在一个终端中，通过运行./gradlew以dev模式启动服务器，在另一个终端中，通过运行yarn start或npm start启动客户端开发服务器。\n当您在服务器端进行任何更改时，只需运行./gradlew compileJava，或者如果您使用IDE，则单击compile按钮。\n提交Git（可选择行执行） \u0026gt; git init \u0026gt; git add --all \u0026gt; git commit -am \u0026quot;generated myshop application\u0026quot;  链接与资源 jhipster学习网\n","date":1554867047,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554867047,"objectID":"d2d6abc0fd65a29f61e97eb52f6e8dfa","permalink":"https://cytgenkidu.github.io/post/jhipster-monolithic-build/","publishdate":"2019-04-10T11:30:47+08:00","relpermalink":"/post/jhipster-monolithic-build/","section":"post","summary":"准备 从Oracle网站安装Java 8。\n从Node.js网站安装Node.js（LTS 64位版本，不支持非LTS版本）。\n如使用docker，请从docker网站安装docker。\n安装JHipster 使用yarn安装，在终端运行:\nyarn add global generator-jhipster\n使用npm安装,在终端运行：\nnpm install -g generator-jhipster\n等待安装完毕，执行jhipster --version ，你将会看到版本信息。\n\r\r 生成应用 在此之前,可以先准备一个github repository(仓库)，之后将在这个仓库上创建许多Git Branchs(分支)。\n\r可以查看本博客关于Git简要说明。\n\r\r准备工作区 为工作区创建一个新文件夹,导航到该文件夹。\nmkdir my-test-app cd my-test-app  为应用创建一个文件夹，导航到该文件夹。\nmkdir my-shop cd my-shop  在开始前执行jhipster --version确保准备完成，最好使用最新版本的工具,执行yarn global upgrade generator-jhipster或npm update -g generator-jhipster更新版本。\n使用JHipster生成代码 生成代码只需要在应用文件夹下终端执行jhipster命令，终端将输出。\n\r\r JHipster将询问一些问题，以获得有关所需的不同选项输入。\n? (1/19) Which *type* of application would you like to create? (Use arrow keys) //选择创建的应用类型 \u0026gt; Monolithic application (recommended for simple projects) //综合应用 Microservice application //微服务应用 Microservice gateway //微服务网关 [BETA] JHipster UAA server (for microservice OAuth2 authentication) //微服务OAuth2的身份认证服务  服务器选择 ?","tags":["JHipster"],"title":"使用JHipster构建单一的Web应用程序","type":"post"},{"authors":["Tgenkidu Cy"],"categories":["前端","Github"],"content":" 出现原因 该篇博文的评论系统还没初始化。\n解决办法 手动完成 登录自己的github账号登录后，就可以在上面错误信息处看到“Initialize Comments”的按钮 (ps: 由于要求回调URL和当前地址一样，故第2步不能在本地调试， 需把代码先上传再调试),点击Initialize Comments按钮后，就可以开始对该篇博文开始评论了， 同时也可以在对应的github仓库看到相应的issue。\n自动初始化Gitalk 生成sitemap站点地图： hugo附带了一个内置模板文件,可在layouts/sitemap.xml或layouts/_default/sitemap.xml查看模板。\n在public/sitemap.xml查看生成的sitemap站点地图。\n获取github接口的调用权限  创建一个access token 点此创建  点击Generate new token按钮,生成token。   编写脚本文件 安装依赖包 在根目录下执行以下命令\nnpm install request --save npm install xml-parser --save npm install cheerio --save  创建脚本文件 在根目录下创建initialize.js\nconst request = require(\u0026quot;request\u0026quot;); const fs = require(\u0026quot;fs\u0026quot;); const path = require(\u0026quot;path\u0026quot;); const url = require(\u0026quot;url\u0026quot;); const xmlParser = require(\u0026quot;xml-parser\u0026quot;); const cheerio = require(\u0026quot;cheerio\u0026quot;); // 根据自己的情况进行配置 const config = { username: \u0026quot;cytgenkidu\u0026quot;, // GitHub 用户名 token: \u0026quot;\u0026quot;, // GitHub Token repo: \u0026quot;cytgenkidu.github.io\u0026quot;, // 存放 issues的git仓库 // sitemap.xml的路径，commit.js放置在根目录下，无需修改，其他情况自行处理 sitemapUrl: path.resolve(__dirname, \u0026quot;./public/sitemap.xml\u0026quot;), kind: \u0026quot;Gitalk\u0026quot;, // \u0026quot;Gitalk\u0026quot; or \u0026quot;Gitment\u0026quot; }; let issuesUrl = `https://api.github.com/repos/${config.username}/${config.repo}/issues?access_token=${config.token}`; let requestGetOpt = { url: `${issuesUrl}\u0026amp;page=1\u0026amp;per_page=1000`, json: true, headers: { \u0026quot;User-Agent\u0026quot;: \u0026quot;github-user\u0026quot; } }; let requestPostOpt = { ...requestGetOpt, url: issuesUrl, method: \u0026quot;POST\u0026quot;, form: \u0026quot;\u0026quot; }; console.log(\u0026quot;开始初始化评论...\u0026quot;); (async function () { console.log(\u0026quot;开始检索链接，请稍等...\u0026quot;); try { let urls = sitemapXmlReader(config.sitemapUrl); // let directory = ['/project/', '/tutorial/']; let directory = ['/project/']; //筛选需初始化的链接，如不需筛选，下面这句可注释 urls =inArray(urls, directory) console.log(`共检索到${urls.length}个链接`); console.log(\u0026quot;开始获取已经初始化的issues:\u0026quot;); let issues = await send(requestGetOpt); console.log(`已经存在${issues.length}个issues`); let notInitIssueLinks = urls.filter((link) =\u0026gt; { return !issues.find((item) =\u0026gt; { link = removeProtocol(link); return item.body.includes(link); }); }); if (notInitIssueLinks.length \u0026gt; 0) { console.log(`本次有${notInitIssueLinks.length}个链接需要初始化issue：`); console.log(notInitIssueLinks); console.log(\u0026quot;开始提交初始化请求, 大约需要40秒...\u0026quot;); /** * 部署好网站后，直接执行start，新增文章并不会生成评论 * 经测试，最少需要等待40秒，才可以正确生成， 怀疑跟github的api有关系，没有找到实锤 */ setTimeout(async ()=\u0026gt;{ let initRet = await notInitIssueLinks.map(async (item) =\u0026gt; { let html = await send({ ...requestGetOpt, url: item }); let title = cheerio.load(html)(\u0026quot;title\u0026quot;).text(); let pathLabel = url.parse(item).path; // let body = `${item}\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;${websiteConfig.description}`; // let form = JSON.stringify({ body, labels: [config.kind, pathLabel], title }); let form = JSON.stringify({labels: [config.kind, pathLabel], title }); return send({ ...requestPostOpt, form }); }); console.log(`已完成${initRet.length}个！`); console.log(\u0026quot;可以愉快的发表评论了！\u0026quot;); },40000); } else { console.log(\u0026quot;本次发布无新增页面，无需初始化issue!!\u0026quot;); } } catch (e) { console.log(`初始化issue出错，错误如下：`); console.log(e); } finally { } })(); function inArray(arr, arr2) { var array3 = []; for (var i = 0; i \u0026lt; arr.length; i++) { for(var j=0;j\u0026lt;arr2.length;j++){ var item=arr2[j]; if (arr[i].indexOf(item) != -1) { array3.push(arr[i]); } } } return array3; } function sitemapXmlReader(file) { let data = fs.readFileSync(file, \u0026quot;utf8\u0026quot;); let sitemap = xmlParser(data); return sitemap.root.children.map(function (url) { let loc = url.children.filter(function (item) { return item.name === \u0026quot;loc\u0026quot;; })[0]; return loc.content; }); } function removeProtocol(url) { return url.substr(url.indexOf(\u0026quot;:\u0026quot;)); } function send(options) { return new Promise(function (resolve, reject) { request(options, function (error, response, body) { if (!error) { resolve(body); } else { reject(error); } }); }); }  执行脚本 node ./initialize.js\n","date":1554370261,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554370261,"objectID":"dd3d7dbbdfc341488a1dedc428041784","permalink":"https://cytgenkidu.github.io/post/gitalk-initialize/","publishdate":"2019-04-04T17:31:01+08:00","relpermalink":"/post/gitalk-initialize/","section":"post","summary":"出现原因 该篇博文的评论系统还没初始化。\n解决办法 手动完成 登录自己的github账号登录后，就可以在上面错误信息处看到“Initialize Comments”的按钮 (ps: 由于要求回调URL和当前地址一样，故第2步不能在本地调试， 需把代码先上传再调试),点击Initialize Comments按钮后，就可以开始对该篇博文开始评论了， 同时也可以在对应的github仓库看到相应的issue。\n自动初始化Gitalk 生成sitemap站点地图： hugo附带了一个内置模板文件,可在layouts/sitemap.xml或layouts/_default/sitemap.xml查看模板。\n在public/sitemap.xml查看生成的sitemap站点地图。\n获取github接口的调用权限  创建一个access token 点此创建  点击Generate new token按钮,生成token。   编写脚本文件 安装依赖包 在根目录下执行以下命令\nnpm install request --save npm install xml-parser --save npm install cheerio --save  创建脚本文件 在根目录下创建initialize.js\nconst request = require(\u0026quot;request\u0026quot;); const fs = require(\u0026quot;fs\u0026quot;); const path = require(\u0026quot;path\u0026quot;); const url = require(\u0026quot;url\u0026quot;); const xmlParser = require(\u0026quot;xml-parser\u0026quot;); const cheerio = require(\u0026quot;cheerio\u0026quot;); // 根据自己的情况进行配置 const config = { username: \u0026quot;cytgenkidu\u0026quot;, // GitHub 用户名 token: \u0026quot;\u0026quot;, // GitHub Token repo: \u0026quot;cytgenkidu.","tags":["Gitalk","Error","Github","评论自动初始化"],"title":"Gitalk评论自动初始化","type":"post"},{"authors":["Tgenkidu Cy"],"categories":["前端","Github"],"content":" 出现原因 文章标题名太长，由于 Github 限制 labal 长度不能超过 50引起的，该问题解决方案来自Gitalk项目仓 Issues115，通过MD5加密ID来缩短labal长度。\n解决办法 创建md5.min.js文件 ! function(n) { \u0026quot;use strict\u0026quot;; function t(n, t) { var r = (65535 \u0026amp; n) + (65535 \u0026amp; t); return (n \u0026gt;\u0026gt; 16) + (t \u0026gt;\u0026gt; 16) + (r \u0026gt;\u0026gt; 16) \u0026lt;\u0026lt; 16 | 65535 \u0026amp; r } function r(n, t) { return n \u0026lt;\u0026lt; t | n \u0026gt;\u0026gt;\u0026gt; 32 - t } function e(n, e, o, u, c, f) { return t(r(t(t(e, n), t(u, f)), c), o) } function o(n, t, r, o, u, c, f) { return e(t \u0026amp; r | ~t \u0026amp; o, n, t, u, c, f) } function u(n, t, r, o, u, c, f) { return e(t \u0026amp; o | r \u0026amp; ~o, n, t, u, c, f) } function c(n, t, r, o, u, c, f) { return e(t ^ r ^ o, n, t, u, c, f) } function f(n, t, r, o, u, c, f) { return e(r ^ (t | ~o), n, t, u, c, f) } function i(n, r) { n[r \u0026gt;\u0026gt; 5] |= 128 \u0026lt;\u0026lt; r % 32, n[14 + (r + 64 \u0026gt;\u0026gt;\u0026gt; 9 \u0026lt;\u0026lt; 4)] = r; var e, i, a, d, h, l = 1732584193, g = -271733879, v = -1732584194, m = 271733878; for (e = 0; e \u0026lt; n.length; e += 16) i = l, a = g, d = v, h = m, g = f(g = f(g = f(g = f(g = c(g = c(g = c(g = c(g = u(g = u(g = u(g = u(g = o(g = o(g = o(g = o(g, v = o(v, m = o(m, l = o(l, g, v, m, n[e], 7, -680876936), g, v, n[e + 1], 12, -389564586), l, g, n[e + 2], 17, 606105819), m, l, n[e + 3], 22, -1044525330), v = o(v, m = o(m, l = o(l, g, v, m, n[e + 4], 7, -176418897), g, v, n[e + 5], 12, 1200080426), l, g, n[e + 6], 17, -1473231341), m, l, n[e + 7], 22, -45705983), v = o(v, m = o(m, l = o(l, g, v, m, n[e + 8], 7, 1770035416), g, v, n[e + 9], 12, -1958414417), l, g, n[e + 10], 17, -42063), m, l, n[e + 11], 22, -1990404162), v = o(v, m = o(m, l = o(l, g, v, m, n[e + 12], 7, 1804603682), g, v, n[e + 13], 12, -40341101), l, g, n[e + 14], 17, -1502002290), m, l, n[e + 15], 22, 1236535329), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 1], 5, -165796510), g, v, n[e + 6], 9, -1069501632), l, g, n[e + 11], 14, 643717713), m, l, n[e], 20, -373897302), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 5], 5, -701558691), g, v, n[e + 10], 9, 38016083), l, g, n[e + 15], 14, -660478335), m, l, n[e + 4], 20, -405537848), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 9], 5, 568446438), g, v, n[e + 14], 9, -1019803690), l, g, n[e + 3], 14, -187363961), m, l, n[e + 8], 20, 1163531501), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 13], 5, -1444681467), g, v, n[e + 2], 9, -51403784), l, g, n[e + 7], 14, 1735328473), m, l, n[e + 12], 20, -1926607734), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 5], 4, -378558), g, v, n[e + 8], 11, -2022574463), l, g, n[e + 11], 16, 1839030562), m, l, n[e + 14], 23, -35309556), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 1], 4, -1530992060), g, v, n[e + 4], 11, 1272893353), l, g, n[e + 7], 16, -155497632), m, l, n[e + 10], 23, -1094730640), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 13], 4, 681279174), g, v, n[e], 11, -358537222), l, g, n[e + 3], 16, -722521979), m, l, n[e + 6], 23, 76029189), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 9], 4, -640364487), g, v, n[e + 12], 11, -421815835), l, g, n[e + 15], 16, 530742520), m, l, n[e + 2], 23, -995338651), v = f(v, m = f(m, l = f(l, g, v, m, n[e], 6, -198630844), g, v, n[e + 7], 10, 1126891415), l, g, n[e + 14], 15, -1416354905), m, l, n[e + 5], 21, -57434055), v = f(v, m = f(m, l = f(l, g, v, m, n[e + 12], 6, 1700485571), g, v, n[e + 3], 10, -1894986606), l, g, n[e + 10], 15, -1051523), m, l, n[e + 1], 21, -2054922799), v = f(v, m = f(m, l = f(l, g, v, m, n[e + 8], 6, 1873313359), g, v, n[e + 15], 10, -30611744), l, g, n[e + 6], 15, -1560198380), m, l, n[e + 13], 21, 1309151649), v = f(v, m = f(m, l = f(l, g, v, m, n[e + 4], 6, -145523070), g, v, n[e + 11], 10, -1120210379), l, g, n[e + 2], 15, 718787259), m, l, n[e + 9], 21, -343485551), l = t(l, i), g = t(g, a), v = t(v, d), m = t(m, h); return [l, g, v, m] } function a(n) { var t, r = \u0026quot;\u0026quot;, e = 32 * n.length; for (t = 0; t \u0026lt; e; t += 8) r += String.fromCharCode(n[t \u0026gt;\u0026gt; 5] \u0026gt;\u0026gt;\u0026gt; t % 32 \u0026amp; 255); return r } function d(n) { var t, r = []; for (r[(n.length \u0026gt;\u0026gt; 2) - 1] = void 0, t = 0; t \u0026lt; r.length; t += 1) r[t] = 0; var e = 8 * n.length; for (t = 0; t \u0026lt; e; t += 8) r[t \u0026gt;\u0026gt; 5] |= (255 \u0026amp; n.charCodeAt(t / 8)) \u0026lt;\u0026lt; t % 32; return r } function h(n) { return a(i(d(n), 8 * n.length)) } function l(n, t) { var r, e, o = d(n), u = [], c = []; for (u[15] = c[15] = void 0, o.length \u0026gt; 16 \u0026amp;\u0026amp; (o = i(o, 8 * n.length)), r = 0; r \u0026lt; 16; r += 1) u[r] = 909522486 ^ o[r], c[r] = 1549556828 ^ o[r]; return e = i(u.concat(d(t)), 512 + 8 * t.length), a(i(c.concat(e), 640)) } function g(n) { var t, r, e = \u0026quot;\u0026quot;; for (r = 0; r \u0026lt; n.length; r += 1) t = n.charCodeAt(r), e += \u0026quot;0123456789abcdef\u0026quot;.charAt(t \u0026gt;\u0026gt;\u0026gt; 4 \u0026amp; 15) + \u0026quot;0123456789abcdef\u0026quot;.charAt(15 \u0026amp; t); return e } function v(n) { return unescape(encodeURIComponent(n)) } function m(n) { return h(v(n)) } function p(n) { return g(m(n)) } function s(n, t) { return l(v(n), v(t)) } function C(n, t) { return g(s(n, t)) } function A(n, t, r) { return t ? r ? s(t, n) : C(t, n) : r ? m(n) : p(n) } \u0026quot;function\u0026quot; == typeof define \u0026amp;\u0026amp; define.amd ? define(function() { return A }) : \u0026quot;object\u0026quot; == typeof module \u0026amp;\u0026amp; module.exports ? module.exports = A : n.md5 = A }(this);  修改gitalk.html \u0026lt;!-- 评论系统 --\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 配置gitalk --\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var gitalk = new Gitalk({ // gitalk的主要参数 clientID: 'Github Application clientID', clientSecret: 'Github Application clientSecret', repo: '存储你评论 issue 的 Github 仓库名', owner: 'Github 用户名', admin: ['Github 用户名'], id: md5(location.pathname), //其他参数 distractionFreeMode: false // 全屏遮罩,jia }); gitalk.render('gitalk-container'); \u0026lt;/script\u0026gt; \u0026lt;div id=\u0026quot;gitalk-container\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;  ","date":1554369904,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554369904,"objectID":"29a979d754ef068206cd10f4d31a3153","permalink":"https://cytgenkidu.github.io/post/gitalk-validation-failed/","publishdate":"2019-04-04T17:25:04+08:00","relpermalink":"/post/gitalk-validation-failed/","section":"post","summary":"出现原因 文章标题名太长，由于 Github 限制 labal 长度不能超过 50引起的，该问题解决方案来自Gitalk项目仓 Issues115，通过MD5加密ID来缩短labal长度。\n解决办法 创建md5.min.js文件 ! function(n) { \u0026quot;use strict\u0026quot;; function t(n, t) { var r = (65535 \u0026amp; n) + (65535 \u0026amp; t); return (n \u0026gt;\u0026gt; 16) + (t \u0026gt;\u0026gt; 16) + (r \u0026gt;\u0026gt; 16) \u0026lt;\u0026lt; 16 | 65535 \u0026amp; r } function r(n, t) { return n \u0026lt;\u0026lt; t | n \u0026gt;\u0026gt;\u0026gt; 32 - t } function e(n, e, o, u, c, f) { return t(r(t(t(e, n), t(u, f)), c), o) } function o(n, t, r, o, u, c, f) { return e(t \u0026amp; r | ~t \u0026amp; o, n, t, u, c, f) } function u(n, t, r, o, u, c, f) { return e(t \u0026amp; o | r \u0026amp; ~o, n, t, u, c, f) } function c(n, t, r, o, u, c, f) { return e(t ^ r ^ o, n, t, u, c, f) } function f(n, t, r, o, u, c, f) { return e(r ^ (t | ~o), n, t, u, c, f) } function i(n, r) { n[r \u0026gt;\u0026gt; 5] |= 128 \u0026lt;\u0026lt; r % 32, n[14 + (r + 64 \u0026gt;\u0026gt;\u0026gt; 9 \u0026lt;\u0026lt; 4)] = r; var e, i, a, d, h, l = 1732584193, g = -271733879, v = -1732584194, m = 271733878; for (e = 0; e \u0026lt; n.","tags":["Gitalk","Error","Github"],"title":"Gitalk出现Error:Validation Failed问题的解决办法","type":"post"},{"authors":["Tgenkidu Cy"],"categories":["前端","Github"],"content":" 前言  在整理个人博客的过程中，想添加一套评论系统，一方面想收集意见来更好的改进，另一方面想提供一个读者与作者或读者与读者之间交流的平台。 在对比线下比较火的几个评论系统，又考虑到自己的博客是基于GitHub，综合考虑最终选择了基于Github Issues的评论系统Gitalk。 其他评论系统，如：\n  LiveRe：中文名称“来必力”，是一家韩国的公司，但本地化做的非常到位。这是我新发现的一个评论系统，支持的登录方式也挺多，但由于时间问题没有仔细的研究，后续有可能会尝试。\n Disqus：国外比较火的评论系统，但在国内必须完全代理VPN,才可以正常访问。\n gitment:基于Github issue的评论插件,但很久没有人维护。\n 畅言：需要ICP备案。\n 友言、网易云跟帖、多说等等其他家：关停太随意。\n  正文 关于Gitalk Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。\n 使用 GitHub 登录 支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru] 支持个人或组织 无干扰模式（设置 distractionFreeMode 为 true 开启） 快捷键提交评论 （cmd|ctrl + enter）  在线演示\n使用 创建一个Github Application 如果没有 点击申请，也可以\n Github头像下拉菜单 \u0026gt; Settings \u0026gt; 左边Developer settings下的OAuth Application \u0026gt; Register a new application，填写相关信息：\n 点击创建，获得Client ID和Client Secret。\n配置gitalk 将下面这段代码插入到你的网站， 或创建一个gitalk.html直接调用\n{{ partial \u0026quot;gitalk.html\u0026quot; . }}\n代码如下：\n\u0026lt;!-- 评论系统 --\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 配置gitalk --\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var gitalk = new Gitalk({ // gitalk的主要参数 clientID: 'Github Application clientID', clientSecret: 'Github Application clientSecret', repo: '存储你评论 issue 的 Github 仓库名', owner: 'Github 用户名', admin: ['Github 用户名'], id: '页面的唯一标识，gitalk会根据这个标识自动创建的issue的标签', //其他参数 distractionFreeMode: false // 全屏遮罩,jia }); gitalk.render('gitalk-container'); \u0026lt;/script\u0026gt; \u0026lt;div id=\u0026quot;gitalk-container\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;  推送到 Github 仓库 没什么问题的话，当你点击进入你的博客页面后就会出现评论框了。\n当你用 github 帐号登录（管理员），并且第一次加载该会比较慢，因为第一次加载会自动在你 repo 的仓库下创建对应 issue。\n链接与资源 Github gitalk\n相关 Gitalk出现Error:Validation Failed问题的解决办法\nGitalk出现Error: Comments Not Initialized问题的解决办法\n","date":1554187908,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554187908,"objectID":"089a615c21d41771446bc7e0e9d9072e","permalink":"https://cytgenkidu.github.io/post/blog-gitalk/","publishdate":"2019-04-02T14:51:48+08:00","relpermalink":"/post/blog-gitalk/","section":"post","summary":"为个人博客或其他网站接入Github的Gitalk评论插件","tags":["Github","Gitalk","hugo"],"title":"博客添加Gitalk评论","type":"post"},{"authors":null,"categories":null,"content":" 项目介绍： 对原本使用.NET Framework框架的ERP系统进行升级。\n开发过程： JHipster快速构建一个基于Spring Boot + AngularJS的项目，并在此基础上进行开发。\n客户端：  单页面应用AngularJS、Bootstrap、HTML5、I18N、Sass 通过npm来安装额外的JavaScript库 通过webpack构建、优化、实时重载 支持Thtmeleaf模板引擎  服务端：  使用易于配置的Spring Boot框架，通过Gradle对项目进行管理和构建 使用Spring Security OAuth2进行认证授权 使用Mybatis Generator根据数据库自动生成映射文件和Dao 使用Spring data JPA实现动态查询 使用Liquibase初始化数据库信息及数据库源代码版本控制 使用Lombok简化Java代码  生产环境：  支持使用Docker Compose管理Docker多容器，完成部署。  结果： 项目还在进行中，部分功能已测试，其他功能待迁移。\n","date":1553449265,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1553449265,"objectID":"277bd22eb12b5e21979232f56cc5c158","permalink":"https://cytgenkidu.github.io/project/springboot-angular-erp/","publishdate":"2019-03-24T12:41:05-05:00","relpermalink":"/project/springboot-angular-erp/","section":"project","summary":"对原本使用.NET Framework框架的ERP系统进行升级。","tags":["java","Spring Boot","Angular","npm","JPA","Lombok","Docker Compose","REST APIs","ERP","PostgreSQL"],"title":"基于Spring Boot + AngularJS的ERP系统升级","type":"project"},{"authors":null,"categories":null,"content":" 项目介绍： 开发微信公众号，客户通过公众号对应租金进行付款，客户社区运营。\n开发过程： 通过在GitHub上spring-guides/gs-spring-boot-docker的开源项目快速构建Docker镜像，并在此基础上进行开发，使用Spring Data JPA实现有数据库表生成实体类，并快速构建仓储类对数据库进行操作。前端页面使用Thymeleaf模板引擎进行渲染。通过Gradle对项目进行管理和构建，并将Docker镜像push到阿里云，负载到三个服务节点。\n结果： 客户通过公众号了解公司情况，还可以通过公众号查询违章信息、资料上传、租金自缴等功能。\n效果图 \r\r\r\r\r\r\r ","date":1549906865,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1549906865,"objectID":"c1adb9cd6730c9294d41a90bc1d36d4b","permalink":"https://cytgenkidu.github.io/project/weizu-gongzhonghao/","publishdate":"2019-02-11T12:41:05-05:00","relpermalink":"/project/weizu-gongzhonghao/","section":"project","summary":"开发微信公众号，客户通过公众号对应租金进行付款，客户社区运营。","tags":["java","Spring Boot","Docker","HTML5","Docker","微信公众号","JPA"],"title":"微租社群—基于Spring Boot的微信公众号开发","type":"project"},{"authors":null,"categories":null,"content":" 项目介绍： 围绕以租车、以租代购为主营业务的汽车租赁公司和融资租赁公司，为提高企业运营效率而设计开发的ERP管理系统。\n开发过程： 与各条线负责人需求跟进，分析其主要业务流程和信息交互内容，结合公司实际情况进行系统设计和数据库设计，在Visual Studio 2015的.NET环境为开发平台的基础上，通过ASP.NET、C#编程语言、MySQL数据库进行开发，开发过程遵循敏捷开发模式，将开发运维一体化，在系统运行过程中紧随业务调整和需求变动快速迭代，不断完善各功能模块。 \u0026lt;!\u0026ndash;\n系统架构 SaaS混合云架构 采用混合云SaaS模式架构，混合云架构将公司内部自由的服务器集群、传统租赁的ICP机房中的服务器集群通过VPC（Virtual Private Cloud）的可信连接与阿里云的VBR（Virtual Border Router）相连。通过搭建此架构，迅速形成了统一运维多个云端资源的能力。\n\r 负载均衡和服务发现 通过Nginx反向代理提供负载均衡，支持4层和7层的请求转发和后端绑定。通过服务发现可以实时监测到后端服务器特定端口服务的健康状态。\n云上伸缩应用 在业务高峰期或迅速增长期，通过微服务和容器级别的监控，在云端进行分钟级快速扩容，把某些特定业务流量引到新增容器。高峰期业务流量达到扩容指标，可秒级触发容器的横向扩展或纵向扩展操作。\n\r 混合容灾 IT系统同时部署到云上和云下，云上提供服务和容灾，云下专用容灾。利用调度和异常恢复策略，实现了服务级别的亲和性调度，支持跨云上可用区的高可用和灾难恢复。\n云下开发测试 实现了，云下、云上、测试与生产环境的全方位统一，云下开发测试后的应用无缝全自动发布至云上。\n基于Docker Swarm的微服务集群 微租混合云中所涉及的公有云（阿里云）的计算资源主要集中在容器服务（Container Service）。通过其提供的高性能可伸缩的容器应用管理服务，对Docker容器进行应用生命周期管理。从而使微租系统具备多种应用发布方式和持续交付能力，即构成了微租所需要的微服务架构。微租IT系统通过容器服务一站式整合了公有云的虚拟化、存储、网络和安全能力。\n容器服务的基础架构如下，其中：集群管理服务：提供Docker集群管理和调度。\n\r 服务发现：提供Docker的状态等元数据存储。Agent通信服务：提供每台宿主机和集群管理服务之间的通信服务。集群API：对外暴露统一OpenAPI。服务API：对外暴露兼容Docker Swarm的API。微租的IT开发人员可同时管理云上云下的资源，不需在多中云管理控制台中反复切换。基于容器基础设施无关的特性，使用同一套镜像和编排同时在云上云下部署应用。如下图所示，容器与所部属的应用有以下的对应关系，可随时重新部署应用来平衡统一集群中不同节点的负载，实现集群的效用最大化。\n\r 容器服务支撑起微租整体IT系统的DevOps自动化，实现从代码变更到代码构建，镜像构建和应用部署的全流程自动化。由于开发环境与生产环境完全一致，微租IT系统每次的迭代更新不仅是代码，还有基于完全不同语言、架构的整套环境。基于此，微租IT系统能够完成每天10+以上的版本更迭，同时能够得到实时的持续反馈，每次集成或交付，都会得到第一时间的结果反馈，做到实时响应。\n已投入生产的微服务 由于使用了微服务架构，不同的生产与测试环境的搭建以及上线后的运维难度大幅下降为接近于零，使得系统同时涉及不同的编程语言成为一种可行并且最优的解决方案。在实现系统技术模块的全面解耦的同时，针对不同的应用场景选择最合适的编程语言与技术框架进行开发。目前已经使用的编程语言与框架如下图所示：\n\r 其中，提供底层支持的是运行在CentOS集群之上的Docker Swarm用以支撑整个容器服务。\n Python具备大量的图片处理、爬虫、数据分析方面的第三方库，微租IT系统使用Flask框架为其他模块提供标准的RESTful API服务，主要用于系统中的分布式爬虫、图像批量压缩、合同自动生成等功能。 Node js由于其非阻塞机制非常适合大规模并发的应用场景，所以通过结合FIS3和Express框架同样通过RESTful API服务提供了IT系统里面最大并发量的两个应用微租鹰眼和短信群发模块。 由于大部分的第三方API仅提供了Java的接口或SDK，如芝麻信用API、某些GPS设备的回传接口等，其Spring BOOT框架也是通过标准化的RESTful API向微租IT系统其他模块或第三方系统提供服务。 C# .Net Core主要用于系统的ERP系统、各级Agent、微信公众号、微信小程序后台服务的开发。同样搭建在Docker的虚拟化技术之上，不再依赖Windows Server，实现基于Debian的轻量级全自动开发、测试与部署。 上述的各个微服务已经部署在阿里云的容器服务集群之中。  \r 功能架构 微租IT系统功能架构如下图所示。微租IT系统基于微租数据库，包括微租数据、微租社群及通过形成多维数据集支撑的PAM。 微租数据定位为微租内部系统，服务于微租员工的业务工作，包括B/S架构的ERP系统（PC端）和微信小程序（手机端）两个主要组成部分。PC端操作的ERP系统覆盖所有功能，一些有移动办公或即时拍照需要的功能（如意向客户回访、资产盘点、验车上牌等）通过微信小程序实现。\n微租社群定位为支撑DP部门的司机社群运营，包括微租社群微信公众号和微租社群微信小程序两个组成部分。微信公众号主要提供数据发布和信息推送功能，为社群成员（网约车司机）提供如违章查询、高发违章地点列表、积分查询和不定时的活动参与推送。微信小程序主要作为数据交互平台，实现包括司机收入报告、事故报告、维修保养报告等功能，便于司机在工作过程中随时向DP部门传送数据。 通过对全渠道、全过程的大数据抽取与清洗、模型运算与可视化，微租研发实现了一整套PAM（Perspective Action Model）模式，基于微租数据库形成多维数据集，从各个维度穿透财务、资产、人力、司机管理等环节的整个流程，实现各个环节的KPI指数分解，同时针对分解项给出标准化的改进规则与实施方案，支撑各业务数据分析和决策。\n\r 相关链接 公众号\n小程序 \u0026ndash;\u0026gt;\n结果： 2017.08开始进行梳理，10月应急功能上线，12月基本实现前端（销售）和中端（AMC与DP）业务覆盖。开发功能近千个，系统已全面覆盖主营业务，更覆盖企业管理90%以上。\n主要功能图 \r 系统效果图 \r\r\r\r\r\r\r\r\r\r\r ","date":1547228465,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1547228465,"objectID":"bdf5fc08d639cc4abab04fabfa241e1f","permalink":"https://cytgenkidu.github.io/project/weizu-erp/","publishdate":"2019-01-11T12:41:05-05:00","relpermalink":"/project/weizu-erp/","section":"project","summary":"围绕以租车、以租代购为主营业务的汽车租赁公司和融资租赁公司，为提高企业运营效率而设计开发的管理系统。","tags":["APS.NET","DOTNET","NET","ERP","MySQL"],"title":"微租数据—基于.NET的ERP系统及其他微服务","type":"project"},{"authors":null,"categories":null,"content":" 项目介绍： 公司计划与德国大众上汽斯柯达汽车公司合作，设计关爱出行实施方案，提前为项目做准备，确保方案及关键技术能够行得通。\n开发过程： 快速了解简单需求后，参考市场上已有案例Uber Health和Lyft Bussiness，调研现有网约车平台，在此基础上结合需求设计出三种不同的实施方案，包括各方案运行流程、优缺点、基础设施预算、关键技术、关键页面原型等，并对关键技术进行简单测试，确保能够实施。\n需求 \r\r 三种方案流程图 \r\r\r\r 结果： 项目资金审批暂未通过，项目搁置。\n效果图 \r\r\r\r ","date":1543686065,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543686065,"objectID":"d1c0ac45bffab72cee53370dd92923b8","permalink":"https://cytgenkidu.github.io/project/weizu-caredriver/","publishdate":"2018-12-01T12:41:05-05:00","relpermalink":"/project/weizu-caredriver/","section":"project","summary":"设计关爱出行实施方案。","tags":["流程图","HTML5","Demo"],"title":"CareDriver Initial Plan关爱出行初步方案设计与调研","type":"project"},{"authors":null,"categories":null,"content":" 项目介绍： 搭建微信小程序积分商店，客户使用小程序通过支付宝、微信等形式进行租金支付。\n开发过程： 基于Github上找到的开源项目https://github.com/tumobi/nideshop 仿网易严选小程序Demo，在此基础上参考小程序开发手册进行开发。后端使用.NET Core 搭建接口服务，使用它提供的微信和支付宝的支付功能。\n结果： 客户能够通过积分在小程序上兑换商品，并通过小程序对每月租金进行付款。\n效果图 \r\r\r\r\r\r\r\r ","date":1539193265,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1539193265,"objectID":"87eeb4d8b20f216350b71ae32cc18d03","permalink":"https://cytgenkidu.github.io/project/weizu-xiaochengxu/","publishdate":"2018-10-10T12:41:05-05:00","relpermalink":"/project/weizu-xiaochengxu/","section":"project","summary":"搭建微信小程序积分商店，客户使用小程序通过支付宝、微信等形式进行租金支付。","tags":["DOTNET Core","NET","微信小程序","Docker","REST APIs"],"title":"微租小程序—基于.NET Core的微信小程序开发","type":"project"},{"authors":null,"categories":null,"content":"\u0026hellip;\n","date":1530115200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1530115200,"objectID":"18d05a63a1c8d7ed973cc51838494e41","permalink":"https://cytgenkidu.github.io/privacy/","publishdate":"2018-06-28T00:00:00+08:00","relpermalink":"/privacy/","section":"","summary":"\u0026hellip;","tags":null,"title":"Privacy Policy","type":"page"},{"authors":null,"categories":null,"content":" 项目介绍 为提高企业环境风险评估效率，结合人保机构和评估机构对企业风险评估的管理标准和要求，而设计开发的ERP管理系统。\n开发过程 针对环境责任保险风险评估服务管理工作，根据环境责任保险风险评估模型的说明文档，设计出各行业标准的数据结构及整理出各标准的评估模型计算方法。为确保计算速度及可维护性，最后选择将复杂的评估模型算法编写成存储过程进行计算。\n用例图 \r 流程图 \r 跨职能流程图 \r 结果 全面覆盖环境责任保险风险评估模型的说明文档中的所有风险评估模型，简化了企业风险评估过程，提高评估公司评估效率，实现了对评估项目的分配、录入、评分、统计等统一化管理。\n效果图 \r\r\r\r\r\r\r\r\r ","date":1513100465,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1513100465,"objectID":"ea61459e52c1dd1e0dd335155a00df57","permalink":"https://cytgenkidu.github.io/project/huanjing-erp/","publishdate":"2017-12-12T12:41:05-05:00","relpermalink":"/project/huanjing-erp/","section":"project","summary":"为提高企业环境风险评估效率，结合人保机构和评估机构对企业风险评估的管理标准和要求，而设计开发的ERP管理系统。","tags":["DOTNET","NET","ERP","数据库","MySQL","流程分析"],"title":"环境保险风险评估服务平台—基于.NET的ERP系统设计与开发","type":"project"},{"authors":null,"categories":null,"content":" 项目介绍 与人保公司合作项目，开发微信小程序和安卓APP后端服务，实现移动办公，记录评估人员评估轨迹，随时随地上传提交现场风险隐患点及整改情况现场勘查照片。\n开发过程 参考小程序开发文档，使用小程序开发工具进行开发微信小程序。后端使用.NET Core 搭建接口服务，在人保内部网络进行部署，满足小程序接口及安卓后台接口。使用阿里云OSS存储记录现场勘查图片。\n结果 实现评估轨迹查询，实现现场勘查随时上传，实现企业风险点随时记录。\n","date":1513014065,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1513014065,"objectID":"7b77f3a98fb4b03b75670b744f791cc5","permalink":"https://cytgenkidu.github.io/project/huanjing-xiaochengxu/","publishdate":"2017-12-11T12:41:05-05:00","relpermalink":"/project/huanjing-xiaochengxu/","section":"project","summary":"与人保公司合作项目，开发微信小程序和安卓APP后端服务，实现移动办公，记录评估人员评估轨迹，随时随地上传提交现场风险隐患点及整改情况现场勘查照片。","tags":["DOTNET Core","DOTNET","NET","微信小程序","REST APIs"],"title":"安环云—基于.NET Core的微信小程序及安卓后台项目开发","type":"project"},{"authors":["GA Cushen"],"categories":null,"content":"More detail can easily be written here using Markdown and $\\rm \\LaTeX$ math code.\n","date":1441036800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1441036800,"objectID":"d77fa4a74076ffcd7ca6c21cfc27a4b2","permalink":"https://cytgenkidu.github.io/publication/person-re-id/","publishdate":"2015-09-01T00:00:00+08:00","relpermalink":"/publication/person-re-id/","section":"publication","summary":"Person re-identification is a critical security task for recognizing a person across spatially disjoint sensors. Previous work can be computationally intensive and is mainly based on low-level cues extracted from RGB data and implemented on a PC for a fixed sensor network (such as traditional CCTV). We present a practical and efficient framework for mobile devices (such as smart phones and robots) where high-level semantic soft biometrics are extracted from RGB and depth data. By combining these cues, our approach attempts to provide robustness to noise, illumination, and minor variations in clothing. This mobile approach may be particularly useful for the identification of persons in areas ill-served by fixed sensors or for tasks where the sensor position and direction need to dynamically adapt to a target. Results on the BIWI dataset are preliminary but encouraging. Further evaluation and demonstration of the system will be available on our website.","tags":[],"title":"A Person Re-Identification System For Mobile Devices","type":"publication"},{"authors":["GA Cushen","MS Nixon"],"categories":null,"content":"More detail can easily be written here using Markdown and $\\rm \\LaTeX$ math code.\n","date":1372608000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1372608000,"objectID":"2b4d919e3cf73dfcd0063c88fe01cb00","permalink":"https://cytgenkidu.github.io/publication/clothing-search/","publishdate":"2013-07-01T00:00:00+08:00","relpermalink":"/publication/clothing-search/","section":"publication","summary":"A mobile visual clothing search system is presented whereby a smart phone user can either choose a social networking image or capture a new photo of a person wearing clothing of interest and search for similar clothing in a large cloud-based ecommerce database. The phone's GPS location is used to re-rank results by retail store location, to inform the user of local stores where similar clothing items can be tried on.","tags":[],"title":"Mobile visual clothing search","type":"publication"},{"authors":null,"categories":null,"content":" Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = \\;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne\r Two\r Three\r\nA fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears  Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view   Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links   night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links  Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }  Questions? Ask\nDocumentation\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c2915ec5da95791851caafdcba9664af","permalink":"https://cytgenkidu.github.io/slides/example-slides/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/slides/example-slides/","section":"slides","summary":"Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$","tags":null,"title":"Slides","type":"slides"}]