<!DOCTYPE html>
<html lang="zh-cn">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.1.0">
  <meta name="generator" content="Hugo 0.54.0" />

  

  
  
  
  
  
  
  
  
  
  

  
  <meta name="author" content="Tgenkidu Cy">

  
  
  
  
  
  <meta name="description" content="字符指针 在指针的类型中我们知道有一种指针类型为字符指针 char* ;
一般使用:
char ch = &#39;w&#39;; char *pc = &amp;ch; *pc = &#39;w&#39;;  char arr[] = &quot;abcdef&quot;; char* pc = arr; printf(&quot;%s\n&quot;, arr);//abcdef printf(&quot;%s\n&quot;, pc);//abcdef  还有一种使用方式如下：
char* p= &quot;abcdef&quot;;//&quot;abcdef&quot; 是一个常量字符串，存放的是a的地址 printf(&quot;%c\n&quot;, p);//a printf(&quot;%s\n&quot;, p);//abcdef *p=&#39;W&#39;; //printf(&quot;%s\n&quot;, p);//err,准确的写法const char* p= &quot;abcdef&quot;;  面试题 char arr1[] = &quot;abcdef&quot;; char arr2[] = &quot;abcdef&quot;; const char* p1 = &quot;abcdef&quot;;//常量自字符串 const char* p2 = &quot;abcdef&quot;;//常量自字符串里 //p1、p2指向的是一个同一个常量字符串，p1和p2指向同一个地址 //C/C&#43;&#43;会把常量字符串存储到单独的一个内存区域， //当几个指针。指向同一个字符串的时候，他们实际会指向同一块内存。 //但是用相同的常量字符串去初始化不同的数组的时候就会开辟出不同的内存块。 if (arr1 == arr2) { printf(&quot;hehe\n&quot;); } else { printf(&quot;haha\n&quot;);//打印 } if (p1 == p2) { printf(&quot;hehe\n&quot;);//打印 } else { printf(&quot;haha\n&quot;); }  指针数组 指针数组的定义 //指针数组 是数组，用来存放指针的 int arr[10] = {0};//整形数组 char ch[5] = { 0 };//字符数组 int* parr[4];//存放整形指针的数组 - 指针数组 char* pch[5];//存放字符指针的数组 - 指针数组  指针数组的用途 //实际中不会这么用 int a = 10; int b = 20; int c = 30; int d = 40; int* arr[4] = {&amp;a, &amp;b, &amp;c, &amp;d}; int i = 0; for (i = 0; i &lt; 4; i&#43;&#43;) { printf(&quot;%d &quot;, *(arr[i]));//10 20 30 40 }  实际用途">

  
  <link rel="alternate" hreflang="zh-cn" href="https://cytgenkidu.github.io/tutorial/c/10/">

  


  

  

  

  

  

  

  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  
  
  
  
  <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

  
  
  
  
  
  
  
  
  
  <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/styles/github.min.css" crossorigin="anonymous" title="hl-light">
  <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
  
  
  

  

  

  

  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700|Roboto:400,400italic,700|Roboto+Mono">
  

  <link rel="stylesheet" href="/styles.css">
  

  
  
  

  
  <link rel="alternate" href="https://cytgenkidu.github.io/index.xml" type="application/rss+xml"
    title="Cytgenkidu">
  <link rel="feed" href="https://cytgenkidu.github.io/index.xml" type="application/rss+xml" title="Cytgenkidu">
  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://cytgenkidu.github.io/tutorial/c/10/">

  
  
  
  
  
  
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="Cytgenkidu">
  <meta property="og:url" content="https://cytgenkidu.github.io/tutorial/c/10/">
  <meta property="og:title" content=" | Cytgenkidu">
  <meta property="og:description" content="字符指针 在指针的类型中我们知道有一种指针类型为字符指针 char* ;
一般使用:
char ch = &#39;w&#39;; char *pc = &amp;ch; *pc = &#39;w&#39;;  char arr[] = &quot;abcdef&quot;; char* pc = arr; printf(&quot;%s\n&quot;, arr);//abcdef printf(&quot;%s\n&quot;, pc);//abcdef  还有一种使用方式如下：
char* p= &quot;abcdef&quot;;//&quot;abcdef&quot; 是一个常量字符串，存放的是a的地址 printf(&quot;%c\n&quot;, p);//a printf(&quot;%s\n&quot;, p);//abcdef *p=&#39;W&#39;; //printf(&quot;%s\n&quot;, p);//err,准确的写法const char* p= &quot;abcdef&quot;;  面试题 char arr1[] = &quot;abcdef&quot;; char arr2[] = &quot;abcdef&quot;; const char* p1 = &quot;abcdef&quot;;//常量自字符串 const char* p2 = &quot;abcdef&quot;;//常量自字符串里 //p1、p2指向的是一个同一个常量字符串，p1和p2指向同一个地址 //C/C&#43;&#43;会把常量字符串存储到单独的一个内存区域， //当几个指针。指向同一个字符串的时候，他们实际会指向同一块内存。 //但是用相同的常量字符串去初始化不同的数组的时候就会开辟出不同的内存块。 if (arr1 == arr2) { printf(&quot;hehe\n&quot;); } else { printf(&quot;haha\n&quot;);//打印 } if (p1 == p2) { printf(&quot;hehe\n&quot;);//打印 } else { printf(&quot;haha\n&quot;); }  指针数组 指针数组的定义 //指针数组 是数组，用来存放指针的 int arr[10] = {0};//整形数组 char ch[5] = { 0 };//字符数组 int* parr[4];//存放整形指针的数组 - 指针数组 char* pch[5];//存放字符指针的数组 - 指针数组  指针数组的用途 //实际中不会这么用 int a = 10; int b = 20; int c = 30; int d = 40; int* arr[4] = {&amp;a, &amp;b, &amp;c, &amp;d}; int i = 0; for (i = 0; i &lt; 4; i&#43;&#43;) { printf(&quot;%d &quot;, *(arr[i]));//10 20 30 40 }  实际用途">
  <meta property="og:image" content="https://cytgenkidu.github.io/img/icon-192.png">
  <meta property="og:locale" content="zh-cn">
  
  
  <meta property="article:published_time" content="2021-02-20T00:00:00&#43;01:00">
  
  
  <meta property="article:modified_time" content="2021-02-20T00:00:00&#43;01:00">
  
  

  

  

  <title> | Cytgenkidu</title>

  <script>
    var _hmt = _hmt || [];
    (function () {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fcb4ffd03ad556276685a41c0ba9d475";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();

  </script>
</head>

<body id="top" data-spy="scroll"
  data-target="#TableOfContents" data-offset="71"
  >
  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>搜索</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="搜索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" role="textbox" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Cytgenkidu</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="切换导航">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#about">
            
            <span>首页</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#posts">
            
            <span>博客</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/tutorial/">
            
            <span>笔记</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#contact">
            
            <span>联系</span>
            
          </a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>



<div class="container-fluid docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 docs-sidebar">
      




<form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-3" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <span><i class="fas fa-bars"></i></span>
  </button>

  
  <input name="q" type="search" class="form-control" id="search-query" placeholder="搜索..." autocomplete="off">
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/c/">概述</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/c/1/">1、基础知识</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/tutorial/c/1/">初识C语言</a>
      </li>
      
      <li >
        <a href="/tutorial/java/1/">基本概念</a>
      </li>
      
      <li >
        <a href="/tutorial/c/2/">分支语句和循环语句</a>
      </li>
      
      <li >
        <a href="/tutorial/c/3/">函数</a>
      </li>
      
      <li >
        <a href="/tutorial/c/4/">数组</a>
      </li>
      
      <li >
        <a href="/tutorial/c/5/">操作符详解</a>
      </li>
      
      <li >
        <a href="/tutorial/c/6/">指针</a>
      </li>
      
      <li >
        <a href="/tutorial/c/7/">结构体</a>
      </li>
      
      <li >
        <a href="/tutorial/c/8/">实用调试技巧</a>
      </li>
      
      <li >
        <a href="/tutorial/c/9/">数据的存储</a>
      </li>
      
      <li class="active">
        <a href="/tutorial/c/10/">指针的详解</a>
      </li>
      
      <li >
        <a href="/tutorial/c/11/">字符函数和字符串函数</a>
      </li>
      
      <li >
        <a href="/tutorial/c/12/">自定义类型：结构体，枚举，联合</a>
      </li>
      
      <li >
        <a href="/tutorial/c/13/">动态内存管理</a>
      </li>
      
      <li >
        <a href="/tutorial/c/14/">文件操作</a>
      </li>
      
      <li >
        <a href="/tutorial/c/15/">程序环境和预处理</a>
      </li>
      
    </ul>
    

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutorial/c/%E4%B8%89%E5%AD%90%E6%A3%8B/">2、应用</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/tutorial/c/%E4%B8%89%E5%AD%90%E6%A3%8B/">三子棋的实现</a>
      </li>
      
      <li >
        <a href="/tutorial/c/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/">扫雷游戏的实现</a>
      </li>
      
      <li >
        <a href="/tutorial/c/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/">汉诺塔问题</a>
      </li>
      
      <li >
        <a href="/tutorial/c/contact/">通讯录的实现</a>
      </li>
      
      <li >
        <a href="/tutorial/c/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/">青蛙跳台阶问题</a>
      </li>
      
    </ul>
    

  </div>
  
  
</nav>

    </div>

    
    <div class="d-none d-xl-block col-xl-2 docs-toc">
      
      <p class="docs-toc-title">在本页</p>
      

      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#字符指针">字符指针</a>
<ul>
<li><a href="#面试题">面试题</a></li>
</ul></li>
<li><a href="#指针数组">指针数组</a>
<ul>
<li><a href="#指针数组的定义">指针数组的定义</a></li>
<li><a href="#指针数组的用途">指针数组的用途</a></li>
</ul></li>
<li><a href="#数组指针">数组指针</a>
<ul>
<li><a href="#数组名vs数组名">&amp;数组名VS数组名</a></li>
<li><a href="#数组指针的使用">数组指针的使用</a></li>
</ul></li>
<li><a href="#数组参数-指针参数">数组参数、指针参数</a>
<ul>
<li><a href="#一维数组传参">一维数组传参</a></li>
<li><a href="#二维数组传参">二维数组传参</a></li>
<li><a href="#一级指针传参">一级指针传参</a></li>
<li><a href="#二级指针传参">二级指针传参</a></li>
</ul></li>
<li><a href="#函数指针">函数指针</a></li>
<li><a href="#函数指针数组">函数指针数组</a>
<ul>
<li><a href="#函数指针定义">函数指针定义</a></li>
<li><a href="#练习">练习</a></li>
<li><a href="#函数指针数组的用途-转移表">函数指针数组的用途：转移表</a></li>
</ul></li>
<li><a href="#指向函数指针数组的指针">指向函数指针数组的指针</a></li>
<li><a href="#回调函数">回调函数</a>
<ul>
<li><a href="#使用场景">使用场景</a></li>
<li><a href="#qsort函数">qsort函数</a></li>
<li><a href="#qsort函数实现冒泡排序">qsort函数实现冒泡排序</a></li>
</ul></li>
<li><a href="#指针和数组笔试题解析">指针和数组笔试题解析</a>
<ul>
<li><a href="#一维数组">一维数组</a>
<ul>
<li><a href="#整形数组">整形数组</a></li>
<li><a href="#字符数组1">字符数组1</a></li>
<li><a href="#字符数组2">字符数组2</a></li>
<li><a href="#字符数组3">字符数组3</a></li>
</ul></li>
<li><a href="#二维数组">二维数组</a></li>
<li><a href="#指针相关">指针相关</a>
<ul>
<li><a href="#指针加减整数的运算1">指针加减整数的运算1</a></li>
<li><a href="#指针加减整数的运算2">指针加减整数的运算2</a></li>
<li><a href="#指针加减整数的运算3">指针加减整数的运算3</a></li>
<li><a href="#指针加减整数的运算4">指针加减整数的运算4</a></li>
<li><a href="#指针加减整数的运算5">指针加减整数的运算5</a></li>
<li><a href="#指针加减整数的运算6">指针加减整数的运算6</a></li>
<li><a href="#指针加减整数的运算7">指针加减整数的运算7</a></li>
<li><a href="#指针加减整数的运算8">指针加减整数的运算8</a></li>
<li><a href="#旋转字符串">旋转字符串</a></li>
<li><a href="#字符串旋转结果">字符串旋转结果</a></li>
<li><a href="#杨氏矩阵">杨氏矩阵</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav> 

      <ul class="nav toc-top">
        <li><a href="#">回到顶部</a></li>
      </ul>

      
    </div>
    

    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 docs-content" role="main">

      <article class="article" itemscope itemtype="http://schema.org/Article">

        <div class="docs-article-container">
          <h1 itemprop="name"></h1>

          <div class="article-style" itemprop="articleBody">
            

<h2 id="字符指针">字符指针</h2>

<p>在指针的类型中我们知道有一种指针类型为字符指针 char* ;</p>

<p>一般使用:</p>

<pre><code class="language-C++">char ch = 'w';
char *pc = &amp;ch;
*pc = 'w';
</code></pre>

<pre><code class="language-C++">char arr[] = &quot;abcdef&quot;;
char* pc = arr;
printf(&quot;%s\n&quot;, arr);//abcdef
printf(&quot;%s\n&quot;, pc);//abcdef
</code></pre>

<p>还有一种使用方式如下：</p>

<pre><code class="language-C++">char* p= &quot;abcdef&quot;;//&quot;abcdef&quot; 是一个常量字符串，存放的是a的地址
printf(&quot;%c\n&quot;, p);//a
printf(&quot;%s\n&quot;, p);//abcdef
*p='W';
//printf(&quot;%s\n&quot;, p);//err,准确的写法const char* p= &quot;abcdef&quot;;
</code></pre>

<p><img src="../img/10/常量字符.png" alt="Image text" /></p>

<h3 id="面试题">面试题</h3>

<pre><code class="language-C++">char arr1[] = &quot;abcdef&quot;;
char arr2[] = &quot;abcdef&quot;;
const char* p1 = &quot;abcdef&quot;;//常量自字符串
const char* p2 = &quot;abcdef&quot;;//常量自字符串里
//p1、p2指向的是一个同一个常量字符串，p1和p2指向同一个地址
//C/C++会把常量字符串存储到单独的一个内存区域，
//当几个指针。指向同一个字符串的时候，他们实际会指向同一块内存。
//但是用相同的常量字符串去初始化不同的数组的时候就会开辟出不同的内存块。
if (arr1 == arr2)
{
    printf(&quot;hehe\n&quot;);
}
else
{
    printf(&quot;haha\n&quot;);//打印
}

if (p1 == p2)
{
    printf(&quot;hehe\n&quot;);//打印
}
else
{
    printf(&quot;haha\n&quot;);
}
</code></pre>

<p><img src="../img/10/常量字符2.png" alt="Image text" /></p>

<h2 id="指针数组">指针数组</h2>

<h3 id="指针数组的定义">指针数组的定义</h3>

<pre><code class="language-C++">//指针数组 是数组，用来存放指针的

int arr[10] = {0};//整形数组
char ch[5] = { 0 };//字符数组
int* parr[4];//存放整形指针的数组 - 指针数组
char* pch[5];//存放字符指针的数组 - 指针数组
</code></pre>

<h3 id="指针数组的用途">指针数组的用途</h3>

<pre><code class="language-C++">//实际中不会这么用
int a = 10;
int b = 20;
int c = 30;
int d = 40;
int* arr[4] = {&amp;a, &amp;b, &amp;c, &amp;d};
int i = 0;
for (i = 0; i &lt; 4; i++)
{
    printf(&quot;%d &quot;, *(arr[i]));//10 20 30 40
}
</code></pre>

<p><img src="../img/10/指针数组.png" alt="Image text" /></p>

<p><strong>实际用途</strong></p>

<pre><code class="language-C++">int arr1[] = { 1, 2, 3, 4, 5 };
int arr2[] = { 2, 3, 4, 5, 6 };
int arr3[] = { 3, 4, 5, 6, 7 };

int* parr[] = { arr1, arr2, arr3 };
int i = 0;
for (i = 0; i &lt; 3; i++)
{
    int j = 0;
    for (j = 0; j &lt; 5; j++)
    {
        printf(&quot;%d &quot;, *(parr[i] + j));
    }
    printf(&quot;\n&quot;);
}
</code></pre>

<p><img src="../img/10/指针数组用途.png" alt="Image text" /></p>

<p><img src="../img/10/结果.png" alt="Image text" /></p>

<h2 id="数组指针">数组指针</h2>

<p>数组指针是指针？还是数组？</p>

<p>答案是：指针。</p>

<pre><code class="language-C++">//int *p = NULL; //p是整形指针 - 指向整形的指针 - 可以存放整形的地址
//char* pc = NULL;//pc是字符指针 - 指向字符的指针 - 可以存放字符的地址
//数组指针 - 指向数组的指针 - 存放数组的地址
//int arr[10] = {0};
//arr- 首元素地址
//&amp;arr[0] -首元素的地址
//&amp;arr - 数组的地址

int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int (*p)[10] = &amp;arr;//数组的地址要存起来
//上面的p就是数组指针
printf(&quot;%p\n&quot;, arr );
printf(&quot;%p\n&quot;, arr + 1);
printf(&quot;%p\n&quot;, &amp;arr );
printf(&quot;%p\n&quot;, &amp;arr+1);
</code></pre>

<p><img src="../img/10/数组指针地址.png" alt="Image text" /></p>

<p>&amp;arr和arr，虽然值是一样的，但是意义应该不一样的。
实际上： &amp;arr 表示的是数组的地址，而不是数组首元素的地址。
数组的地址+1，跳过整个数组的大小，所以 &amp;arr+1 相对于 &amp;arr 的差值是40.</p>

<h3 id="数组名vs数组名">&amp;数组名VS数组名</h3>

<h3 id="数组指针的使用">数组指针的使用</h3>

<pre><code class="language-C++">char* arr[5];
char* (*pa)[5] = &amp;arr;;//把数组arr的地址赋值给数组指针变量pa
//但是我们一般很少这样写代码
</code></pre>

<p><img src="../img/10/数组指针定义.png" alt="Image text" /></p>

<p>一个数组指针的使用：</p>

<pre><code class="language-C++">//参数是数组的形式
void print1(int arr[3][5], int x, int y)
{
    int i = 0;
    int j = 0;
    for (i = 0; i &lt; x; i++)
    {
        for (j = 0; j &lt; y; j++)
        {
            printf(&quot;%d &quot;, arr[i][j]);
        }
        printf(&quot;\n&quot;);
    }
}

//参数是指针的形式
void print2(int(*p)[5], int x, int y)
{
    int i = 0;
    for (i = 0; i &lt; x; i++)
    {
        int j = 0;
        for (j = 0; j &lt; y; j++)
        {
            printf(&quot;%d &quot;, p[i][j]);
            //printf(&quot;%d &quot;, *(p[i] + j));//
            //printf(&quot;%d &quot;, *(*(p + i) + j));
            //printf(&quot;%d &quot;, (*(p + i))[j]);//*(p + i)找到第i行j元素
        }
        printf(&quot;\n&quot;);
    }
}

int main()
{
    int arr[3][5] = { { 1, 2, 3, 4, 5 }, { 2, 3, 4, 5, 6 }, { 3, 4, 5, 6, 7 } };

    //print1(arr, 3, 5);//arr - 数组名 - 数组名就是首元素地址

    //但是二维数组的首元素是二维数组的第一行
    //所以这里传递的arr，其实相当于第一行的地址，是一维数组的地址
    //可以数组指针来接收
    print_arr2(arr, 3, 5);
    return 0;
}
</code></pre>

<p><strong>arr[i] == *(arr+i) == *(p+i) == p[i]</strong></p>

<pre><code class="language-C++">int arr[10] = {1,2,3,4,5,6,7,8,9,10};
int i = 0;
int* p = arr;
for (i = 0; i &lt; 10; i++)
{
    printf(&quot;%d &quot;, p[i]);//1 2 3 4 5 6 7 8 9 10
    printf(&quot;%d &quot;, *(p + i));//1 2 3 4 5 6 7 8 9 10
    printf(&quot;%d &quot;, *(arr + i));//1 2 3 4 5 6 7 8 9 10
    printf(&quot;%d &quot;, arr[i]);//arr[i] == *(arr+i) == *(p+i) == p[i]
}
</code></pre>

<p>//去掉数组名，就是存储的元素类型</p>

<pre><code class="language-C++">int arr[5]; //arr 是一个5个元素的整形数组
int *parr1[10]; //parr1 是一个数组，数组有10个元素，每个元素的类型是int* ,parr1是存放指针的数组。指针数组
int (*parr2)[10]; //parr2 是一个指针，改指针指向了一个数组，数组有10个元素，每个元素的类型是int,parr2 是数组指针
int (*parr3[10])[5];//parr3 是一个数组，该数组有10个元素，每个元素是一个数组指针，该数组指针指向的数组有5个元素，每个元素是int
</code></pre>

<p><img src="../img/10/parr3.png" alt="Image text" /></p>

<h2 id="数组参数-指针参数">数组参数、指针参数</h2>

<h3 id="一维数组传参">一维数组传参</h3>

<pre><code class="language-C++">#include &lt;stdio.h&gt;
void test(int arr[])//ok
{}
void test(int arr[10])//ok
{}
void test(int *arr)//ok
{}
void test2(int *arr[20])//ok
{}
void test2(int **arr)//ok
{}
int main()
{
 int arr[10] = {0};
 int *arr2[20] = {0};
 test(arr);
 test2(arr2);
}
</code></pre>

<h3 id="二维数组传参">二维数组传参</h3>

<pre><code class="language-C++">
void test(int arr[3][5])//ok
{}
void test(int arr[][])//err
{}
void test(int arr[][5])//ok
{}
void test(int arr[3][])//err
{}
//总结：二维数组传参，函数形参的设计只能省略第一个[]的数字。
//因为对一个二维数组，可以不知道有多少行，但是必须知道一行多少元素。
//这样才方便运算。
void test(int *arr)//err
{}
void test(int* arr[5])//ok
{}
void test(int (*arr)[5])//ok
{}
void test(int **arr)//err
{}
int main()
{
 int arr[3][5] = {0};
 test(arr);//传入arr的第一行的地址，是个一维数组的地址值
}
</code></pre>

<h3 id="一级指针传参">一级指针传参</h3>

<pre><code class="language-C++">#include &lt;stdio.h&gt;
void print(int *p, int sz)
{
 int i = 0;
 for(i=0; i&lt;sz; i++)
 {
 printf(&quot;%d\n&quot;, *(p+i));
 }
}
int main()
{
 int arr[10] = {1,2,3,4,5,6,7,8,9};
 int *p = arr;
 int sz = sizeof(arr)/sizeof(arr[0]);
 //一级指针p，传给函数
 print(p, sz);
 return 0;
}
</code></pre>

<pre><code class="language-C++">void test1(int *p)
{}
//test1函数能接收什么参数？
void test2(char* p)
{}
//test2函数能接收什么参数？
int main()
{
    int a = 10;
    int* p1 = &amp;a;
    test1(&amp;a);//ok
    test1(p1);//ok

    char ch = 'w';
    char* pc = &amp;ch;
    test2(&amp;ch);//ok
    test2(pc);//ok
    return 0;
}
</code></pre>

<h3 id="二级指针传参">二级指针传参</h3>

<pre><code class="language-C++">#include &lt;stdio.h&gt;
void test(int** ptr)
{
 printf(&quot;num = %d\n&quot;, **ptr);
}
int main()
{
 int n = 10;
 int*p = &amp;n;
 int **pp = &amp;p;
 test(pp);
 test(&amp;p);
 int* arr[10];
 test(arr);//指针数组也可以
 return 0;
}
</code></pre>

<h2 id="函数指针">函数指针</h2>

<p><strong>&amp;函数名 和 函数名 都是函数的地址</strong></p>

<pre><code class="language-C++">//数组指针 - 是指向数组的指针
//函数指针 - 是指向函数的指针 - 存放函数地址的一个指针

int Add(int x, int y)
{
    int z = 0;
    z = x + y;
    return z;
}

int main()
{
    int a = 10;
    int b = 20;

    //int arr[10] = { 0 };
    //int (*p)[10] = &amp;arr;

    //arr;//&amp;arr
    //printf(&quot;%d\n&quot;, Add(a, b));

    //&amp;函数名 和 函数名 都是函数的地址
    /*
    printf(&quot;%p\n&quot;, &amp;Add);
    printf(&quot;%p\n&quot;, Add);
    */
    int (*pa)(int, int) = Add;
    printf(&quot;%d\n&quot;, (*pa)(2, 3));//5

    return 0;
}
</code></pre>

<pre><code class="language-C++">void Print(char*str)
{
    printf(&quot;%s\n&quot;, str);
}

int main()
{
    int a;
    int * pa;
    void (*p)(char*) = Print;

    (*p)(&quot;hello&quot;);
    p(&quot;hello&quot;);
    p(&quot;hello world&quot;);
    return 0;
}
</code></pre>

<pre><code class="language-C++">//代码1
(*(void (*)())0)();//将0进行强制类型转换成【void (*)() 】-函数指针类型，该函数指针的类型是无参换返回类型是void,0就是一个函数的地址，然后*解引用，调用0地址处的该函数。

//代码2
void (* signal(int , void(*)(int)) )(int);//void(*)(int) 函数指针类型，该函数指针类型传入int返回void 。整个函数指针返回的是void(*  )(int)-函数指针类型

// signal是一个函数声明
// signal函数的参数有2个，第一个是int。第二个是函数指针，该函数指针指向的函数的参数是int，返回类型是void
// signal函数的返回类型也是一个函数指针：该函数指针指向的函数的参数是int，返回类型是void

////简化
//typedef void(*pfun_t)(int);
//pfun_t signal(int, pfun_t);
//
//typedef unsigned int uint;
</code></pre>

<p>注 :推荐《C陷阱和缺陷》</p>

<pre><code class="language-C++">int Add(int x, int y)
{
    int z = 0;
    z = x + y;
    return z;
}

int main()
{
    int a = 10;
    int b = 20;

    int(*pa)(int, int) = Add;
    printf(&quot;%d\n&quot;, pa(2, 3));
    printf(&quot;%d\n&quot;, Add(2, 3));
    //printf(&quot;%d\n&quot;, *pa(2, 3));//err
    printf(&quot;%d\n&quot;, (*pa)(2, 3));
    printf(&quot;%d\n&quot;, (**pa)(2, 3));
    return 0;
}
</code></pre>

<h2 id="函数指针数组">函数指针数组</h2>

<pre><code class="language-C++">int Add(int x, int y)
{
    return x + y;
}
int Sub(int x, int y)
{
    return x - y;
}
int Mul(int x, int y)
{
    return x * y;
}
int Div(int x, int y)
{
    return x / y;
}

int main()
{
    //指针数组
    //int* arr[5];

    //需要一个数组，这个数组可以存放4个函数的地址 - 函数指针的数组
    int (*pa)(int, int) = Add;//Sub/Mul/Div

    int(*parr[4])(int, int) = {Add, Sub, Mul, Div};//函数指针的数组
    
    int i = 0;
    for (i = 0; i &lt; 4; i++)
    {
        printf(&quot;%d\n&quot;, parr[i](2, 3));//5 -1 6 0
    }

    return 0;
}
</code></pre>

<h3 id="函数指针定义">函数指针定义</h3>

<pre><code class="language-C++">int (*parr1[10])();
int *parr2[10]();//err
int (*)() parr3[10];//err
</code></pre>

<h3 id="练习">练习</h3>

<pre><code class="language-C++">char* my_strcpy(char* dest, const char* src);
//1.写一个函数指针 pf，能够指向my_strcpy
char* (*pf)(char*, const char*);

//2. 写一个函数指针数组 pfArr，能够存放4个my_strcpy函数的地址
char* (*pfArr[4])(char*, const char*);
</code></pre>

<h3 id="函数指针数组的用途-转移表">函数指针数组的用途：转移表</h3>

<p><strong>例子：（计算器）</strong></p>

<pre><code class="language-C++">#include &lt;stdio.h&gt;
//计算器

void menu()
{
    printf(&quot;**************************\n&quot;);
    printf(&quot;**  1. add       2. sub **\n&quot;);
    printf(&quot;**  3. mul       4. div **\n&quot;);
    printf(&quot;**  5. xor       0. exit**\n&quot;);
    printf(&quot;**************************\n&quot;);
}

int Add(int x, int y)
{
    return x + y;
}

int Sub(int x, int y)
{
    return x - y;
}

int Mul(int x, int y)
{
    return x * y;
}

int Div(int x, int y)
{
    return x / y;
}

int Xor(int x, int y)
{
    return x ^ y;
}

//回调函数
void Calc(int (*pf)(int, int))
{
    int x = 0;
    int y = 0;
    printf(&quot;请输入两个操作数:&gt;&quot;);
    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
    printf(&quot;%d\n&quot;, pf(x, y));
}

int main()
{
    int input = 0;
    do
    {
        menu();
        printf(&quot;请选择:&gt;&quot;);
        scanf(&quot;%d&quot;, &amp;input);
        switch (input)
        {
        case 1:
            Calc(Add);
            break;
        case 2:
            Calc(Sub);
            break;
        case 3:
            Calc(Mul);
            break;
        case 4:
            Calc(Div);
            break;
        case 0:
            printf(&quot;退出\n&quot;);
            break;
        default:
            printf(&quot;选择错误\n&quot;);
            break;
        }
    } while (input);
    return 0;
}
</code></pre>

<p><strong>使用函数指针数组的实现main：</strong></p>

<pre><code class="language-C++">int main()
{
    int input = 0;
    int x = 0;
    int y = 0;

    //pfArr 是一个函数指针数组 - 转移表
    int(*pfArr[])(int, int) = {0, Add, Sub, Mul, Div, Xor};
    do
    {
        menu();
        printf(&quot;请选择:&gt;&quot;);
        scanf(&quot;%d&quot;, &amp;input);
        if (input &gt;= 1 &amp;&amp; input &lt;= 5)
        {
            printf(&quot;请输入两个操作数:&gt;&quot;);
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            int ret = pfArr[input](x, y);
            printf(&quot;%d\n&quot;, ret);
        }
        else if (input == 0)
        {
            printf(&quot;退出\n&quot;);
        }
        else
        {
            printf(&quot;选择错误\n&quot;);
        }
    } while (input);
}
</code></pre>

<h2 id="指向函数指针数组的指针">指向函数指针数组的指针</h2>

<p>指向函数指针数组的指针是一个指针，指针指向一个数组，数组的元素都是函数指针。</p>

<pre><code class="language-C++">int arr[10] = { 0 };
int (*p)[10] = &amp;arr;//取出数组的地址

int(*pf)(int, int);//函数指针
int (*pfArr[4])(int, int);//pfArr是一个数组-函数指针的数组
//ppfArr是一个指向[函数指针数组]的指针
int(*(*ppfArr)[4])(int, int) = &amp;pfArr;
//
//ppfArr 是一个数组指针，指针指向的数组有4个元素
//指向的数组的每个元素的类型是一个函数指针 int(*)(int, int)
//
</code></pre>

<h2 id="回调函数">回调函数</h2>

<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>

<pre><code class="language-C++">void print(char *str) //回调函数
{
    printf(&quot;hehe:%s&quot;, str);
}

void test( void (*p)(char*) )
{
    printf(&quot;test\n&quot;);
    p(&quot;hello&quot;);
}

int main()
{
    test(print);
    //test
    //hehe : hello
    return 0;
}
</code></pre>

<h3 id="使用场景">使用场景</h3>

<p>之前写的BubbleSort：只能排序整形数组</p>

<pre><code class="language-C++">void bubble_sort(int arr[], int sz)
{
    int i = 0;
    //趟数
    for (i = 0; i &lt; sz-1; i++)
    {
        //一趟冒泡排序
        int j = 0;
        for (j = 0; j &lt;sz-1-i; j++)//9 8 7 6 5 4 3 2 1 多少对
        {
            if (arr[j] &gt; arr[j + 1])
            {
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
            }
        }
    }
}
</code></pre>

<p><strong>void* 类型的指针 可以接受任意类型的地址</strong></p>

<pre><code class="language-C++">int a = 10;
//int* pa = &amp;a;//
//char* pc = &amp;a;

//char ch = 'w';
void* p = &amp;a;
//*p = 0;
//p++;

//p = &amp;ch;
//void* 类型的指针 可以接收任意类型的地址
//void* 类型的指针 不能进行解引用操作
//void* 类型的指针 不能进行+-整数的操作
</code></pre>

<h3 id="qsort函数">qsort函数</h3>

<p><img src="../img/10/qsort1.png" alt="Image text" /></p>

<p><img src="../img/10/qsort2.png" alt="Image text" /></p>

<h3 id="qsort函数实现冒泡排序">qsort函数实现冒泡排序</h3>

<pre><code class="language-C++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int cmp_int(const void *e1, const void *e2)
{
    //比较两个整形值的
    return *(int *)e1 - *(int *)e2;
}

void test1()
{
    int arr[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
    int sz = sizeof(arr) / sizeof(arr[0]);
    qsort(arr, sz, sizeof(arr[0]), cmp_int);
    int i = 0;
    for (i = 0; i &lt; sz; i++)
    {
        printf(&quot;%d &quot;, arr[i]);
    }
}

//比较浮点型
int cmp_float(const void *e1, const void *e2)
{
    /*if (*(float*)e1 == *(float*)e2)
        return 0;
    else if (*(float*)e1 &gt; *(float*)e2)
        return 1;
    else
        return -1;*/

    return ((int)(*(float *)e1 - *(float *)e2));
}

void test2()
{
    float f[] = {9.0, 8.0, 7.0, 6.0, 5.0, 4.0};
    int sz = sizeof(f) / sizeof(f[0]);
    qsort(f, sz, sizeof(f[0]), cmp_float);
    int j = 0;
    for (j = 0; j &lt; sz; j++)
    {
        printf(&quot;%f &quot;, f[j]);
    }
}

//比较结构体类型
struct Stu
{
    char name[20];
    int age;
};

int cmp_stu_by_age(const void *e1, const void *e2)
{
    return ((struct Stu *)e1)-&gt;age - ((struct Stu *)e2)-&gt;age;
}

int cmp_stu_by_name(const void *e1, const void *e2)
{
    //比较名字就是比较字符串
    //字符串比较不能直接用&gt;&lt;=来比较，应该用strcmp函数&lt;string.h&gt;
    return strcmp(((struct Stu *)e1)-&gt;name, ((struct Stu *)e2)-&gt;name);
}

void test3()
{
    struct Stu s[3] = {{&quot;zhangsan&quot;, 20}, {&quot;lisi&quot;, 30}, {&quot;wangwu&quot;, 10}};
    int sz = sizeof(s) / sizeof(s[0]);
    qsort(s, sz, sizeof(s[0]), cmp_stu_by_name);
    //第一个参数：待排序数组的收元素地址
    //第二个参数：待排序数组的元素个数
    //第三个参数：待排序数组的每个元素的大小-单位是字节
    //第四个参数：是函数指针，比较两个元素的所用函数的地址-这个函数使用者自己实现
    //           函数指针的两个参数是：待比较的两个元素的地址
}

//实现bubble_sort函数的程序员，他是否知道未来排序的数据类型-不知道
//那程序员也不知道，待比较的两个元素的类型
void Swap(char *buf1, char *buf2, int width)
{
    int i = 0;
    for (i = 0; i &lt; width; i++)
    {
        char tmp = *buf1;
        *buf1 = *buf2;
        *buf2 = tmp;
        buf1++; //指向下一个字符
        buf2++;
    }
}

//因为首元素类型不同，v所以使用void指针
//sz要排序元素个数
//width每个元素的字节数
//两个元素比较的方法不一样，把比较函数的地址传进来,e1,e2要比较的元素
void bubble_sort(void *base, int sz, int width, int (*cmp)(void *e1, void *e2))
{
    int i = 0;
    //趟数
    for (i = 0; i &lt; sz - 1; i++)
    {
        //每一趟比较的对数
        int j = 0;
        for (j = 0; j &lt; sz - 1 - i; j++)
        {
            //两个元素的比较
            if (cmp((char *)base + j * width, (char *)base + (j + 1) * width) &gt; 0)
            {
                //交换,一对一对字符交换
                Swap((char *)base + j * width, (char *)base + (j + 1) * width, width);
            }
        }
    }
}

void test4()
{
    int arr[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
    int sz = sizeof(arr) / sizeof(arr[0]);
    //使用bubble_sort的程序员一定知道自己排序的是什么数据
    //就应该知道如何比较待排序数组中的元素
    bubble_sort(arr, sz, sizeof(arr[0]), cmp_int);
}

void test5()
{
    struct Stu s[3] = {{&quot;zhangsan&quot;, 20}, {&quot;lisi&quot;, 30}, {&quot;wangwu&quot;, 10}};
    int sz = sizeof(s) / sizeof(s[0]);
    //bubble_sort(s, sz, sizeof(s[0]), cmp_stu_by_age);
    bubble_sort(s, sz, sizeof(s[0]), cmp_stu_by_name);
}

int main()
{

    //test1();
    //test2();
    //test3();
    //test4();
    test5();
    return 0;
}
</code></pre>

<h2 id="指针和数组笔试题解析">指针和数组笔试题解析</h2>

<p>数组名是首元素的地址</p>

<ol>
<li>sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小。</li>
<li>&amp;数组名，这里的数组名表示整个数组，取出的是整个数组的地址。</li>
<li>除此之外所有的数组名都表示首元素的地址。</li>
</ol>

<h3 id="一维数组">一维数组</h3>

<h4 id="整形数组">整形数组</h4>

<pre><code class="language-C++">int a[] = {1, 2, 3, 4};            //4*4 = 16
printf(&quot;%d\n&quot;, sizeof(a));         //sizeof(数组名)-计算的是数组总大小-单位是字节- 16
printf(&quot;%d\n&quot;, sizeof(a + 0));     //4/8 - 数组名这里表示收元素的值，a+0 还是首元素地址，地址的大小就是4/8个字节
printf(&quot;%d\n&quot;, sizeof(*a));        //4 - 数组名表示首元素地址，*a就是首元素，sizeof(*a)就是4
printf(&quot;%d\n&quot;, sizeof(a + 1));     //4/8 - 数组名这里表示收元素的值，a+1 第2个元素的地址，地址的大小就是4/8个字节
printf(&quot;%d\n&quot;, sizeof(a[1]));      //4 - 第2个元素的大小
printf(&quot;%d\n&quot;, sizeof(&amp;a));        //4/8 &amp;a取出的是数组的地址，但是数组的地址那也是地址，地址的大小就是4/8个字节
printf(&quot;%d\n&quot;, sizeof(*&amp;a));       //16 - &amp;a数组的地址，数组的地址解引用访问的数组，sizeof计算的就是数组的大小单位是字节
printf(&quot;%d\n&quot;, sizeof(&amp;a + 1));    //4/8   &amp;a是数组的地址，&amp;a+1虽然地址跳过整个数组，但还是地址，所以是4/8个字节
printf(&quot;%d\n&quot;, sizeof(&amp;a[0]));     //4/8 &amp;a[0]是第一个元素的地址
printf(&quot;%d\n&quot;, sizeof(&amp;a[0] + 1)); //4/8  &amp;a[0]+1 是第二个元素的地址
</code></pre>

<h4 id="字符数组1">字符数组1</h4>

<pre><code class="language-C++">char arr[] = {'a', 'b', 'c', 'd', 'e', 'f'};

printf(&quot;%d\n&quot;, strlen(arr));     //随机值
printf(&quot;%d\n&quot;, strlen(arr + 0)); //随机值
//printf(&quot;%d\n&quot;, strlen(*arr));//err
//printf(&quot;%d\n&quot;, strlen(arr[1]));//err

printf(&quot;%d\n&quot;, strlen(&amp;arr));//随机值
printf(&quot;%d\n&quot;, strlen(&amp;arr + 1));//随机值-6,与前一个随机值差6
printf(&quot;%d\n&quot;, strlen(&amp;arr[0] + 1));//随机值-1，与前一个随机值差1

printf(&quot;%d\n&quot;, sizeof(arr));         //sizeof计算机的是数组大小，6*1 = 6字节
printf(&quot;%d\n&quot;, sizeof(arr + 0));     //4/8 arr是首元素的地址，arr+0还是首元素的地址 地址的大小是4/8字节
printf(&quot;%d\n&quot;, sizeof(*arr));        //1   arr是首元素的地址，*arr就是首元素，首元素是字符大小是一个字节
printf(&quot;%d\n&quot;, sizeof(arr[1]));      //1
printf(&quot;%d\n&quot;, sizeof(&amp;arr));        //4/8 &amp;arr 虽然是数组的地址，但还是地址，地址大小是4/8个字节
printf(&quot;%d\n&quot;, sizeof(&amp;arr + 1));    //4/8 &amp;arr+1 是跳过整个数组后的地址，地址大小是4/8个字节
printf(&quot;%d\n&quot;, sizeof(&amp;arr[0] + 1)); //4/8 第二个元素的地址
</code></pre>

<h4 id="字符数组2">字符数组2</h4>

<pre><code class="language-C++">char arr[] = &quot;abcdef&quot;;

printf(&quot;%d\n&quot;, strlen(arr));     //6
printf(&quot;%d\n&quot;, strlen(arr + 0)); //6
//printf(&quot;%d\n&quot;, strlen(*arr));//err
//printf(&quot;%d\n&quot;, strlen(arr[1]));//err
printf(&quot;%d\n&quot;, strlen(&amp;arr));        //6 &amp;arr - 数组的地址-数组指针 char(*p)[7] = &amp;arr;
printf(&quot;%d\n&quot;, strlen(&amp;arr + 1));    //随机值
printf(&quot;%d\n&quot;, strlen(&amp;arr[0] + 1)); //5

printf(&quot;%d\n&quot;, sizeof(arr));         //sizeof(arr)计算的数组的大小，单位是字节：7
printf(&quot;%d\n&quot;, sizeof(arr + 0));     //4/8 计算的是地址的大小-arr + 0是首元素的地址
printf(&quot;%d\n&quot;, sizeof(*arr));        //1 *arr 是首元素，sizeof(*arr)计算首元素的大小
printf(&quot;%d\n&quot;, sizeof(arr[1]));      //1 arr[1]是第二个元素，sizeof(arr[1])计算的是第二个元素的大小
printf(&quot;%d\n&quot;, sizeof(&amp;arr));        //4/8 &amp;arr虽然是数组的地址，但也是地址，所以是4/8个字节
printf(&quot;%d\n&quot;, sizeof(&amp;arr + 1));    //4/8 &amp;arr+1是跳过整个数组后的地址，但也是地址
printf(&quot;%d\n&quot;, sizeof(&amp;arr[0] + 1)); //4/8 &amp;arr[0]+1 第二个元素的地址
</code></pre>

<h4 id="字符数组3">字符数组3</h4>

<pre><code class="language-C++">char *p = &quot;abcdef&quot;; //把常量字符串abcdef的a的地址放到p

printf(&quot;%d\n&quot;, strlen(p));     //6
printf(&quot;%d\n&quot;, strlen(p + 1)); //5
//printf(&quot;%d\n&quot;, strlen(*p));//err
//printf(&quot;%d\n&quot;, strlen(p[0]));//err
printf(&quot;%d\n&quot;, strlen(&amp;p));        //随机值 小端存储
printf(&quot;%d\n&quot;, strlen(&amp;p + 1));    //随机值
printf(&quot;%d\n&quot;, strlen(&amp;p[0] + 1)); //5

printf(&quot;%d\n&quot;, sizeof(p));         //4/8 - 计算指针变量p的大小
printf(&quot;%d\n&quot;, sizeof(p + 1));     //4/8 - p+1 得到的是字符b的地址
printf(&quot;%d\n&quot;, sizeof(*p));        //1 *p 就是字符串的第一个字符 - 'a'
printf(&quot;%d\n&quot;, sizeof(p[0]));      //1  int arr[10];  arr[0] == *(arr+0)    p[0] == *(p+0) == 'a'
printf(&quot;%d\n&quot;, sizeof(&amp;p));        //4/8  地址 a的地址
printf(&quot;%d\n&quot;, sizeof(&amp;p + 1));    //4/8 地址 b的地址
printf(&quot;%d\n&quot;, sizeof(&amp;p[0] + 1)); //4/8 地址 b的地址
</code></pre>

<p>&amp;p 和 &amp;p+1 【图中地址为捏造，举例】</p>

<p><img src="../img/10/p.png" alt="Image text" /></p>

<h3 id="二维数组">二维数组</h3>

<pre><code class="language-C++">//二维数组
int a[3][4] = {0};
//printf(&quot;%p\n&quot;, &amp;a[0][0]);  //00000009A9B4F6E8 第一行第一个元素的地址
//printf(&quot;%p\n&quot;, a[0] + 1);  //00000009A9B4F6EC 第一行第二个元素的地址 64位
//printf(&quot;%p\n&quot;, a + 1);     //00000009A9B4F6F8 第二行的地址
//printf(&quot;%p\n&quot;, &amp;a[0] + 1); //00000009A9B4F6F8 第二行的地址

printf(&quot;%d\n&quot;, sizeof(a));       //48
printf(&quot;%d\n&quot;, sizeof(a[0][0])); //4
printf(&quot;%d\n&quot;, sizeof(a[0]));    //16 a[0]相当于第一行做为一维数组的数组名，
//sizeof(arr[0])把数组名单独放在sizeof()内，计算的是第一行的大小

printf(&quot;%d\n&quot;, sizeof(a[0] + 1)); //4/8 - a[0]是第一行的数组名，数组名此时是首元素的地址，a[0]其实就是第一行第一个元素的地址
//所以 a[0]+1 就是第一行第二个元素的地址- 地址大小是4/8个字节

printf(&quot;%d\n&quot;, sizeof(*(a[0] + 1))); //4- *(a[0] + 1)) 是第一行第二个元素，大小是4个字节
printf(&quot;%d\n&quot;, sizeof(a + 1));       //4/8     //a是二维数组的数组名，没有sizeof(a)，也没有&amp;(a),所以a是首元素地址
//而把二维数组看成一维数组时，二维数组的首元素是他的第一行，a就是第一行（首元素）的地址
//a+1就是第二行的地址

printf(&quot;%d\n&quot;, sizeof(*(a + 1)));     //16, sizeof(a[1]) 计算第二行的大小,单位是字节
printf(&quot;%d\n&quot;, sizeof(&amp;a[0] + 1));    //4/8, 第二行的地址
printf(&quot;%d\n&quot;, sizeof(*(&amp;a[0] + 1))); //16 计算第二行的大小，单位是字节
printf(&quot;%d\n&quot;, sizeof(*a));           //16 a是首元素地址-第一行的地址，*a就是第一行，sizeof(*a)就是计算第一行的大小
printf(&quot;%d\n&quot;, sizeof(a[3]));         //16 sizeof()括号里不参与真实运算，sizeof(a[3])等价sizeof(a[0])
</code></pre>

<p><img src="../img/10/二维数组.png" alt="Image text" /></p>

<h3 id="指针相关">指针相关</h3>

<h4 id="指针加减整数的运算1">指针加减整数的运算1</h4>

<pre><code class="language-C++">int a[5] = { 1, 2, 3, 4, 5 };
int *ptr = (int *)(&amp;a + 1);
printf( &quot;%d,%d&quot;, *(a + 1), *(ptr - 1)); //2 5
</code></pre>

<p><img src="../img/10/指针相关1.png" alt="Image text" /></p>

<h4 id="指针加减整数的运算2">指针加减整数的运算2</h4>

<pre><code class="language-C++">//结构体的大小是20个字节
struct Test
{
    int Num;
    char *pcName;
    short sDate;
    char cha[2];
    short sBa[4];
} * p;
//假设p 的值为0x100000。 如下表表达式的值分别为多少？
int main()
{
    p = (struct Test *)0x100000;
    printf(&quot;%p\n&quot;, p + 0x1);                 //00100014 32位 0x100000+20
    printf(&quot;%p\n&quot;, (unsigned long)p + 0x1);  //00100001 32位 p转换成10进制=1,048,576+1
    printf(&quot;%p\n&quot;, (unsigned int *)p + 0x1); //00100004 32位 (unsigned int *)无符号整型指针 就是指针+1(int指针为4/8)
    return 0;
}
</code></pre>

<p><img src="../img/10/指针相关2.png" alt="Image text" />
<img src="../img/10/指针相关2-2.png" alt="Image text" /></p>

<h4 id="指针加减整数的运算3">指针加减整数的运算3</h4>

<pre><code class="language-C++">int a[4] = { 1, 2, 3, 4 };
int *ptr1 = (int *)(&amp;a + 1);
int *ptr2 = (int *)((int)a + 1);//a是首元素地址，强制转换成整数+1.在转换成地址，相当于向后偏移了一个字节
printf(&quot;%x,%x&quot;, ptr1[-1], *ptr2);//4，2000000
</code></pre>

<p><img src="../img/10/指针相关2-3.png" alt="Image text" /></p>

<h4 id="指针加减整数的运算4">指针加减整数的运算4</h4>

<pre><code class="language-C++">int a[3][2] = { (0, 1), (2, 3), (4, 5) };//（，）逗号表达式，存储逗号后内容
int *p;
p = a[0];

printf(&quot;%d\n&quot;, p[0]);//1
</code></pre>

<p><img src="../img/10/指针相关2-4.png" alt="Image text" /></p>

<h4 id="指针加减整数的运算5">指针加减整数的运算5</h4>

<pre><code class="language-C++">int a[5][5];
int(*p)[4];
p = a;//int (*)[4]  ----- int (*) [5]  【会有警告】
printf(&quot;%p,%d\n&quot;, &amp;p[4][2] - &amp;a[4][2], &amp;p[4][2] - &amp;a[4][2]);//FFFFFFFC,-4
</code></pre>

<p><img src="../img/10/指针相关2-5.png" alt="Image text" /></p>

<h4 id="指针加减整数的运算6">指针加减整数的运算6</h4>

<pre><code class="language-C++">int aa[2][5] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int *ptr1 = (int *)(&amp;aa + 1);
int *ptr2 = (int *)(*(aa + 1));              // aa[1]
printf(&quot;%d,%d\n&quot;, *(ptr1 - 1), *(ptr2 - 1)); //10 5

int arr[10] = {1,2,3,4,5};
int* p = arr;
//*(p + 2) == p[2] ==&gt; *(arr+2) == arr[2]
arr[2]; // ==&gt; *(arr+2)
</code></pre>

<p><img src="../img/10/指针相关2-6.png" alt="Image text" /></p>

<h4 id="指针加减整数的运算7">指针加减整数的运算7</h4>

<pre><code class="language-C++">char* a[] = { &quot;work&quot;, &quot;at&quot;, &quot;alibaba&quot; };
char**pa = a;

pa++;
printf(&quot;%s\n&quot;, *pa);//
</code></pre>

<p><img src="../img/10/指针相关2-7.png" alt="Image text" /></p>

<h4 id="指针加减整数的运算8">指针加减整数的运算8</h4>

<pre><code class="language-C++">char *c[] = {&quot;ENTER&quot;, &quot;NEW&quot;, &quot;POINT&quot;, &quot;FIRST&quot;};
char **cp[] = {c + 3, c + 2, c + 1, c};
char ***cpp = cp;

printf(&quot;%s\n&quot;, **++cpp);         //POINT
printf(&quot;%s\n&quot;, *--*++cpp + 3);   //ER
printf(&quot;%s\n&quot;, *cpp[-2] + 3);    //ST
printf(&quot;%s\n&quot;, cpp[-1][-1] + 1); //EW
</code></pre>

<p><img src="../img/10/指针相关2-8.png" alt="Image text" /></p>

<h4 id="旋转字符串">旋转字符串</h4>

<p>实现一个函数，可以左旋字符串中的k个字符。</p>

<pre><code>例如：
ABCD左旋一个字符得到BCDA
ABCD左旋两个字符得到CDAB
</code></pre>

<ol>
<li><p>暴力求解法</p>

<pre><code class="language-C++">#include &lt;string.h&gt;
#include &lt;assert.h&gt;
void left_move(char* arr, int k)
{
    assert(arr != NULL);
    int i = 0;
    int len = strlen(arr);
    for (i = 0; i &lt; k; i++)
    {
        //左旋转一个字符
        //1
        char tmp = *arr;
        //2
        int j = 0;
        for (j = 0; j &lt; len-1; j++)
        {
            *(arr + j) = *(arr + j + 1);
        }
        //3
        *(arr + len - 1) = tmp;
    }
}
int main()
{
    char arr[] = &quot;abcdef&quot;;
    left_move(arr, 2);

    printf(&quot;%s\n&quot;, arr);

    return 0;
}
</code></pre></li>

<li><p>三步翻转法</p>

<pre><code>abcdef  
ab cdef 左边逆序，右边逆序
bafedc 整体逆序
cdefab
</code></pre>

<pre><code class="language-C++">#include &lt;string.h&gt;
#include &lt;assert.h&gt;
//逆序字符串的函数
void reverse(char* left, char* right)
{
    assert(left != NULL);
    assert(right != NULL);
    while (left &lt; right)
    {
        char tmp = *left;
        *left = *right;
        *right = tmp;
        left++;
        right--;
    }
}

void left_move(char* arr, int k)
{
    assert(arr);
    int len = strlen(arr);
    assert(k &lt;= len); //不能超过字符长度

    reverse(arr, arr + k - 1);//逆序左边
    reverse(arr + k, arr + len - 1);//逆序右边
    reverse(arr, arr + len - 1);//逆序整体
}

int main()
{
    char arr[] = &quot;abcdef&quot;;
    left_move(arr, 2);
    printf(&quot;%s\n&quot;, arr);
    return 0;
}
</code></pre></li>
</ol>

<h4 id="字符串旋转结果">字符串旋转结果</h4>

<p>写一个函数，判断一个字符串是否为另一个字符串旋转之后的字符串。</p>

<pre><code>例如给定 s1=AABCD和s2=BCDAA,返回1
给定s1=abcd和s2=ACBD,返回0

AABCD左旋一个字符得到ABCDA
AABCD左旋两个字符得到BCDAA
AABCD右旋一个字符得到DAABC
</code></pre>

<ol>
<li><p>穷举法</p>

<pre><code class="language-C++">int is_left_move(char* str1, char* str2)
{
    int len = strlen(str1);
    int i = 0;
    for (i = 0; i &lt; len; i++)
    {
        left_move(str1, 1);//调用上题代码，每次旋转s1都会变化
        int ret = strcmp(str1, str2);
        if (ret == 0) {
            return 1;
        }
    }
    return 0;
}
int main()
{
    char arr1[] = &quot;abcdef&quot;;
    char arr2[] = &quot;cdefab&quot;;
    int ret = is_left_move(arr1, arr2);
    if (ret == 1)
    {

        printf(&quot;Yes\n&quot;);
    }
    else
    {
        printf(&quot;No\n&quot;);
    }

    return 0;
}
</code></pre></li>

<li><p>追加法</p>

<pre><code>abcdef
cdefab
abcdefabcdef
</code></pre>

<pre><code class="language-C++">#include &lt;string.h&gt;
#include &lt;assert.h&gt;
int is_left_move(char* str1, char* str2)
{
    int len1 = strlen(str1);
    int len2 = strlen(str2);
    if (len1 != len2)
        return 0;

    //1. 在str1字符串中追加一个str1字符串
    //strcat(str1, str1);//err 自己给自己追加不能使用该方法\0不会停下来
    strncat(str1, str1, len1);//abcdefabcdef
    //2. 判断str2指向的字符串是否是str1指向的字符串的子串
    //strstr-找子串的
    char * ret = strstr(str1, str2);
    if (ret == NULL)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

int main()
{
    char arr1[30] = &quot;abcdef&quot;;
    char arr2[] = &quot;cdef&quot;;
    int ret = is_left_move(arr1, arr2);
    if (ret == 1)
    {

        printf(&quot;Yes\n&quot;);
    }
    else
    {
        printf(&quot;No\n&quot;);
    }

    return 0;
}
</code></pre>

<p>注： strcat 示例</p>

<pre><code class="language-C++">#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    char arr1[30] = &quot;abc&quot;;
    char arr2[] = &quot;def&quot;;
    strcat(arr1, arr2);
    printf(&quot;%s\n&quot;, arr1); //abcdef

    return 0;
}
</code></pre></li>
</ol>

<h4 id="杨氏矩阵">杨氏矩阵</h4>

<pre><code>有一个数字矩阵，矩阵的每行从左到右是递增的，矩阵从上到下是递增的，
请编写程序在这样的矩阵中查找某个数字是否存在。
要求：时间复杂度小于O(N);

1 2 3
4 5 6
7 8 9

1 2 3
2 3 4
3 4 5
</code></pre>

<p><img src="../img/10/杨氏矩阵.png" alt="Image text" /></p>

<pre><code class="language-C++">//int FindNum(int arr[3][3], int k, int row, int col)
//{
//  int x = 0;
//  int y = col - 1;
//
//  while (x&lt;=row-1 &amp;&amp; y&gt;=0)
//  {
//      if (arr[x][y] &gt; k)
//      {
//          y--;
//      }
//      else if (arr[x][y] &lt; k)
//      {
//          x++;
//      }
//      else
//      {
//          return 1;
//      }
//  }
//  //找不到
//  return 0;
//}
//
int FindNum(int arr[3][3], int k, int *px, int*py)
{
    int x = 0;
    int y = *py - 1;

    while (x &lt;= *px - 1 &amp;&amp; y &gt;= 0)
    {
        if (arr[x][y] &gt; k)
        {
            y--;
        }
        else if (arr[x][y] &lt; k)
        {
            x++;
        }
        else
        {
            *px = x;
            *py = y;
            return 1;
        }
    }
    //找不到
    return 0;
}
int main()
{
    int arr[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, {7,8,9} };
    int k = 7;
    int x = 3;
    int y = 3;

    //返回型参数
    int ret = FindNum(arr, k, &amp;x, &amp;y);
    if (ret == 1)
    {
        printf(&quot;找到了\n&quot;);
        printf(&quot;下标是：%d %d\n&quot;, x, y);
    }
    else
    {
        printf(&quot;找不到\n&quot;);
    }
    return 0;
}

</code></pre>

          </div>

          


          
          <div class="article-widget">
            
<div class="post-nav">
  
  
  
  <div class="post-nav-item">
    <div class="meta-nav">上一页</div>
    <a href="/tutorial/c/9/" rel="next"></a>
  </div>
  
  
  
  <div class="post-nav-item">
    <div class="meta-nav">下一页</div>
    <a href="/tutorial/c/11/" rel="prev"></a>
  </div>
  
</div>


          </div>
          
        </div>

        <div class="body-footer">
          最近更新于 2021-02-20
        </div>
       
      </article>
      



<link rel="stylesheet" href="/css/gitalk.css">
<script src="/js/gitalk/md5.min.js"></script>
<script src="/js/gitalk/gitalk.min.js"></script>

<div id="gitalk-container"></div>
<script type="text/javascript">
  
   
 
 var gitalk = new Gitalk({
    clientID: '10a6d5d1d3fbd4240caf',
    clientSecret: '3df97152f7b0637c0d6dca7cd06eac30b4b908e3',
    repo: 'cytgenkidu.github.io',
    owner: 'cytgenkidu',
    admin: ['cytgenkidu'],
    
    id: md5(location.pathname),
    distractionFreeMode: false 
  });
  gitalk.render('gitalk-container');
</script>

      <footer class="site-footer">
  
  <p class="powered-by">
    <a href="/privacy/">Privacy Policy</a>
  </p>
  

  <p class="powered-by">
    &copy; 2019 &middot; 

    Powered by the
    
    <a href="https://github.com/cytgenkidu" target="_blank" rel="noopener">cytgenkidu</a> 
    <i class="fas fa-heart" style="color: red;"></i>
    .

    
  </p>
</footer>


    </main>
  </div>
</div>

    

    
    

    
    
    
      <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha512-+NqPlbbtM1QqiK8ZAo4Yrj2c4lNQoGv8P79DPtKzj++l5jnN39rHA/xsqn8zE9l0uSoxaCdrOgFs6yjyfbBxSg==" crossorigin="anonymous"></script>
      <script src="https://cdn.bootcdn.net/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
      <script src="https://cdn.bootcdn.net/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        
        <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
        
      

      
      
    

    
    

    
    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "搜索...",
        'results': "搜索结果",
        'no_results': "没有找到结果"
      };
      const content_type = {
        'post': "文章",
        'project': "项目",
        'publication' : "出版物",
        'talk' : "演讲"
        };
    </script>
    

    
    
    <script src="https://cdn.bootcdn.net/ajax/libs/anchor-js/4.1.1/anchor.min.js" integrity="sha256-pB/deHc9CGfFpJRjC43imB29Rse8tak+5eXqntO94ck=" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdn.bootcdn.net/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.d7381f2d79e6271d4da28f474f49096c.js"></script>

  </body>
</html>


